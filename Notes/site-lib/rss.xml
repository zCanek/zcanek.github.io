<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[GZ]]></title><description><![CDATA[Obsidian digital garden]]></description><link>canekzamudio.com</link><image><url>canekzamudio.com/site-lib/media/favicon.png</url><title>GZ</title><link>canekzamudio.com</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 28 Jan 2026 22:50:45 GMT</lastBuildDate><atom:link href="canekzamudio.com/site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 28 Jan 2026 22:50:43 GMT</pubDate><copyright><![CDATA[Canek]]></copyright><ttl>60</ttl><dc:creator>Canek</dc:creator><item><title><![CDATA[CBC - Cyber-Block Chaining]]></title><description><![CDATA[This is what ensures that no two blocks (even if they contain identical plaintext) will encrypt to the same ciphertext. It does this by mixing the ciphertext from the previous round into the plaintext of the next round using the XOR operator. In mathematical notation:
Let = the plaintext, and = the plaintext of block .
Let = the corresponding ciphertext, and = the ciphertext of block .
Let = the number of blocks ( and have the same number of blocks by definition).
Let = the initialization vector - a random string - frequently (incorrectly) set to all zeroes.
Let = a single-block encryption operation (any block encryption algorithm, such as AES or DES, it doesn't matter which), with some unique and unknown (to the attacker) secret key (that we don't notate here).
Let = the corresponding decryption operation.
We can define the encrypted ciphertexct -- in terms of the encryption algorithm, the plaintext, and the initialization vector:<img alt="Pasted image 20260128110417.png" src="canekzamudio.com/assets/pasted-image-20260128110417.png" target="_self">Decryption is the opposite:<br><img alt="Pasted image 20260128110814.png" src="canekzamudio.com/assets/pasted-image-20260128110814.png" target="_self"><br>
Once all blocks are decrypted, the <a data-href="Padding" href="canekzamudio.com/indexes/cryptography/padding.html" class="internal-link" target="_self" rel="noopener nofollow">Padding</a> on the last block is validated.]]></description><link>canekzamudio.com/indexes/cryptography/cbc-cyber-block-chaining.html</link><guid isPermaLink="false">Indexes/Cryptography/CBC - Cyber-Block Chaining.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 28 Jan 2026 17:17:31 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.3.1 Unsigned Addition]]></title><description><![CDATA[Consider two nonnegative integers x and y, such that 0 ≤ x, y &lt; 2w. Each of these values can be represented by a w-bit unsigned number. If we compute their sum, however, we have a possible range 0 ≤ x + y ≤ 2w+1 − 2. Representing this sum could require w + 1 bits.Figure 2.21 shows a plot of the function x + y when x and y have 4-bit representations. The arguments (shown on the horizontal axes) range from 0 to 15, but the sum ranges from 0 to 30. The shape of the function is a sloping plane (the function is linear in both dimensions). If we were to maintain the sum as a (w + 1)-bit number and add it to another value, we may require w + 2 bits, and so on.
<img alt="Pasted image 20250807171802.png" src="canekzamudio.com/assets/pasted-image-20250807171802.png" target="_self">
This continued "word size inflation" means we cannot place any bound on the word size required to fully represent the results of arithmetic operations.Let us define the operation for arguments and , where , as the result of truncating the integer sum to be bits long and then viewing the result as an unsigned number.
This can be characterized as a form of modular arithmetic, computing the sum modulo by simply discarding any bits with weight greater than in the bit-level representation of . For example, consider a -bit number representation with and , having bit representations and , respectively. Their sum is 21, having a 5-bit representation . But if we discard the high-order bit, we get [0101], that is, decimal value 5. This matches the value 21 mod 16 = 5.So we can characterize operation as follows:Unsigned addition
For and such that : -^u_w x =
\begin{cases}
x, &amp; x = 0 \quad \
2^w − x, &amp; x &gt; 0 \quad
\end{cases}]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.1-unsigned-addition.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.1 Unsigned Addition.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 28 Jan 2026 01:45:16 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.1.8 Logical Operations in C]]></title><description><![CDATA[Operators ||, &amp;&amp;, and ! treat any nonzero argument as representing TRUE and argument 0 FALSE. They return either 1 or 0 (true or false).
<img alt="Pasted image 20250724134626.png" src="canekzamudio.com/assets/pasted-image-20250724134626.png" target="_self"><br>
An important distinction between the logical operators ‘&amp;&amp;’ and ‘||’ versus their <a data-tooltip-position="top" aria-label="2.1.7 Bitwise operators" data-href="2.1.7 Bitwise operators" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html" class="internal-link" target="_self" rel="noopener nofollow">bit-level</a> counterparts ‘&amp;’ and ‘|’ is that the logical operators do not evaluate their second argument if the result of the expression can be determined by evaluating the first argument. Thus, for example, the expression a &amp;&amp; 5/a will never cause a division by zero, and the expression p &amp;&amp; *p++ will never cause the dereferencing of a null <a data-tooltip-position="top" aria-label="Pointers" data-href="Pointers" href="canekzamudio.com/indexes/coding/c/pointers.html" class="internal-link" target="_self" rel="noopener nofollow">pointer</a>.]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.8-logical-operations-in-c.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.8 Logical Operations in C.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Tue, 27 Jan 2026 23:58:27 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[4.1.3 Instruction Encoding]]></title><description><![CDATA[Each instruction requires between 1 and 10 bytes, depending on which fields are required. All have an initial byte identifying the instruction type. This byte is split into two 4-bit parts, the high-order, or code part, and the low-order, or function part.
<img alt="Pasted image 20260122194808.png" src="canekzamudio.com/assets/pasted-image-20260122194808.png" target="_self" style="width: 550px; max-width: 100%;"><br>
Each of the 15 program <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a>s has an associated register identifier (ID) ranging from 0 to same as in x86-64, the program registers are stored within the <a data-href="CPU" href="canekzamudio.com/cs_app/glossary/cpu.html" class="internal-link" target="_self" rel="noopener nofollow">CPU</a> in a register file, a small random access memory where the register IDs serve as addresses. ID is used when we need to indicate that no register should be accessed.<br>
<img alt="Pasted image 20260122211607.png" src="canekzamudio.com/assets/pasted-image-20260122211607.png" target="_self" style="width: 560px; max-width: 100%;">
Some instructions are just 1 byte long, but those that require operands have longer encodings. First, there can be an additional register specifier byte, dpecifying either one or two registers. These register fields are called rA and rB, they can specify the registers used for data sources and destinations, as well as the base register used in an address computation.<br>
<img alt="Pasted image 20260122212355.png" src="canekzamudio.com/assets/pasted-image-20260122212355.png" target="_self">
Some instructions require an additional 8-byte constant word. This word can serve as an immediate data. As with x86-64, all integers have a little-endian encoding.Instruction byte encoding Let us generate the byte encoding of the instruction rmmovq %rsp, 0x123456789abcd (%rdx) in hexadecimal. We can see that rmmovq has initial byte 40, source register %rsp should be encoded in the rA field, and base register %rdx should be encoded in the rB field, so we get a register specifier byte of 42. Finally, the displacement is encoded in the 8-byte constant word . Combining these, we get an instruction encoding of:
4042cdab896745230100 ]]></description><link>canekzamudio.com/cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.3-instruction-encoding.html</link><guid isPermaLink="false">CS_APP/IV. Processor Arch/4.1 Y86-64 ISA/4.1.3 Instruction Encoding.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Fri, 23 Jan 2026 03:47:38 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[4.1.2 Y86-64 Instructions]]></title><description><![CDATA[<img alt="Pasted image 20260122172120.png" src="canekzamudio.com/assets/pasted-image-20260122172120.png" target="_self" style="width: 560px; max-width: 100%;">
<br>The x86-64 <a data-href="MOV" href="canekzamudio.com/indexes/coding/assembly-x86/mov.html" class="internal-link" target="_self" rel="noopener nofollow">MOV</a>Q instruction is split into four different instructions: irmovq, rrmovq, mrmovq and rmmovq, explicitly indicating the form of the source and destination. The source is either immediate (i), register (r), or memory (m), it is designated by the first character in the instruction name. The destination is either register(r) or memory(m).
<br>There are four integer operation instructions, as OPq. These are addq, subq, and xorq. They operate only on register data, whereas x86-64 also allows operations on memory data. These instructions set the three <a data-tooltip-position="top" aria-label="3.6.1 Condition Codes" data-href="3.6.1 Condition Codes" href="canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html" class="internal-link" target="_self" rel="noopener nofollow">condition codes</a> ZF, SF, and OF (zero, sign, and overflow).
<br>The seven <a data-href="JUMP" href="canekzamudio.com/indexes/coding/assembly-x86/jump.html" class="internal-link" target="_self" rel="noopener nofollow">JUMP</a> instructions, as jXX are jmp, jle, jl, je, jne, jge, and jg. Branches are taken according to the type of branch and the settings of the condition codes.
There are six conditional move instructions as cmovXX: cmovle, cmovl, cmove, cmovne, cmovge, and cmovg. These have the same format as the register-register move instruction rrmovq, but destination register is updated only if the condition codes satisfy the required constraints.
The halt instruction stops instruction execution. x86-64 has a comparable instruction called hlt but common application programs are not permitted to use this instruction since it causes the entire system to suspend operation. In Y86-64, executing the halt instruction causes the processor to stop, with the status code set to HLT.
]]></description><link>canekzamudio.com/cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.2-y86-64-instructions.html</link><guid isPermaLink="false">CS_APP/IV. Processor Arch/4.1 Y86-64 ISA/4.1.2 Y86-64 Instructions.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Fri, 23 Jan 2026 01:12:41 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[4.1.1 Programmer-Visible State]]></title><description><![CDATA[Each instruction in a Y86-64 program can read and modify some part of the processor state. This is referred to as the programmer-visible state, where the "programmer" in this case is either someone writing programs in <a data-href="assembly" href="canekzamudio.com/assembly.html" class="internal-link" target="_self" rel="noopener nofollow">assembly</a> code or a compiler generating machine-level code.<br>Similar to x86-64. There are 15 program <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a>s, each of these stores a 64-bit word. Register %rsp is used as <a data-tooltip-position="top" aria-label="3.7.1 The Run-Time Stack" data-href="3.7.1 The Run-Time Stack" href="canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html" class="internal-link" target="_self" rel="noopener nofollow">stack</a> pointer by the <a data-tooltip-position="top" aria-label="push &amp; pop" data-href="push &amp; pop" href="canekzamudio.com/indexes/coding/assembly-x86/push-&amp;-pop.html" class="internal-link" target="_self" rel="noopener nofollow">push, pop</a>, <a data-href="call" href="canekzamudio.com/indexes/coding/assembly-x86/call.html" class="internal-link" target="_self" rel="noopener nofollow">call</a>, and return instructions. There are three single-bit condition codes, ZF, SF and OF, storing information about the effect of the most recent arithmetic or logical instruction. The program counter (PC) holds the address of the instruction currently being executed.<br>
<img alt="Pasted image 20260122171049.png" src="canekzamudio.com/assets/pasted-image-20260122171049.png" target="_self" style="width: 490px; max-width: 100%;"><br>
The memory is conceptually a large array of bytes, holding both program and data. Y86-64 programs reference memory locations using <a data-tooltip-position="top" aria-label="virtual memory" data-href="virtual memory" href="canekzamudio.com/cs_app/glossary/virtual-memory.html" class="internal-link" target="_self" rel="noopener nofollow">virtual addresses</a>, a combination of hardware and <a data-href="Operating System" href="canekzamudio.com/cs_app/glossary/operating-system.html" class="internal-link" target="_self" rel="noopener nofollow">Operating System</a> software translates these into the actual or physical, addresses indicating where the values are actually stored in memory.The status code Stat, indicates the overall state of program execution. It will indicate either normal operation or that some sort of exception has occurred, such as when an instruction attempts to read from an invalid memory address.]]></description><link>canekzamudio.com/cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.1-programmer-visible-state.html</link><guid isPermaLink="false">CS_APP/IV. Processor Arch/4.1 Y86-64 ISA/4.1.1 Programmer-Visible State.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 22 Jan 2026 23:18:43 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Intro]]></title><description><![CDATA[A <a data-tooltip-position="top" aria-label="CPU" data-href="CPU" href="canekzamudio.com/cs_app/glossary/cpu.html" class="internal-link" target="_self" rel="noopener nofollow">processor</a> must execute a sequence of instructions, where each instruction performs some priomitive operation. An instruction is encoded in binary form as a sequence of 1 or more bytes. The instructions supported by a particular processor and their byte-level encodings are known as its instruction set architecture (ISA).Different "families" of processors, such as x86-64, have different ISAs, there are many different models of processors within a single family. Each manufacturer producesprocessors of ever-growing performance and complex, but the different models remain compatible at the ISA level. Thus the ISA provides a conceptual layer of abstraction between compiler writers, who need only know what instructions are permitted and how they are encoded, and processors designers, who must build machines that execute those instructions.Note
The actual way a modern processor operates can be quite different from the model of computation implied by the ISA. The ISA model would seem to imply sequential instruction execution, wherre each instruction is fetched and executed to completion before the next one begins. By executing different parts of multiple instructions simultaneously, the processor can achieve higher performance than if it executed just one instruction at a time. Special mechanisms are used to make sure the processor computes the same results as it would with sequential execution.
]]></description><link>canekzamudio.com/cs_app/iv.-processor-arch/intro.html</link><guid isPermaLink="false">CS_APP/IV. Processor Arch/Intro.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 21 Jan 2026 22:58:16 GMT</pubDate></item><item><title><![CDATA[3.10.5 Supporting Variable-Size Stack Frames]]></title><description><![CDATA[Some functions require a variable amount of local storage. i.e., when the function calls alloca a standard library function that can allocate an arbitrary number of bytes of storage on the stack. It can also occur when the code declares a local array of variable size...]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.5-supporting-variable-size-stack-frames.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.5 Supporting Variable-Size Stack Frames.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 21 Jan 2026 22:27:45 GMT</pubDate></item><item><title><![CDATA[3.10.4 Thwarting Buffer Overflow Attacks]]></title><description><![CDATA[In order to insert exploit code into a system, the attacker needs to inject both the code as well as a pointer to this code as part of the attack string. Generating this <a data-tooltip-position="top" aria-label="3.10.1 Understanding Pointers" data-href="3.10.1 Understanding Pointers" href="canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.1-understanding-pointers.html" class="internal-link" target="_self" rel="noopener nofollow">pointer</a> requires knowing the <a data-tooltip-position="top" aria-label="3.7.1 The Run-Time Stack" data-href="3.7.1 The Run-Time Stack" href="canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html" class="internal-link" target="_self" rel="noopener nofollow">stack</a> address where the string will be located. Historically, the stack addresses for a program were highly predictable. So if an attacker could determine the stack addresses used by a common <a data-tooltip-position="top" aria-label="Web page, Website, Web server > Web Server" data-href="Web page, Website, Web server#Web Server" href="canekzamudio.com/indexes/web/web-page,-website,-web-server.html" class="internal-link" target="_self" rel="noopener nofollow">web server</a>, it could devise an attack that would work on many machines.Stack randomization is to make the position of the stack vary from one run of a program to another. Thus, even if many machines are running identical code, they would all be using different stack addresses. This is implemented by allocating a random amount of space between and bytes on the stack at the start of a program, the addresses range of nearly .A persistent attacker can overcome randomization by brute force, repeatedly attempting attacks with different addresses. A common trick is to include a long sequence of nop(no operation) instructions before the actual exploit code. This only increments the program counter to the next instruction. As long as the attacker can guess an address somewhere within this sequence, the program will run through the sequence and then hit the exploit code.A corruption typically occurs when the program overruns the bounds of a local buffer. In C, there is no reliable way to prevent writing beyond the bounds of an array. instead, the program can attempt to detect when such a write has occurred before it can have any harmful effects.<br>GCC incorporates a mechanism known as stack protector into the generated code to detect buffer overruns. The idea is to store a special canary value in the stack frame between any local buffer and the rest of the stack state. This canary value (or guard value) is generated randomly each time the program runs, and so there is no easy way for an attacker to determine what it is. Before restoring the <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a> state and returning from the function, the program checks if the canary has been altered by some operation of this function or one that it has called. If so, the program aborts with an error.<br>
<img alt="Pasted image 20251020154933.png" src="canekzamudio.com/assets/pasted-image-20251020154933.png" target="_self" style="width: 530px; max-width: 100%;">
The instruction argument %fs:40 is an indication that the canary value is read from memory using segmented addressing, by storing the canary in a special segment, it can be marked as "read only", so that an attacker cannot overwrite the stored canary value. Before restoring the register state and returning, the function compares the value stored at the stack location with the canary value (via a xorq instruction). If the two are identical, the xorq instruction will yield zero, and the function will complete in the normal fashion. A nonzero value indicates that the canary on the stack has been modified, and so the code will call an error routine. A final step is to eliminate the ability of an attacker to insert executable code into a system. One method is to limit which memory regions hold executable code. In typical programs, only the portion of memory holding the code generated by the compiler need be executable. The other portions can be restricted to allow just reading and writing. The hardware supports different forms of memory protection, indicating the forms of access allowed by both user programs and the operating system kernel, like an NX (for "no-execute") bit into the memory, by this the stack can be marked as being readable and writable, but not executable, and the checking of whether a page is executable is performed in hardware, with no penalty in efficiency.]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.4-thwarting-buffer-overflow-attacks.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.4 Thwarting Buffer Overflow Attacks.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Tue, 21 Oct 2025 03:11:29 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.10.3 Out-of-Bounds Memory References and Buffer Overflow]]></title><description><![CDATA[C does not perform any bounds checking for array references, and local variables are stored on the <a data-tooltip-position="top" aria-label="3.7.1 The Run-Time Stack" data-href="3.7.1 The Run-Time Stack" href="canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html" class="internal-link" target="_self" rel="noopener nofollow">stack</a> along with state information such as saved <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a> values and return addresses. This combination can lead to serious program errors, where the state stored on the stack gets corrupted by a write to an out-of-bounds <a data-tooltip-position="top" aria-label="3.8.1 Array Basic Principles" data-href="3.8.1 Array Basic Principles" href="canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html" class="internal-link" target="_self" rel="noopener nofollow">array</a> element. When the program then tries to reload the register or execute a ret instruction with this corrupted state, things can go seriously wrong.Typically, some character array is allocated on the stack to hold a string, but the size of the string exceeds the space allocated for the array. This is demonstrated by the following program:/* Implementation of library function gets() */
char *gets(char *s)
{ int c; char *dest = s; while ((c = getchar()) != ’\n’ &amp;&amp; c != EOF) *dest++ = c; if (c == EOF &amp;&amp; dest == s) /* No characters read */ return NULL; *dest++ = ’\0’; /* Terminate string */ return s;
} /* Read input line and write it back */
void echo()
{ char buf[8]; /* Way too small! */ gets(buf); puts(buf);
}
The code demonstrates a serious problem with the function gets. It reads a line from the standard input, stopping when either a terminating newline character or some error condition is encountered. It copies this string to the location designated by argument s and terminates the string with a null character. We show the use of gets in the function echo, which simply reads a line from standard input and echos it back to standard output.<br>
<img alt="Pasted image 20251018225151.png" src="canekzamudio.com/assets/pasted-image-20251018225151.png" target="_self" style="width: 550px; max-width: 100%;">
The problem with gets is that it has no way to determine whether sufficient space has been allocated to hold the entire string. In our echo example, we have purposely made the buffer very small, just eight characters long. Any string longer than seven characters will cause an out-of-bounds write.
By examining the assembly code generated by GCC for echo, we can infer how the stack is
organized:// void echo() echo: subq $24, %rsp // Allocate 24 bytes on stack movq %rsp, %rdi // Compute buf as %rsp call gets // Call gets movq %rsp, %rdi // Compute buf as %rsp call puts // Call puts addq $24, %rsp // Deallocate stack space ret // Return
<br>The program allocates 24 bytes on the stack by <a data-tooltip-position="top" aria-label="3.4.4 Pushing and Popping Stack Data" data-href="3.4.4 Pushing and Popping Stack Data" href="canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.4-pushing-and-popping-stack-data.html" class="internal-link" target="_self" rel="noopener nofollow">subtracting</a> 24 from the stack pointer. Character buf is positioned at the top of the stack, as can be seen by the fact that %rsp is copied to %rdi to be used as the argument to the calls to both gets and puts. The 16 bytes between buf and the stored return pointer are not used. As long as the user types at most seven characters, the string returned by gets (including the terminating null) will fit within the space allocated for buf.
A longer string, however, will cause gets to overwrite some of the information stored on the
stack. As the string gets longer, the following information will get corrupted:If the stored value of the return address is corrupted then the ret instruction (line 8) will cause the program to jump to a totally unexpected location.
A better version of echo involves using the function fgets, which includes as an argument a count on the maximum number of bytes to read.
<br>Buffer Overflow working
Typically, the program is fed with a string that contains the byte encoding of some executable code, called the exploit code, plus some extra bytes that overwrite the return address with a pointer to the exploit code. The effect of executing the ret instruction is then to jump to the exploit code.
In one form of attack, the exploit code then uses a system call to start up a <a data-href="Shell" href="canekzamudio.com/cs_app/glossary/shell.html" class="internal-link" target="_self" rel="noopener nofollow">Shell</a> program, providing the attacker with a range of <a data-href="Operating System" href="canekzamudio.com/cs_app/glossary/operating-system.html" class="internal-link" target="_self" rel="noopener nofollow">Operating System</a> functions
]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.3 Out-of-Bounds Memory References and Buffer Overflow.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Mon, 20 Oct 2025 21:12:48 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.1 The Run-Time Stack.md</guid></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.1 Array Basic Principles.md</guid></item><item><title><![CDATA[3.8.4 Fixed-Size Arrays]]></title><description><![CDATA[Suppose we declare data type fix_matrix to be 16 x 16 arrays of integers as follows:#define N 16 typedef int fix_matrix[N][N];
The code in Figure 3.37(a) computes element , of the product of arrays and —that is, the inner product of row from and column from . This product is given by the formula <img alt="Pasted image 20250908124256.png" src="canekzamudio.com/assets/pasted-image-20250908124256.png" target="_self" style="width: 550px; max-width: 100%;"><br>
Gcc generates code that we then recoded into C, shown as function fix_prod_ele_opt in Figure(b). This code optimizes by removing the integer index and converts all array references to <a data-href="Pointers" href="canekzamudio.com/indexes/coding/c/pointers.html" class="internal-link" target="_self" rel="noopener nofollow">Pointers</a> dereferences. This involves:
Generating a pointer, which we have named Aptr, that points to successive elements in row of Generating a pointer, which we have named Bptr, that points to successive elements in column of Generating a pointer, which we have named Bend, that equals the value Bptr will have when it is time to terminate the loop. The initial value for Aptr is the address of the first element of row of , given by the expression . The initial value for Bptr is the address of the first element of column of , given by the expression . The value for Bend is the index of what would be the ()st element in column of , given by the C expression .<br>This is the actual assembly code generated by gcc for function fix_ prod_ele. We see that four <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a>s are used as follows: %eax holds result, %rdi holds Aptr, %rcx holds Bptr, and %rsi holds Bend.# int fix_prod_ele_opt(fix_matrix A, fix_matrix B, long i, long k)
A in %rdi, B in %rsi, i in %rdx, k in %rcx 1 fix_prod_ele:
2 salq $6, %rdx # Compute 64 * i
3 addq %rdx, %rdi # Compute Aptr = X_A + 64i = &amp;A[i][0]
4 leaq (%rsi,%rcx,4), %rcx # Compute Bptr = x_b + 4k = &amp;B[0][k]
5 leaq 1024(%rcx), %rsi # Compute Bend = x_B + 4k + 1024 = &amp;B[N][k]
6 movl $0, %eax # Set result = 0
7 .L7: # loop:
8 movl (%rdi), %edx # Read *Aptr
9 imull (%rcx), %edx # Multiply by *Bptr
10 addl %edx, %eax # Add to result
]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.4-fixed-size-arrays.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.4 Fixed-Size Arrays.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 19 Oct 2025 04:41:48 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.8.3 Nested Arrays]]></title><description><![CDATA[The declartaionint A[5][3];
is equivalent to the declarationtypedef int row3_t[3];
row3_t A[5];
Data type row3_t is defined to be an array of three integers. Array contains five such elements, each requiring 12 bytes to store the three integers. The total array size is then Array can also be viewed as a two-dimensional array with five rows and three columns, referenced as through . The array elements are ordered in memory in row-major order, meaning all elements of row 0, which can be written , followed by all elements of row 1 (), and so on.
<img alt="Pasted image 20250908121209.png" src="canekzamudio.com/assets/pasted-image-20250908121209.png" target="_self" style="width: 350px; max-width: 100%;"><br>
Viewing as an array of five elements, each of which is an array of three int’s, we first have , followed by , and so on. To access elements of multidimensional arrays, the compiler generates code to compute the offset of the desired element and then uses one of the <a data-href="MOV" href="canekzamudio.com/indexes/coding/assembly-x86/mov.html" class="internal-link" target="_self" rel="noopener nofollow">MOV</a> instructions with the start of the array as the base address and the (possibly scaled) offset as an index. In general, for an array declared as array element is at memory address where is the size of data type in bytes. Consider the 5 × 3 integer array defined earlier. Suppose , , and are in registers %rdi, %rsi, and %rdx, respectively. Then array element A[i][j] can be copied to register %eax by the following code:<br>
<img alt="Pasted image 20250908121735.png" src="canekzamudio.com/assets/pasted-image-20250908121735.png" target="_self" style="width: 470px; max-width: 100%;">
This code computes the element's address as using the scaling and addition capabilities of x86 address arithmetic.]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.3-nested-arrays.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.3 Nested Arrays.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 19 Oct 2025 04:39:39 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.10.1 Understanding Pointers]]></title><description><![CDATA[<a data-href="Pointers" href="canekzamudio.com/indexes/coding/c/pointers.html" class="internal-link" target="_self" rel="noopener nofollow">Pointers</a> serve as a uniform way to generate references to elements within different data structures.This type indicates what kind of object the pointer points to, consider the following code:int *ip;
char **cpp;
variable ip is a pointer to an object of type int, while cpp is a pointer to an object that itself is a pointer to an object of type char. In general, if the object has type T , then the pointer has type *T. The special void * type represents a generic pointer.
For example, the malloc function returns a generic pointer, which is converted to a typed pointer via either an explicit cast or by the implicit casting of the assignment operation. Pointer types are not part of machine code; they are an abstraction provided by C to help programmers avoid addressing errors.This value is an address of some object of the designated type. The special NULL (0) value indicates that the pointer does not point anywhere.<br>This operator can be applied to any C expression that is categorized as an lvalue, meaning an expression that can appear on the left side of an assignment. Examples include variables and the elements of structures, unions, and arrays. We have seen that the machine code realization of the &amp; operator often uses the <a data-href="leaq" href="canekzamudio.com/indexes/coding/assembly-x86/leaq.html" class="internal-link" target="_self" rel="noopener nofollow">leaq</a> instruction to compute the expression value, since this instruction is designed to compute the address of a memory reference.The result is a value having the type associated with the pointer. Dereferencing is implemented by a memory reference, either storing to or retrieving from the specified address.The name of an array can be referenced (but not updated) as if it were a pointer variable. Array referencing (a[3]) has the exact same effect as pointer arithmetic and dereferencing ( *(a+3)). Both array referencing and pointer arithmetic require scaling the offsets by the object size. When we write an expression p+i for pointer p with value p, the resulting address is computed as , where is the size of the data type associated with p.One effect of casting is to change any scaling of pointer arithmetic. So, for example, if p is a pointer of type char* having value p, then the expression (int *) p+7 computes p + 28, while (int *) (p+7) computes p + 7. (Recall that casting has higher precedence than addition.)This provides a powerful capability for storing and passing references to code, which can be invoked in some other part of the program. For example, if we have a function defined by the proto-typeint fun(int x, int *p);
then we declare and assign a pointer fp to this function by the following code sequence:int (*fp)(int, int *);
fp = fun;
We can then invoke the function using this pointer:int y = 1;
int result = fp(3, &amp;y);
The value of a function pointer is the address of the first instruction in the machine-code representation of the function.Function pointers
For a declaration such as int (*f)(int*); it helps to read it starting from the inside (starting with ‘f’) and working outward. Thus, we see that f is a pointer, as indicated by (*f). It is a pointer to a function that has a single int * as an argument, as indicated by (*f)(int*). Finally, we see that it is a pointer to a function that takes an int * as an argument and returns int. The parentheses around *f are required, because otherwise the declaration int *f(int*); would be read as (int *) f(int*); That is, it would be interpreted as a function prototype, declaring a function f that has an int * as its argument and returns an int *.
]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.1-understanding-pointers.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.1 Understanding Pointers.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 16 Oct 2025 05:41:42 GMT</pubDate></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.3-data-alignment.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.9 Heterogeneous Data Structures/3.9.3 Data Alignment.md</guid></item><item><title><![CDATA[3.9.2 Unions]]></title><description><![CDATA[Unions provide a way to circumvent the type system of C, allowing a single object to be referenced according to multiple types. the syntax of a union declaration is identical to that for structures, but its semantics are very different. Rather than having the different fields reference different blocks of memory, they all reference the same block.
Consider the next declarations:struct S3 { char c; int i[2]; double v;
}; union U3 { char c; int i[2]; double v;
};
When compiled on an x86-64 Linux machine, the offsets of the fields, as well as the total size of data types S3 and U3, are as shown in the following table:For pointer of type union U3 *, references p-&gt;c, p-&gt;i[0], and p-&gt;v would all reference the beginning of the data structure. Observe also that the overall size of a union equals the maximum size of any of its fields.
Unions can be useful in several contexts. One application is when we know in advance that the use of two different fields in a data structure will be mutually exclusive. Then, declaring these two fields as part of a union rather than a structure will reduce the total space allocated. For example, suppose we want to implement a binary tree data structure where each leaf node has two double data values and each internal node has pointers to two children but no data. If we declare this as:struct node_s { struct node_s *left; struct node_s *right; souble data[2];
};
then every node requires 32 bytes, with half the bytes wasted for each type of node. On the other hand, if we declare a node as:union node_u { struct { union node_u *left; union node_u *right; } internal; double data[2];
};
then every node will require just 16 bytes. If is a pointer to a node of type union node_u *, we would reference to the data of a leaf node as n-&gt;data[0] and n-&gt;data[1], and the children of an internal node as n-&gt;internal.left and n-&gt;internal.right.More on <a data-tooltip-position="top" aria-label="CS_APP.pdf > page=299&amp;selection=0,0,0,18&amp;color=important" data-href="CS_APP.pdf#page=299&amp;selection=0,0,0,18&amp;color=important" href="canekzamudio.com/cs_app/cs_app.html#page=299&amp;selection=0,0,0,18&amp;color=important" class="internal-link" target="_self" rel="noopener nofollow">CS_APP, p.299</a>...]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.2-unions.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.9 Heterogeneous Data Structures/3.9.2 Unions.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sat, 11 Oct 2025 23:16:42 GMT</pubDate></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.1-structures.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.9 Heterogeneous Data Structures/3.9.1 Structures.md</guid></item><item><title><![CDATA[Transistor]]></title><description><![CDATA[Transistors are microscopic crystals of silicon that use electrical properties of silicon to act as switches. Modern computers have what are referred to as field-effect transistors]]></description><link>canekzamudio.com/cs_app/glossary/transistor.html</link><guid isPermaLink="false">CS_APP/Glossary/Transistor.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Fri, 10 Oct 2025 22:39:40 GMT</pubDate></item><item><title><![CDATA[TIB, TEB & PEB]]></title><description><![CDATA[These structures are stored inside the process memory, and their main function is to include all the information about the process and each thread, as well as make them accessible to the code so that it can easily know the process filename, the loaded <a data-href="DLL" href="canekzamudio.com/indexes/malware/dll.html" class="internal-link" target="_self" rel="noopener nofollow">DLL</a>s, and other related information.<br>They can all be accessed through a special segment <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a>, either FS (32-bit) or GS ( 64-bit), like this:mov eax, DWORD PTR FS:[XX]
<br>This contains the context of the <a data-tooltip-position="top" aria-label="threads" data-href="threads" href="canekzamudio.com/cs_app/glossary/threads.html" class="internal-link" target="_self" rel="noopener nofollow">thread</a>.This structure starts with the TIB, which is then followed by additional thread-related fields. In many cases, the terms TIB and TEB are used interchangeably. <br>This includes various information about the process, such as its name, ID (PID), and a list of modules (which includes all the <a data-tooltip-position="top" aria-label="PE Header" data-href="PE Header" href="canekzamudio.com/indexes/malware/windows/pe-structure/pe-header.html" class="internal-link" target="_self" rel="noopener nofollow">PE</a> files that have been loaded in memory – mainly the program itself and the <a data-href="DLL" href="canekzamudio.com/indexes/malware/dll.html" class="internal-link" target="_self" rel="noopener nofollow">DLL</a>s).]]></description><link>canekzamudio.com/cs_app/glossary/tib,-teb-&amp;-peb.html</link><guid isPermaLink="false">CS_APP/Glossary/TIB, TEB &amp; PEB.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Fri, 19 Sep 2025 04:17:33 GMT</pubDate></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/glossary/threads.html</link><guid isPermaLink="false">CS_APP/Glossary/threads.md</guid></item><item><title><![CDATA[virtual memory]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Software" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Software">#Software</a> Virtual memory is an abstraction that provides each process with the illusion that it has exclusive use of the main memory. Each process has the same uniform view of memory, which is known as its virtual address space.<br><img alt="Pasted image 20250715115553.png" src="canekzamudio.com/assets/pasted-image-20250715115553.png" target="_self"><br>
In Linux, the topmost region of the address space is reserved for code and data in the <a data-tooltip-position="top" aria-label="Operating System" data-href="Operating System" href="canekzamudio.com/cs_app/glossary/operating-system.html" class="internal-link" target="_self" rel="noopener nofollow">OS</a> that is common to all <a data-href="processes" href="canekzamudio.com/cs_app/glossary/processes.html" class="internal-link" target="_self" rel="noopener nofollow">processes</a>. The lower region of the address space holds the code and data defined by the user's process. Note that addresses in the figure increase from the bottom to the top. Code begins at the same fixed address for all processes, followed by data locations that correspond to global C variables. The code and data areas are initialized directly from the contents of an executable object file (in this case the hello executable) The code and data areas are followed immediately by the run-time heap. Unlike the code and data areas, which are fixed in size once the process begins running, the heap expands and contracts dynamically at run time as a result of calls to C standard library routines such as malloc and free. Near the middle of the address space is an area that holds the code and data for shared libraries such as the C standard library and the math library. The notion of a shared library is a powerful but somewhat difficult concept. At the top of the user's virtual address space is the user stack that the compiler uses to implement function calls. Like the heap, the user stack expands and contracts dynamically during the execution of the program. In particular, each time we call a function, the stack grows. Each time we return from a function, it contracts. The top region of the address space is reversed for the kernel. Application programs are not allowed to read or write the contents of this area or to directly call functions defined in the kernel code. Instead, they must invoke the kernel to perform these operations.
For virtual memory to work, a hardware translation of every address generated by the processor is required. The basic idea is to store the contents of a process's virtual memory on disk and then use the main memory as a cache for the disk.This virtual memory has a mapper to the equivalent physical memory. Not all virtual memory addresses are mapped to physical memory, and each one that’s been mapped has a permission (READ|WRITE, READ|EXECUTE, or maybe READ|WRITE|EXECUTE), as shown in the following diagram:<br>
<img alt="Pasted image 20250917213940.png" src="canekzamudio.com/assets/pasted-image-20250917213940.png" target="_self" style="width: 570px; max-width: 100%;">
Virtual memory allows you to create a security layer between one process and another and allows the operating system to manage different processes and suspend one process to give resources to another.]]></description><link>canekzamudio.com/cs_app/glossary/virtual-memory.html</link><guid isPermaLink="false">CS_APP/Glossary/virtual memory.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 18 Sep 2025 03:40:02 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/glossary/processes.html</link><guid isPermaLink="false">CS_APP/Glossary/processes.md</guid></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/glossary/multi-core-processor.html</link><guid isPermaLink="false">CS_APP/Glossary/multi-core processor.md</guid></item><item><title><![CDATA[ISA - Instruction Set Architecture]]></title><description><![CDATA[The ISA defines the format and behaviour of a machine-level program.Defines:
Processor state
Format of the instructions
The effect each of these instructions will have on the state
Most ISAs, like x86 one, describe the behavior of a program as if each instruction is executed in sequence, with one instruction completing before the next one begins.
The processor hardware is far more elaborate, executing many instructions concurrently, but it employs safeguards to ensure that the overall behavior matches the sequential operation dictated by the ISA. Two big groups of architectures define main <a data-href="assembly" href="canekzamudio.com/assembly.html" class="internal-link" target="_self" rel="noopener nofollow">assembly</a> languages :CISC assembly languages, such as Intel IA-32 and x64, have more complex instructions. They generally focus on completing tasks using as few lines of assembly instructions as possible.
To do so, some instructions can perform multiple operations, such as mul in Intel assembly,
which performs data access, multiplication, and data store operations in one go.In the RISC assembly language, assembly instructions are simple and generally perform only one operation each. This may lead to more lines of code to complete a specific task, but it may also be more efficient, as this omits the execution of any unnecessary operations.]]></description><link>canekzamudio.com/cs_app/glossary/isa-instruction-set-architecture.html</link><guid isPermaLink="false">CS_APP/Glossary/ISA - Instruction Set Architecture.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 11 Sep 2025 03:57:42 GMT</pubDate></item><item><title><![CDATA[3.8.5 Variable-Size Arrays]]></title><description><![CDATA[See in the book...]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.5-variable-size-arrays.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.5 Variable-Size Arrays.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 10 Sep 2025 18:28:07 GMT</pubDate></item><item><title><![CDATA[3.8.2 Pointer Arithmetic]]></title><description><![CDATA[C allows arithmetic on <a data-href="Pointers" href="canekzamudio.com/indexes/coding/c/pointers.html" class="internal-link" target="_self" rel="noopener nofollow">Pointers</a>, where the computed value is scaled according to the size of the data type referenced by the pointer. That is, if is a pointer to data of type , and the value of is , then the expression has value , where is the size of data type .The unary operators '&amp; ' and '*' allow the generation and dereferencing of pointers. That is, for an expression denoting some object, is a pointer giving the address of the object. For an expression denoting an address, gives the value at that address. The expressions and $&amp;Expr$ are therefore equivalent.
The array subscripting operation can be applied to both arrays and pointers. The array
reference is identical to the expression $(A+i)th array element and then accesses this memory location. Suppose the starting address of integer array and integer index are stored in registers %rdx and %rcx, respectively. The following are some expressions involving . Results are stored in either register %eax (for data) or register %rax (for pointers).<br>
<img alt="Pasted image 20250908115829.png" src="canekzamudio.com/assets/pasted-image-20250908115829.png" target="_self" style="width: 540px; max-width: 100%;">
Operations that return array values have type int, and hence involve 4-byte operations and registers. Those that return pointers have type int*, and hence involve 8-byte operations and registers
The final example shows that one can compute the difference of two pointers within the same data structure with the result being data type having type long and value equal to the difference of the two addresses divided by the size of the data type.
]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.2-pointer-arithmetic.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.2 Pointer Arithmetic.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Mon, 08 Sep 2025 18:03:55 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.6-recursive-procedures.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.6 Recursive Procedures.md</guid></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.5-local-storage-in-registers.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.5 Local Storage in Registers.md</guid></item><item><title><![CDATA[register]]></title><description><![CDATA[An x86 <a data-href="CPU" href="canekzamudio.com/cs_app/glossary/cpu.html" class="internal-link" target="_self" rel="noopener nofollow">CPU</a> contains a set of 16 general-purpose registers storing 64-bit values. These registers are used to store integer data as well as <a data-href="Pointers" href="canekzamudio.com/indexes/coding/c/pointers.html" class="internal-link" target="_self" rel="noopener nofollow">Pointers</a>. Their names all begin with %r, but otherwise follow multiple different naming conventions, owing to the historical evolution of the instruction set.<br>
<img alt="Pasted image 20250817140128.png" src="canekzamudio.com/assets/pasted-image-20250817140128.png" target="_self" style="width: 500px; max-width: 100%;">
Figure 3.2 Integer registers. The low-order portions of all 16 registers can be accessed as byte, word (16-bit), double word (32-bit), and quad word (64-bit) quantities.As the nested boxes above indicate, instructions can operate on data of different sizes stored in the low-order bytes of the 16 registers. Byte-level operations can access the least significant byte, 16-bit operations can access the least significant 2 bytes, 32-bit operations can access the least significant 4 bytes, and 64-bit operations can access entire registers.There are also a number of instructions for copying and generating 1, 2, 4, and 8-byte values. When these instructions have registers as destinations, two conventions arise for what happens to the remaining bytes in the register for instructions that generate less than 8 bytes: Those that generate 1 or 2-byte quantities leave the remaining bytes unchanged. Those that generate 4-byte quantities set the upper 4 bytes of the register to zero.x86 adopts a uniform set of conventions for register usage that must be respected by all procedures. By convention, registers %rbx, %rbp, and %r12 - %r15 are classified as callee-saved registers. When procedure P calls procedure Q, Q must preserve the values of these registers, ensuring that they have the same values when Q returns to P as they did when Q was called.
Procedure Q can preserve a register value by either not changing it at all or by pushing<br>
the original value on the stack, altering it, and then popping the old value from the stack before returning. The pushing of register values has the effect of creating the portion of the stack frame labeled “<a data-tooltip-position="top" aria-label="Pasted image 20250904115435.png" data-href="Pasted image 20250904115435.png" href="canekzamudio.com/assets/pasted-image-20250904115435.html" class="internal-link" target="_self" rel="noopener nofollow">Saved registers</a>” in Figure 3.25. With this convention, the code for P can safely store a value in a callee-saved register (after saving the previous value on the stack, of course), call Q, and then use the value in the register without risk of it having been corrupted. <br>All other registers, except for the <a data-tooltip-position="top" aria-label="3.7.1 The Run-Time Stack" data-href="3.7.1 The Run-Time Stack" href="canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html" class="internal-link" target="_self" rel="noopener nofollow">stack</a> pointer %rsp, are classified as caller-saved registers. This means that they can be modified by any function. The name “caller saved” can be understood in the context of a procedure P having some local data in such a register and calling procedure Q. Since Q is free to alter this register, it is incumbent upon P (the caller) to first save the data before it makes the call. ]]></description><link>canekzamudio.com/cs_app/glossary/register.html</link><guid isPermaLink="false">CS_APP/Glossary/register.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sat, 06 Sep 2025 20:17:07 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.4-local-storage-on-the-stack.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.4 Local Storage on the Stack.md</guid></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.3-data-transfer.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.3 Data Transfer.md</guid></item><item><title><![CDATA[3.7.2 Control Transfer]]></title><description><![CDATA[Passing control from function P to function Q involves simply setting the program counter (PC) to the starting address of the code for Q. This informations is recorded in x86 machines by invoking procedure Q with the instruction call Q.
callThis instruction pushes an address onto the stack and sets the PC to the beginning of Q. The pushed address is referred to as the return address and is computed as the address of the instruction immediately following the call instruction.
The counterpart instruction ret pops an address off the stack and sets the PC to .
<img alt="Pasted image 20250904134956.png" src="canekzamudio.com/assets/pasted-image-20250904134956.png" target="_self" style="width: 300px; max-width: 100%;"><br>
The call instruction has a target indicating the address of the instruction where the called procedure starts. Like <a data-href="JUMP" href="canekzamudio.com/indexes/coding/assembly-x86/jump.html" class="internal-link" target="_self" rel="noopener nofollow">JUMP</a>s, a call can be either direct or indirect. The target of a direct call is given as a label, while the target of an indirect call is given by "*" followed by an <a data-tooltip-position="top" aria-label="3.4.1 Operand Specifiers" data-href="3.4.1 Operand Specifiers" href="canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html" class="internal-link" target="_self" rel="noopener nofollow">operand specifier</a>.<br>
<img alt="Pasted image 20250904135618.png" src="canekzamudio.com/assets/pasted-image-20250904135618.png" target="_self"><br>
<img alt="Pasted image 20250904135903.png" src="canekzamudio.com/assets/pasted-image-20250904135903.png" target="_self" style="width: 500px; max-width: 100%;"><br>
In this code we can see that the call instruction with address 0x400563 in main calls function multstore. This status is shown in Figure 3.26(a), with the indicated values for the <a data-tooltip-position="top" aria-label="program stack" data-href="program stack" href="canekzamudio.com/cs_app/glossary/program-stack.html" class="internal-link" target="_self" rel="noopener nofollow">stack</a> pointer %rsp and the program counter %rip. The effect of the call is to push the return address 0x400568 onto the stack and to jump to the first instruction in function multstore, at address 0x0400540 (3.26(b)). The execution of function multstore continues until it hits the ret instruction at address 0x40054d. This instruction pops the value 0x400568 from the stack and jumps to this address, resuming the execution of main just after the call instruction (3.26(c)).<br>
<img alt="Pasted image 20250904141340.png" src="canekzamudio.com/assets/pasted-image-20250904141340.png" target="_self" style="width: 550px; max-width: 100%;">
Each instruction is identified by labels L1–L2 (in leaf), T1–T4 (in top), and M1–M2 in main.
Part (b) of the figure shows a detailed trace of the code execution, in which main calls top(100), causing top to call leaf(95). Function leaf returns 97 to top, which then return 194 to main.
Instruction L1 of leaf sets %rax to 97, the value to be returned. Instruction L2 then
returns. It pops 0x400054e from the stack. In setting the PC to this popped value, control
transfers back to instruction T3 of top.
The program has successfully completed the call to leaf and returned to top.
Instruction T3 sets %rax to 194, the value to be returned from top. Instruction T4 then returns. It pops 0x4000560 from the stack, thereby setting the PC to instruction M2 of main. The program has successfully completed the call to top and returned to main. We see that the stack pointer has also been restored to 0x7fffffffe820, the value it had before the call to top. We can see that this simple mechanism of pushing the return address onto the stack makes it possible for the function to later return to the proper point in the program.]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.2-control-transfer.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.2 Control Transfer.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 04 Sep 2025 20:00:07 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.7 Procedures]]></title><description><![CDATA[Also called functions or methods, procedures provide a way to package code that implements some functionality with a designated set of arguments and an optional return value. Procedures come in many guises in different programming languages—functions, methods, subroutines, handlers, and so on— but they all share a general set of features.There are many different attributes that must be handled when providing machine-level support for procedures. For discussion purposes, suppose procedure P calls procedure Q, and Q then executes and returns back to P. These actions involve one or more of the following mechanisms:
Passing control. The program counter must be set to the starting address of the code for Q upon entry and then set to the instruction in P following the call to Q upon return.
Passing data. P must be able to provide one or more parameters to Q, and Q must be able to return a value back to P.
Allocating and deallocating memory. Q may need to allocate space for local variables when it begins and then free that storage before it returns.
The x86-64 implementation of procedures involves a combination of special instructions and a set of conventions on how to use the machine resources, such as the <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a>s and the program memory. Great effort has been made to minimize the overhead involved in invoking a procedure.
As a consequence, it follows what can be seen as a minimalist strategy, implementing only as much of the above set of mechanisms as is required for each particular procedure. In our presentation, we build up the different mechanisms step by step, first describing control, then data passing, and, finally, memory management.]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7-procedures.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7 Procedures.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 04 Sep 2025 17:35:05 GMT</pubDate></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.8-switch-statements.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.8 Switch Statements.md</guid></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.7-loops.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.7 Loops.md</guid></item><item><title><![CDATA[3.6.6 Conditional Branches with Conditional Moves]]></title><description><![CDATA[As with <a data-tooltip-position="top" aria-label="Indexes/Coding/Assembly x86/SET" data-href="Indexes/Coding/Assembly x86/SET" href="canekzamudio.com/indexes/coding/assembly-x86/set.html" class="internal-link" target="_self" rel="noopener nofollow">SET</a> and <a data-href="JUMP" href="canekzamudio.com/indexes/coding/assembly-x86/jump.html" class="internal-link" target="_self" rel="noopener nofollow">JUMP</a> instructions, the outcome of these instructions depends on the values of the <a data-tooltip-position="top" aria-label="3.6.1 Condition Codes" data-href="3.6.1 Condition Codes" href="canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html" class="internal-link" target="_self" rel="noopener nofollow">condition codes</a>. The source value is read from either memory or the source <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a>, but it is copied to the destination only if the specified condition holds.Single byte conditional moves are not supportedThe conventional way to implement conditional operations is through a conditional transfer of control, this mechanism is simple and general, but it can be very inefficient on modern processors.An alternate strategy is through a conditional transfer of data. This approach computes both outcomes of a conditional operation and then selects one based on whether or not the condition holds.
This strategy makes sense only in restricted cases, but it can then be implemented by a simple conditional move instruction that is better matched to the performance characteristics of modern processors.(A) Shows code that can be compiled using a conditional move. The function computes the absolute value of its arguments and .<br>
<img alt="Pasted image 20250825133158.png" src="canekzamudio.com/assets/pasted-image-20250825133158.png" target="_self" style="width: 600px; max-width: 100%;">
For this function, gcc generates the assembly code shown in (C), alike to cmovdiff (b). in (b) version, we can see that it computes both and , naming these rval and eval, respectively. It then tests whether is greater than or equal to , and if so, copies eval to rval before returning rval. <br>The assembly code on (C) follows the same logic. The key is that the single cmovge instruction (line 7) of the assembly code implements the conditional assignment (line 8) of cmovdiff. It will transfer the data from the source <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a> to the destination, only if the cmpq instruction of line 6 indicates that one value is greater than or equal to the other. Processors achieve high performance through pipelining, where an instruction is processed via a sequence of stages, each performing one small portion of the required operations. This approach achieves high performance by overlapping the steps of the successive instructions, such as fetching one instruction while performing the arithmetic operations for a previous instruction.
To do this requires being able to determine the sequence of instructions to be
executed well ahead of time in order to keep the pipeline full of instructions to be executed. When the machine encounters a conditional jump (referred to as a “branch”), it cannot determine which way the branch will go until it has evaluated the branch condition.
Processors employ sophisticated branch prediction logic to try to guess whether or not
each jump instruction will be followed. As long as it can guess reliably (modern microprocessor achieve success rates of 90%), the instruction pipeline will be kept full of instructions. Mispredicting a jump, on the other hand, requires that the processor discard much of the work it has already done on future instructions and then begin filling the pipeline with instructions starting at the correct location.
Such a misprediction can incur a serious penalty, say, 15–30 clock cycles of wasted
effort, causing a serious degradation of program performance.Determining the penalty time for a misprediction
Assume the probability of misprediction is , the time to execute the code without misprediction is , and the misprediction penalty is . Then the average time to execute the code as a function of is . We are given and , the average time when , and we want to determine . Substituting into the equation, we get , and therefore . So, for and , we get . On the other hand, the code compiled using conditional moves requires around 8 clock cycles regardless of the data being tested. - The flow of control does not depend on data, and this makes it easier for the processor to keep its pipeline full. ]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.6-conditional-branches-with-conditional-moves.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.6 Conditional Branches with Conditional Moves.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 27 Aug 2025 17:48:28 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.5-conditional-branches-with-conditional-control.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.5 Conditional Branches with Conditional Control.md</guid></item><item><title><![CDATA[3.6.4 Jump instruction Encodings]]></title><description><![CDATA[In <a data-href="assembly" href="canekzamudio.com/assembly.html" class="internal-link" target="_self" rel="noopener nofollow">assembly</a> code, <a data-href="JUMP" href="canekzamudio.com/indexes/coding/assembly-x86/jump.html" class="internal-link" target="_self" rel="noopener nofollow">JUMP</a> targets are written using symbolic labels. The assembler, and later the linker, generate the proper encodings of the jump targets. There are several different encodings for jumps, but some of the most commonly used ones are PC relative. That is, they encode the difference between the address of the target instruction and the address of the instruction immediately following the jump. These offsets can be encoded using 1, 2, or 4 bytes. A second encoding method is to give an “absolute” address, using 4 bytes to directly specify the target. The assembler and linker select the appropriate encodings of the jump destinations. As an example of PC-relative addressing, the following assembly code for a function was generated by compiling a file branch.c. It contains two jumps: the jmp instruction on line 2 jumps forward to a higher address, while the jg instruction on line 7 jumps back to a lower one. movq %rdi, %rax jmp .L2
.L3: sarq %rax
.L2: testq %rax, %rax jg .L3 rep; ret
The disassembled version of the .o format generated by the assembler is as follows:0: 48 89 f8 mov %rdi,%rax 3: eb 03 jmp 8 &lt;loop+0x8&gt;
5: 48 d1 f8 sar %rax
8: 48 85 c0 test %rax, %rax
b: 7f f8 jg 5 &lt;loop+0x5&gt;
d: f3 c3 repz retq
<br>In this the jump targets are indicated as 0x8 and 0x5(the disassembler lists all number in <a data-tooltip-position="top" aria-label="2.1.1 Hexadecimal Notation" data-href="2.1.1 Hexadecimal Notation" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html" class="internal-link" target="_self" rel="noopener nofollow">hexadecimal</a>). Looking at the byte encodings of the instructions, we see that the target of the first jump instruction is encoded (in the second byte) as 0x03. Adding this to 0x5, the address of the following instruction, we get jump target address 0x8, the address of the instruction on line 4.Similarly, the target of the second jump is encoded as 0xf8(decimal -8), adding this to 0xd(decimal 13), the address of the instruction on line 6, we get 0x5, the address of the instruction on line 3The value of the program counter when performing PC-relative addressing is the address of the instruction following the jump, not that of the jump itself.This shows the disassembled version of the program after linking:4004d0: 48 89 f8 mov %rdi,%rax
4004d3: eb 03 jmp 4004d8 &lt;loop+0x8&gt;
4004d5: 48 d1 f8 sar %rax
4004d8: 48 85 c0 test %rax,%rax
4004db: 7f f8 jg 4004d5 &lt;loop+0x5&gt;
4004dd: f3 c3 repz retq
By using a PC-relative encoding of the jump targets, the instructions can be compactly encoded(requiring just 2 bytes). and the object code can be shifted to different positions in memory without alteration.
The jump instructions provide a means to implement conditional execution (if), as well as several different loop constructs.
]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.4-jump-instruction-encodings.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.4 Jump instruction Encodings.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Fri, 22 Aug 2025 19:43:48 GMT</pubDate></item><item><title><![CDATA[program stack]]></title><description><![CDATA[A stack is a data structure where values can be added or deleted, but only according to a "last-in, first-out" discipline.We add data to a stack via a <a data-tooltip-position="top" aria-label="push &amp; pop" data-href="push &amp; pop" href="canekzamudio.com/indexes/coding/assembly-x86/push-&amp;-pop.html" class="internal-link" target="_self" rel="noopener nofollow">push</a> operation and remove it via a <a data-tooltip-position="top" aria-label="push &amp; pop" data-href="push &amp; pop" href="canekzamudio.com/indexes/coding/assembly-x86/push-&amp;-pop.html" class="internal-link" target="_self" rel="noopener nofollow">pop</a> operation, with the property that the value popped will always be the value that was most recently pushed and is still on the stack.A stack can be implemented as an array, where we always insert and remove elements from one end of the array. This end is called the top of the stack. With x86, the program stack is stored in some region of memory.<br>
<img alt="Pasted image 20250819153309.png" src="canekzamudio.com/assets/pasted-image-20250819153309.png" target="_self" style="width: 550px; max-width: 100%;">
The stack grows downward such that the top element of the stack has the lowest address of all stack elements. The stack pointer %rsp holds the address of the top stack element.<br>The pushq instruction provides the ability to push data onto the stack, while the popq instruction pops it. Each of these instructions takes a single <a data-tooltip-position="top" aria-label="3.4.1 Operand Specifiers" data-href="3.4.1 Operand Specifiers" href="canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html" class="internal-link" target="_self" rel="noopener nofollow">operand</a>, the data source for pushing and the data destination por popping.Pushing a quad word value onto the stack involves first decrementing the stack pointer by 8 and then writing the value at the new top-of-stack address. Therefore, the behavior of the instruction pushq %rbp is equivalent to this of the pair of instructions:subq $8, %rsp //Decrement stack pointer
movq %rbp, (%rsp) //Store %rbp on stack
except that the pushq instruction is encoded in the machine code as a single byte, whereas the pair of instructions shown above requires a total of 8 bytes. The first two columns in Figure 3.9 illustrate the effect of executing the instruction pushq %rax when %rsp is 0x108 and %rax is 0x123. First %rsp is decremented by 8, giving 0x100, and then 0x123 is stored at memory address 0x100. Popping a quad word involves reading from the top-of-stack location and then incrementing the stack pointer by 8. Therefore, the instruction popq %rax is equivalent to the following pair of instructions:movq (%rsp), %rax //Read %rax from stack
addq $8, %rsp //Increment stack pointer
The third column of Figure 3.9 illustrates the effect of executing the instruction popq %edx immediately after executing the pushq. Value 0x123 is read from memory and written to register %rdx. Register %rsp is incremented back to 0x108. As shown in the figure, the value 0x123 remains at memory location 0x104 until it is overwritten (e.g., by another push operation). However, the stack top is always considered to be the address indicated by %rsp. <br>Since the stack is contained in the same memory as the program code and other forms of program data, programs can access arbitrary positions within the stack using the standard memory addressing methods. For example, assuming the topmost element of the stack is a quad word, the instruction movq 8(%rsp),%rdx will copy the second quad word from the stack to <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a> %rdx.]]></description><link>canekzamudio.com/cs_app/glossary/program-stack.html</link><guid isPermaLink="false">CS_APP/Glossary/program stack.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 21 Aug 2025 22:28:18 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.6.3 Jump Instructions]]></title><description><![CDATA[JUMPA jump instruction can cause the execution to switch to a completely new position in the program. These jump destinations are generally indicated in assembly code by a labelConsider the following assembly-code sequence:
<img alt="Pasted image 20250821143128.png" src="canekzamudio.com/assets/pasted-image-20250821143128.png" target="_self">
The instruction jmp .L1 will cause the program to skip over the movq instruction and instead resume execution with the popq instruction. In generating the object-code file, the assembler determines the addresses of all labeled instructions and encodes the jump targets (the addresses of the destination instructions) as part of the jump instructions.<br>
<img alt="Pasted image 20250821143052.png" src="canekzamudio.com/assets/pasted-image-20250821143052.png" target="_self" style="width: 600px; max-width: 100%;"><br>
The jmp instruction jumps unconditionally. It can be either a direct jump, where the jump target is encoded as part of the instruction, or an indirect jump, where the jump target is read from a <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a> or a memory location. Direct jumps are written in assembly code by giving a label as the jump target, for example, the label .L1 in the code shown. <br>Indirect jumps are written using * followed by an <a data-tooltip-position="top" aria-label="Operands - as" data-href="Operands - as" href="canekzamudio.com/indexes/coding/assembly-x86/operands-as.html" class="internal-link" target="_self" rel="noopener nofollow">operand specifier</a>. As examples, the instruction jmp *%rax uses the value in register %rax as the jump target, and the instruction jmp *(%rax) reads the jump target from memory, using the value in %rax as the read address. <br>The remaining jump instructions in the table are conditional—they either jump or continue executing at the next instruction in the code sequence, depending on some combination of the <a data-tooltip-position="top" aria-label="3.6.1 Condition Codes" data-href="3.6.1 Condition Codes" href="canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html" class="internal-link" target="_self" rel="noopener nofollow">condition codes</a>. The names of these instructions and the conditions under which they jump match those of the <a data-tooltip-position="top" aria-label="Indexes/Coding/Assembly x86/SET" data-href="Indexes/Coding/Assembly x86/SET" href="canekzamudio.com/indexes/coding/assembly-x86/set.html" class="internal-link" target="_self" rel="noopener nofollow">SET</a> instructions. As with the SET instructions, some of the underlying machine instructions have multiple names. Conditional jumps can only be direct.3.6.4 Jump instruction Encodings<br>In <a data-href="assembly" href="canekzamudio.com/assembly.html" class="internal-link" target="_self" rel="noopener nofollow">assembly</a> code, <a data-href="JUMP" href="canekzamudio.com/indexes/coding/assembly-x86/jump" class="internal-link" target="_self" rel="noopener nofollow">JUMP</a> targets are written using symbolic labels. The assembler, and later the linker, generate the proper encodings of the jump targets. There are several different encodings for jumps, but some of the most commonly used ones are PC relative. That is, they encode the difference between the address of the target instruction and the address of the instruction immediately following the jump. These offsets can be encoded using 1, 2, or 4 bytes. A second encoding method is to give an “absolute” address, using 4 bytes to directly specify the target. The assembler and linker select the appropriate encodings of the jump destinations. As an example of PC-relative addressing, the following assembly code for a function was generated by compiling a file branch.c. It contains two jumps: the jmp instruction on line 2 jumps forward to a higher address, while the jg instruction on line 7 jumps back to a lower one. movq %rdi, %rax jmp .L2
.L3: sarq %rax
.L2: testq %rax, %rax jg .L3 rep; ret
The disassembled version of the .o format generated by the assembler is as follows:0: 48 89 f8 mov %rdi,%rax 3: eb 03 jmp 8 &lt;loop+0x8&gt;
5: 48 d1 f8 sar %rax
8: 48 85 c0 test %rax, %rax
b: 7f f8 jg 5 &lt;loop+0x5&gt;
d: f3 c3 repz retq
<br>In this the jump targets are indicated as 0x8 and 0x5(the disassembler lists all number in <a data-tooltip-position="top" aria-label="2.1.1 Hexadecimal Notation" data-href="2.1.1 Hexadecimal Notation" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html" class="internal-link" target="_self" rel="noopener nofollow">hexadecimal</a>). Looking at the byte encodings of the instructions, we see that the target of the first jump instruction is encoded (in the second byte) as 0x03. Adding this to 0x5, the address of the following instruction, we get jump target address 0x8, the address of the instruction on line 4.Similarly, the target of the second jump is encoded as 0xf8(decimal -8), adding this to 0xd(decimal 13), the address of the instruction on line 6, we get 0x5, the address of the instruction on line 3The value of the program counter when performing PC-relative addressing is the address of the instruction following the jump, not that of the jump itself.This shows the disassembled version of the program after linking:4004d0: 48 89 f8 mov %rdi,%rax
4004d3: eb 03 jmp 4004d8 &lt;loop+0x8&gt;
4004d5: 48 d1 f8 sar %rax
4004d8: 48 85 c0 test %rax,%rax
4004db: 7f f8 jg 4004d5 &lt;loop+0x5&gt;
4004dd: f3 c3 repz retq
By using a PC-relative encoding of the jump targets, the instructions can be compactly encoded(requiring just 2 bytes). and the object code can be shifted to different positions in memory without alteration.
The jump instructions provide a means to implement conditional execution (if), as well as several different loop constructs.
]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.3-jump-instructions.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.3 Jump Instructions.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 21 Aug 2025 20:24:49 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.4.2 Data Movement Instructions]]></title><description><![CDATA[MOVThere are many different data movement instructions, differing in their source and destination types, what conversions they perform, and other side effects they may have.We group the many different instructions into instruction classes, where the instructions in a class perform the same operation but with different operand sizes.The mov class instructions copy data from a source location to a destination location, without any transformation. The class consists of four instructions:
movb
movw
movl
movq
These four have similar effects; they differ primarily in that they operate on data of different sizes: 1, 2, 4, and 8 bytes, respectively.
<img alt="Pasted image 20250818123607.png" src="canekzamudio.com/assets/pasted-image-20250818123607.png" target="_self" style="width: 450px; max-width: 100%;"><br>
The source operand designates a value that is immediate, stored in a <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a>, or stored in memory
The destination operand designates a location that is either a register or a memory address. Copying a value from one memory location to another requires two instructions:
The first to load the source value into a register
The second to write this register value to the destination
For most cases the MOV instructions will only update the specific register bytes or memory locations indicated by the destination operand. The only exception is that when movl has a register as the destination, it will also set the high-order 4 bytes of the register to 0.<br>
<img alt="Pasted image 20250818124727.png" src="canekzamudio.com/assets/pasted-image-20250818124727.png" target="_self"><br>
A final instruction movabsq is for dealing with 64-bit immediate data. The regular movq instruction can only have immediate source operands that can be represented as 32-bit <a data-tooltip-position="top" aria-label="2.2.3 Two's-Complement Encodings" data-href="2.2.3 Two's-Complement Encodings" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.3-two's-complement-encodings.html" class="internal-link" target="_self" rel="noopener nofollow">two's complement</a> numbers. This value is then sign extended to produce the 64-bit value for the destination. The movabsq instruction can have an arbitrary 64-bit immediate value as its source operand and can only have a register as a destination<br>This class is used when copying a smaller source value (in a register or memory address) to a larger destination(<a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a>).<br>
<img alt="Pasted image 20250818133441.png" src="canekzamudio.com/assets/pasted-image-20250818133441.png" target="_self">
Instructions in the MOVZ class fill out the remaining bytes of the destination with zeros, while those in the MOVS class fill them out by sign extension, replicating copies of the most significant bit of the source operand.Each instruction name has size designators as its final two characters, the first specifying the source size, and the second specifying the destination size.Note the absence of an explicit instruction to zero-extend a 4-byte source value to an 8-byte destination, this doesn't exist. Instead, this type of data movement can be implemented using a movl instruction having a register as the destination.<br><img alt="Pasted image 20250818134520.png" src="canekzamudio.com/assets/pasted-image-20250818134520.png" target="_self"><br>
Figure above also documents the ctlq instruction. This instruction has no operands, it always uses <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a> %eax as its source and %rax as the destination for the sign-extended result. It has the exact same effect as the instruction movslq %eax, %rax, but it has a more compact encoding.
x86 imposes the restriction that a move instruction cannot have both operands refer to memory locations
Understanding how data movement changes a destination register
There are two different conventions regarding wheter and how data movement instructions modify the upper bytes of a destination register. This distinction is illustrated by the following code sequence:<br>
<img alt="Pasted image 20250818135026.png" src="canekzamudio.com/assets/pasted-image-20250818135026.png" target="_self">
Instruction on line 1 initializes register %rax to the pattern 0x0011223344556677. The remaining instructions have immediate value -1(0xFF...F) as their source values.
The movb instruction on line 2 sets the low-order byte of %rax to FF, while the movw instruction on line 3 sets the low-order 2 bytes to FFFF, with the remaining bytes unchanged. The movl instruction on line 4 sets the low-order 4 bytes to FFFFFFFF, but it also sets the high-order 4 bytes to 00000000. Finally, the movq instruction on line 5 sets the complete register to FFFFFFFFFFFFFFFF.
Comparing byte movement instructions
The following example illustrates how different data movement instructions either do or do not change the high-order bytes of the destination. Observe that the three byte-movement instructions movb, movsbq, and movzbq differ from each other in subtle ways.<br>
<img alt="Pasted image 20250818141612.png" src="canekzamudio.com/assets/pasted-image-20250818141612.png" target="_self">
The first two lines of the code initialize registers %rax and %dl to 0011223344556677 and AA, respectively. The remaining instructions all copy the low-order byte of %rdx to the low-order byte of %rax. The movb instruction (line 3) does not change the other bytes. The movsbq instruction (line 4) sets the other 7 bytes to either all ones or all zeros depending on the high-order bit of the source byte. Since hexadecimal A represents binary value 1010, sign extension causes the higher-order bytes to each be set to FF. The movzbq instruction (line 5) always sets the other 7 bytes to zero.
]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.2-data-movement-instructions.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.2 Data Movement Instructions.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 21 Aug 2025 19:20:01 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.6.2 Accessing the Condition Codes]]></title><description><![CDATA[Rather than reading the condition codes directly, there are three common ways of using the condition codes:
We can set a single byte to 0 or 1 depending on some combination of the condition codes.
We can conditionally jump to some other part of the program.
We can conditionally transfer data.
SETThese instructions set a single byte to 0 or 1 depending on some combination of the <a data-tooltip-position="top" aria-label="3.6.1 Condition Codes" data-href="3.6.1 Condition Codes" href="canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html" class="internal-link" target="_self" rel="noopener nofollow">condition codes</a>, they differ from one another based on which combinations of condition codes they consider, as indicated by the different suffixes for the instruction names.
It is important to recognize that the suffixes for these instructions denote different<br>
conditions and not different <a data-tooltip-position="top" aria-label="Operands - as" data-href="Operands - as" href="canekzamudio.com/indexes/coding/assembly-x86/operands-as.html" class="internal-link" target="_self" rel="noopener nofollow">operand</a> sizes. For example, instructions setl and setb denote “set less” and “set below,” not “set long word” or “set byte.”<br>A SET instruction has either one of the low-order single-byte <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a> elements or a single-byte memory location as its destination, setting this byte to either 0 or 1, we must also clear the high-order bits.<br>
<img alt="Pasted image 20250821131150.png" src="canekzamudio.com/assets/pasted-image-20250821131150.png" target="_self" style="width: 570px; max-width: 100%;">
A typical instruction sequence to compute the C expression a &lt; b, where a and b are both of type long, proceeds as follows:<br>
<img alt="Pasted image 20250821131322.png" src="canekzamudio.com/assets/pasted-image-20250821131322.png" target="_self"><br>
Note the comparison order of the <a data-tooltip-position="top" aria-label="CMP &amp; TEST" data-href="CMP &amp; TEST" href="canekzamudio.com/indexes/coding/assembly-x86/cmp-&amp;-test.html" class="internal-link" target="_self" rel="noopener nofollow">cmpq</a> instruction . Although the arguments are listed in the order %rsi (b), then %rdi (a), the comparison is really between a and b. Recall also, that the <a data-tooltip-position="top" aria-label="MOV > MOVZ" data-href="MOV#MOVZ" href="canekzamudio.com/indexes/coding/assembly-x86/mov#MOVZ" class="internal-link" target="_self" rel="noopener nofollow">movzbl</a> instruction (line 4) clears the upper 4 bytes of the entire register, %rax, as well. For some of the underlying machine instructions, there are multiple possible names, which we list as “synonyms.” For example, both setg (for “set greater”) and setnle (for “set not less or equal”) refer to the same machine instruction.
Compilers and disassemblers make arbitrary choices of which names to use.
Although all arithmetic and logical operations set the condition codes, the descriptions of the different set instructions apply to the case where a comparison instruction has been executed, setting the condition codes according to the computation t = a-b.<br>
More specifically, let a, b, and t be the integers represented in <a data-tooltip-position="top" aria-label="2.2.3 Two's-Complement Encodings" data-href="2.2.3 Two's-Complement Encodings" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.3-two's-complement-encodings.html" class="internal-link" target="_self" rel="noopener nofollow">two's complement</a>
form by variables a, b, and t, respectively, and so , where depends on the sizes associated with a and b.Consider the sete instruction, When a = b, we will have t = 0, and hence the zero flag indicates equality]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.2-accessing-the-condition-codes.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.2 Accessing the Condition Codes.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 21 Aug 2025 19:04:49 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.1 Condition Codes.md</guid></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.5 Special Arithmetic Operations.md</guid></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.0-arithmetic-and-logical-operations.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.0 Arithmetic and Logical Operations.md</guid></item><item><title><![CDATA[3.4.1 Operand Specifiers]]></title><description><![CDATA[Operands - asMost instructions have one or more operands specifying the source values to use in performing an operation and the destination location into which to place the result.Source values can be given as constants or read from registers or memory. Results can be stored in either registers or memory. Thus, the different operand possibilities can be classified into three types
immediate, is for constant values. In ATT format assembly code, these are written with a "$" followed by an integer using standard C notation -i.e., $-577 or $0x1F. Different instructions allow different ranges of immediate values; the assembler will automatically select the most compact way of encoding a value.
<a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a>, denotes the contents of a register, one of the 16-, 8-, 4-, 2-, or 1-byte low-order portions of the registers for operands having 64, 32, 16, or 8 bits, respectively. n Figure 3.3, we use the notation to denote an arbitrary register and indicate its value with the reference , viewing the set of registers as an array indexed by register identifiers.
memory reference, in this we access some memory location according to a computed address, often called the effective address. Since we view the memory as a large array of bytes, we use the notation to denote a reference to the -byte value stored in memory starting at address Addr. To simplify things, we will generally drop the subscript .<br>
<img alt="Pasted image 20250817144946.png" src="canekzamudio.com/assets/pasted-image-20250817144946.png" target="_self" style="width: 550px; max-width: 100%;">
There are many different addressing modes allowing different forms of memory references. The most general form is shown at the bottom of the table with syntax . Such a reference has four components: an immediate offset , a base register , an index register , and a scale factor , where must be 1, 2, 4, or 8. Both the base and index must be 64-bit registers. The effective address is computed as . This general form is often seen when referencing elements of arrays. The other forms are simply special cases of this general form where some of the components are omitted.<br>
<img alt="Pasted image 20250817164321.png" src="canekzamudio.com/assets/pasted-image-20250817164321.png" target="_self">
]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.1 Operand Specifiers.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 20 Aug 2025 18:13:15 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.5.2 Unary and Binary Operations]]></title><description><![CDATA[Unary Operations - as<img alt="Pasted image 20250819172841.png" src="canekzamudio.com/assets/pasted-image-20250819172841.png" target="_self"><br>
These are unary operations, with the single <a data-tooltip-position="top" aria-label="Operands - as" data-href="Operands - as" href="canekzamudio.com/indexes/coding/assembly-x86/operands-as" class="internal-link" target="_self" rel="noopener nofollow">operand</a> serving as both source and destination. This operand can be either a <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a> or a memory location.<br>For example, the instruction incq (%rsp) causes the 8-byte element element on the top of the <a data-tooltip-position="top" aria-label="program stack" data-href="program stack" href="canekzamudio.com/cs_app/glossary/program-stack.html" class="internal-link" target="_self" rel="noopener nofollow">stack</a> to be incremented. This syntax is reminiscent of the C increment (++) and decrement (--) operators.Binary Operations - as<br><img alt="Pasted image 20250819173309.png" src="canekzamudio.com/assets/pasted-image-20250819173309.png" target="_self"><br>
In binary operations the second <a data-tooltip-position="top" aria-label="Operands - as" data-href="Operands - as" href="canekzamudio.com/indexes/coding/assembly-x86/operands-as" class="internal-link" target="_self" rel="noopener nofollow">operand</a> is used as both a source and a destination. Note that the source operand is given first and the destination second. This looks peculiar for non-commutative operations. For example, the instruction subq %rax,%rdx decrements register %rdx by the value in %rax. (It helps to read the instruction as “Subtract %rax from %rdx.”) <br>The first operand can be either an immediate value, a <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a>, or a memory location. The second can be either a register or a memory location. As with the <a data-tooltip-position="top" aria-label="MOV" data-href="MOV" href="canekzamudio.com/indexes/coding/assembly-x86/mov" class="internal-link" target="_self" rel="noopener nofollow">MOV</a> instructions, the two operands cannot both be memory locations. Note that when the second operand is a memory location, the processor must read the value from memory, perform the operation, and then write the result back to memory.
This syntax is reminiscent of the C assignment operators, such as x -= y
]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.2-unary-and-binary-operations.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.2 Unary and Binary Operations.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 20 Aug 2025 18:13:10 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.5.3 Shift Operations]]></title><description><![CDATA[Shift Operations - as<img alt="Pasted image 20250820121350.png" src="canekzamudio.com/assets/pasted-image-20250820121350.png" target="_self"><br>
In <a data-tooltip-position="top" aria-label="2.1.9 Shift Operations in C" data-href="2.1.9 Shift Operations in C" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html" class="internal-link" target="_self" rel="noopener nofollow">shift operations</a>, the shift amount is given first and the value to shift is given second, the different shift instructions can specify the shift amount either as an immediate value or with the single-byte <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a> %cl. (These instructions are unusual in only allowing this specific register as the operand.) In principle, having a 1-byte shift amount would make it possible to encode shift amounts ranging up to . With x86-64, a shift instruction operating on data values that are bits long determines the shift amount from the low-order bits of register %cl, where . The higher-order bits are ignored. So, for example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift by 63. There are two names for the left shift instruction: sal and shl. Both have the same effect, filling from the right with zeros. The right shift instructions differ in that sar performs an arithmetic shift (fill with copies of the sign bit), whereas shr performs a logical shift (fill with zeros). The destination operand of a shift operation can be either a register or a memory location.]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.3-shift-operations.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.3 Shift Operations.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 20 Aug 2025 18:12:38 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.5.1 Load Effective Address]]></title><description><![CDATA[leaqThe load effective address instruction leaq is actually a variant of the <a data-tooltip-position="top" aria-label="MOV > MOV" data-href="MOV#MOV" href="canekzamudio.com/indexes/coding/assembly-x86/mov#MOV" class="internal-link" target="_self" rel="noopener nofollow">movq</a> instruction. It has the form of an instruction that reads from memory to a register but it does not reference memory at all.Its first operand appears to be a memory reference, but instead of reading from the designated location, the instruction copies the effective address to the destination.<br>This instruction can be used to generate <a data-href="Pointers" href="canekzamudio.com/indexes/coding/c/pointers.html" class="internal-link" target="_self" rel="noopener nofollow">Pointers</a> for later memory references. Arithmetic operations with leaq In addition, it can be used to compactly describe common arithmetic operations. For example, if register %rdx contains value , then the instruction leaq 7(%rdx,%rdx,4), %rax will set register %rax to .<br>
Compilers often find clever uses of leaq that have nothing to do with effective address computations. The destination operand must be a <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a>.
As an illustration of the use of leaq in compiled code, consider the following C program:long scale(long x, long y, long z) { long t = x + 4 * y + 12 * z; return t;
}
When compiled, the arithmetic operations of the function are implemented by a sequence of three leaq functions://x in %rdi, y in %rsi, z in %rdx scale: leaq (%rdi, %rsi, 4), %rax // x + 4*y leaq (%rdx, %rdx, 2), %rdx // z + 2*z = 3*z leaq (%rax, %rdx, 4), %rax // (x+4*y) + 4*(3*z) = x + 4*y + 12*z
The ability of the leaq instruction to perform addition and limited forms of multiplication proves useful when compiling simple arithmetic expressions such as this example.]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.1-load-effective-address.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.1 Load Effective Address.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Tue, 19 Aug 2025 22:31:07 GMT</pubDate></item><item><title><![CDATA[3.4.4 Pushing and Popping Stack Data]]></title><description><![CDATA[push &amp; popThese two data movement operations are used to push data onto and pop data from the <a data-href="program stack" href="canekzamudio.com/cs_app/glossary/program-stack.html" class="internal-link" target="_self" rel="noopener nofollow">program stack</a>.<br>
<img alt="Pasted image 20250819150715.png" src="canekzamudio.com/assets/pasted-image-20250819150715.png" target="_self">
program stackA stack is a data structure where values can be added or deleted, but only according to a "last-in, first-out" discipline.<br>We add data to a stack via a <a data-tooltip-position="top" aria-label="push &amp; pop" data-href="push &amp; pop" href="canekzamudio.com/indexes/coding/assembly-x86/push-&amp;-pop" class="internal-link" target="_self" rel="noopener nofollow">push</a> operation and remove it via a <a data-tooltip-position="top" aria-label="push &amp; pop" data-href="push &amp; pop" href="canekzamudio.com/indexes/coding/assembly-x86/push-&amp;-pop" class="internal-link" target="_self" rel="noopener nofollow">pop</a> operation, with the property that the value popped will always be the value that was most recently pushed and is still on the stack.A stack can be implemented as an array, where we always insert and remove elements from one end of the array. This end is called the top of the stack. With x86, the program stack is stored in some region of memory.<br>
<img alt="Pasted image 20250819153309.png" src="canekzamudio.com/assets/pasted-image-20250819153309.png" target="_self" style="width: 550px; max-width: 100%;">
The stack grows downward such that the top element of the stack has the lowest address of all stack elements. The stack pointer %rsp holds the address of the top stack element.<br>The pushq instruction provides the ability to push data onto the stack, while the popq instruction pops it. Each of these instructions takes a single <a data-tooltip-position="top" aria-label="3.4.1 Operand Specifiers" data-href="3.4.1 Operand Specifiers" href="canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html" class="internal-link" target="_self" rel="noopener nofollow">operand</a>, the data source for pushing and the data destination por popping.Pushing a quad word value onto the stack involves first decrementing the stack pointer by 8 and then writing the value at the new top-of-stack address. Therefore, the behavior of the instruction pushq %rbp is equivalent to this of the pair of instructions:subq $8, %rsp //Decrement stack pointer
movq %rbp, (%rsp) //Store %rbp on stack
except that the pushq instruction is encoded in the machine code as a single byte, whereas the pair of instructions shown above requires a total of 8 bytes. The first two columns in Figure 3.9 illustrate the effect of executing the instruction pushq %rax when %rsp is 0x108 and %rax is 0x123. First %rsp is decremented by 8, giving 0x100, and then 0x123 is stored at memory address 0x100. Popping a quad word involves reading from the top-of-stack location and then incrementing the stack pointer by 8. Therefore, the instruction popq %rax is equivalent to the following pair of instructions:movq (%rsp), %rax //Read %rax from stack
addq $8, %rsp //Increment stack pointer
The third column of Figure 3.9 illustrates the effect of executing the instruction popq %edx immediately after executing the pushq. Value 0x123 is read from memory and written to register %rdx. Register %rsp is incremented back to 0x108. As shown in the figure, the value 0x123 remains at memory location 0x104 until it is overwritten (e.g., by another push operation). However, the stack top is always considered to be the address indicated by %rsp. <br>Since the stack is contained in the same memory as the program code and other forms of program data, programs can access arbitrary positions within the stack using the standard memory addressing methods. For example, assuming the topmost element of the stack is a quad word, the instruction movq 8(%rsp),%rdx will copy the second quad word from the stack to <a data-href="register" href="canekzamudio.com/cs_app/glossary/register.html" class="internal-link" target="_self" rel="noopener nofollow">register</a> %rdx.]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.4-pushing-and-popping-stack-data.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.4 Pushing and Popping Stack Data.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Tue, 19 Aug 2025 21:04:15 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.3-data-movement-example.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.3 Data Movement Example.md</guid></item><item><title><![CDATA[2.3.2 Two's-Complement Addition]]></title><description><![CDATA[With two’s-complement addition, we must decide what to do when the result is either too large (positive) or too small (negative) to represent. Given integer values and in the range , their sum is in the range , potentially requiring bits to represent exactly.Let us define to be the result of truncating the integer sum to be bits long and then viewing the result as a two’s-complement number.Two's-complement addition
For integer values and in the range : This principle is illustrated in Figure 2.24, where the sum is shown on the left, having a value in the range , and the result of truncating the sum to a -bit two’s-complement number is shown on the right. (The labels “Case 1” to “Case 4” in this figure are for the case analysis of the formal derivation of the principle.) When the sum exceeds (case 4), we say that positive overflow has occurred. In this case, the effect of truncation is to subtract from the sum. When the sum is less than (case 1), we say that negative overflow has occurred. In this case, the effect of truncation is to add to the sum.
The -bit two’s-complement sum of two numbers has the exact same bit-level
representation as the unsigned sum. In fact, most computers use the same machine instruction to perform either unsigned or signed addition.
<img alt="Pasted image 20250807193243.png" src="canekzamudio.com/assets/pasted-image-20250807193243.png" target="_self"><br>
<img alt="Pasted image 20250807193302.png" src="canekzamudio.com/assets/pasted-image-20250807193302.png" target="_self">
Figure 2.26 illustrates two’s-complement addition for word size . The operands range between . When , two’s-complement addition has a negative overflow, causing the sum to be incremented by 16. When , the addition yields . When , the addition has a positive overflow, causing the sum to be decremented by . Each of these three ranges forms a sloping plane in the figure.<br>
<img alt="Pasted image 20250807193731.png" src="canekzamudio.com/assets/pasted-image-20250807193731.png" target="_self">Detecting overflow in two's-complement addition
For and in the range , let . Then the computation of has had positive overflow if and only if and but . The computation has had negative overflow if and only if and but .
]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.2-two's-complement-addition.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.2 Two's-Complement Addition.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Mon, 18 Aug 2025 17:59:13 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.4.0 Accessing Information]]></title><description><![CDATA[registerAn x86 <a data-href="CPU" href="canekzamudio.com/cs_app/glossary/cpu.html" class="internal-link" target="_self" rel="noopener nofollow">CPU</a> contains a set of 16 general-purpose registers storing 64-bit values. These registers are used to store integer data as well as <a data-href="Pointers" href="canekzamudio.com/indexes/coding/c/pointers.html" class="internal-link" target="_self" rel="noopener nofollow">Pointers</a>. Their names all begin with %r, but otherwise follow multiple different naming conventions, owing to the historical evolution of the instruction set.<br>
<img alt="Pasted image 20250817140128.png" src="canekzamudio.com/assets/pasted-image-20250817140128.png" target="_self" style="width: 500px; max-width: 100%;">
Figure 3.2 Integer registers. The low-order portions of all 16 registers can be accessed as byte, word (16-bit), double word (32-bit), and quad word (64-bit) quantities.As the nested boxes above indicate, instructions can operate on data of different sizes stored in the low-order bytes of the 16 registers. Byte-level operations can access the least significant byte, 16-bit operations can access the least significant 2 bytes, 32-bit operations can access the least significant 4 bytes, and 64-bit operations can access entire registers.There are also a number of instructions for copying and generating 1, 2, 4, and 8-byte values. When these instructions have registers as destinations, two conventions arise for what happens to the remaining bytes in the register for instructions that generate less than 8 bytes: Those that generate 1 or 2-byte quantities leave the remaining bytes unchanged. Those that generate 4-byte quantities set the upper 4 bytes of the register to zero.x86 adopts a uniform set of conventions for register usage that must be respected by all procedures. By convention, registers %rbx, %rbp, and %r12 - %r15 are classified as callee-saved registers. When procedure P calls procedure Q, Q must preserve the values of these registers, ensuring that they have the same values when Q returns to P as they did when Q was called.
Procedure Q can preserve a register value by either not changing it at all or by pushing<br>
the original value on the stack, altering it, and then popping the old value from the stack before returning. The pushing of register values has the effect of creating the portion of the stack frame labeled “<a data-tooltip-position="top" aria-label="Pasted image 20250904115435.png" data-href="Pasted image 20250904115435.png" href="canekzamudio.com/assets/pasted-image-20250904115435.html" class="internal-link" target="_self" rel="noopener nofollow">Saved registers</a>” in Figure 3.25. With this convention, the code for P can safely store a value in a callee-saved register (after saving the previous value on the stack, of course), call Q, and then use the value in the register without risk of it having been corrupted. <br>All other registers, except for the <a data-tooltip-position="top" aria-label="3.7.1 The Run-Time Stack" data-href="3.7.1 The Run-Time Stack" href="canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html" class="internal-link" target="_self" rel="noopener nofollow">stack</a> pointer %rsp, are classified as caller-saved registers. This means that they can be modified by any function. The name “caller saved” can be understood in the context of a procedure P having some local data in such a register and calling procedure Q. Since Q is free to alter this register, it is incumbent upon P (the caller) to first save the data before it makes the call. ]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.0-accessing-information.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.0 Accessing Information.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 17 Aug 2025 19:51:16 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.3-data-formats/3.3.0-data-formats.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.3 Data Formats/3.3.0 Data Formats.md</guid></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.3-notes-on-formatting.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.3 Notes on Formatting.md</guid></item><item><title><![CDATA[3.2.2 Code Examples]]></title><description><![CDATA[C code file mstore.c:long mult2(long, long); void multstore(long x, long y, long *dest) { long t = mult2(x, y); *dest = t
}
To see the <a data-href="assembly" href="canekzamudio.com/assembly.html" class="internal-link" target="_self" rel="noopener nofollow">assembly</a> code generated by the C compiler, we can use the -S optionlinux&gt; gcc -Og -S mstore.c
The assembly code file contains various declarations, including the following set of lines:multstore: pushq %rbx movq %rdx, %rbx call %mult2 movq %rax, (%rbx) popq %rbx ret
Each indented line in the code corresponds to a single machine instruction. For example, the pushq instruction indicates that the contents of register %rbx should be pushed onto the program stack.If we use the -c command-line option, GCC will both compile and assemble the codelinux&gt; gcc -Og -c mstore.c
This will generate an object-code file mstore.o that is in binary format and hence cannot be viewed directly. Embedded within the 1,368 bytes of the file mstore.o is a 14-byte sequence with the hexadecimal representation53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
This is the object code corresponding to the assembly instructions listed previously. A key lesson to learn from this is that the program executed by the machine is simply a sequence of bytes encoding a series of instructions
To inspect the contents of machine-code files, we need a disassembler. These programs generate a format similar to assembly code from the machine code. With Linux systems, the program objdump (for “object dump”) can serve this role given the -d command-line flag:linux&gt; objdump -d mstore.c
<br><img alt="Pasted image 20250815131351.png" src="canekzamudio.com/assets/pasted-image-20250815131351.png" target="_self"><br>
On the left we see the 14 <a data-tooltip-position="top" aria-label="2.1.1 Hexadecimal Notation" data-href="2.1.1 Hexadecimal Notation" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html" class="internal-link" target="_self" rel="noopener nofollow">hexadecimal</a> byte values, listed in the byte sequence shown earlier, partitioned into groups of 1 to 5 bytes each. Each of these groups is a single instruction, with the <a data-href="assembly" href="canekzamudio.com/assembly.html" class="internal-link" target="_self" rel="noopener nofollow">assembly</a>-language equivalent shown on the right. Several features about machine code and its disassembled representation are worth noting:
x86-64 instructions can range in length from 1 to 15 bytes
The instruction format is designed in such a way that from a given starting position, there is a unique decoding of the bytes into machine instructions. For example, only the instruction pushq %rbx can start with byte value 53.
The disassembler determines the assembly code based purely on the byte sequences in the machine-code file.
The disassembler uses a slightly different naming convention for the instructions than does the assembly code generated by gcc. In our example, it has omitted the suffix ‘q’ from many of the instructions. These suffixes are size designators and can be omitted in most cases.
<br>Generating the actual executable code requires running a <a data-tooltip-position="top" aria-label="Linker - ld" data-href="Linker - ld" href="canekzamudio.com/.html" class="internal-link" target="_self" rel="noopener nofollow">linker</a> on the set of object-code files, one of which must contain a function main. making a separated main.c file then we could generate an executable program prog as follows:linux&gt; gcc -Og -o prog main.c mstore.c
The file prog has grown to 8,655 bytes, since it contains not just the machine code for the procedures we provided but also code used to start and terminate the program as well as to interact with the operating system.
The disassembler will extract various code sequences, including the following:<br>
<img alt="Pasted image 20250815133752.png" src="canekzamudio.com/assets/pasted-image-20250815133752.png" target="_self">
This code is almost identical to that generated by the disassembly of mstore.c. One important difference is that the addresses listed along the left are different— the linker has shifted the location of this code to a different range of addresses. A second difference is that the linker has filled in the address that the callq instruction should use in calling the function mult2 (line 4 of the disassembly).
One task for the linker is to match function calls with the locations of the executable code for those functions. A final difference is that we see two additional lines of code (lines 8–9). These instructions will have no effect on the program, since they occur after the return instruction (line 7). They have been inserted to grow the code for the function to 16 bytes, enabling a better placement of the next block of code in terms of memory system performance.]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.2-code-examples.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.2 Code Examples.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Fri, 15 Aug 2025 19:39:53 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.2.1 Machine-Level Code]]></title><description><![CDATA[CS employ different forms of abstraction, hiding details of an implementation through the use of a simpler abstract model. Two of these are specially important for machine-level programming:ISA - Instruction Set ArchitectureThe ISA defines the format and behaviour of a machine-level program.Defines:
Processor state
Format of the instructions
The effect each of these instructions will have on the state
Most ISAs, like x86 one, describe the behavior of a program as if each instruction is executed in sequence, with one instruction completing before the next one begins.
The processor hardware is far more elaborate, executing many instructions concurrently, but it employs safeguards to ensure that the overall behavior matches the sequential operation dictated by the ISA. Two big groups of architectures define main <a data-href="assembly" href="canekzamudio.com/assembly.html" class="internal-link" target="_self" rel="noopener nofollow">assembly</a> languages :CISC assembly languages, such as Intel IA-32 and x64, have more complex instructions. They generally focus on completing tasks using as few lines of assembly instructions as possible.
To do so, some instructions can perform multiple operations, such as mul in Intel assembly,
which performs data access, multiplication, and data store operations in one go.In the RISC assembly language, assembly instructions are simple and generally perform only one operation each. This may lead to more lines of code to complete a specific task, but it may also be more efficient, as this omits the execution of any unnecessary operations.<br>Second, the memory addresses used by a machine level program are <a data-tooltip-position="top" aria-label="virtual memory" data-href="virtual memory" href="canekzamudio.com/cs_app/glossary/virtual-memory.html" class="internal-link" target="_self" rel="noopener nofollow">virtual addresses</a>, providing a memory model that appears to be a very large byte array. The actual implementation of the memory system involves a combination of multiple hardware memories and operating system software.The machine code for x86 differs greatly from the original C code. Parts of the processor state are visible that normally are hidden from the C programmer:
<br>The <a data-tooltip-position="top" aria-label="1.4.1 Hardware Organization of a System" data-href="1.4.1 Hardware Organization of a System" href="canekzamudio.com/cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html" class="internal-link" target="_self" rel="noopener nofollow">program counter</a> (called %rip in x86) indicates the address in memory of the next instrucion to be executed
<br>The integer <a data-tooltip-position="top" aria-label="1.4.1 Hardware Organization of a System" data-href="1.4.1 Hardware Organization of a System" href="canekzamudio.com/cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html" class="internal-link" target="_self" rel="noopener nofollow">register file</a> contains 16 named locations storing 64-bit values. These registers can hold addresses (corresponding to C <a data-href="Pointers" href="canekzamudio.com/indexes/coding/c/pointers.html" class="internal-link" target="_self" rel="noopener nofollow">Pointers</a>) or integer data. Some registers are used to keep track of critical parts of the program state, while others are used to hold temporary data, such as the arguments and local <a data-href="Variables" href="canekzamudio.com/indexes/coding/c井/variables.html" class="internal-link" target="_self" rel="noopener nofollow">Variables</a> of a procedure, as well as the value to be returned by a function.
The condition code registers hold status information about the most recently executed arithmetic or logical instruction. These are used to implement conditional changes in the control or data flow, such as is required to implement if and while statements.
A set of vector registers can each hold one or more integer or floating-point values
Machine code views the memory as simply a larga byte-addressable array. Aggregate data types in C such as arrays and structures are represented in machine code as contiguous collections of bytes. Even for scalar data types, assembly code makes no distinctions between signed or unsigned integers, between different types of pointers, or even between pointers and integers<br>The program memory contains the executable machine code for the program, some information required by the <a data-href="Operating System" href="canekzamudio.com/cs_app/glossary/operating-system.html" class="internal-link" target="_self" rel="noopener nofollow">Operating System</a>, a run-time stack for managing procedure calls and returns, and blocks of memory allocated by the user( e.g. function in malloc library).
The program memory is addressed using virtual addresses. At any given
time , only limited subranges of virtual addresses are considered valid. For example, x86-64 virtual addresses are represented by 64-bit words. In current implementations of these machines, the upper 16 bits must be set to zero, and so an address can potentially specify a byte over a range of 2 48 , or 64 terabytes. More typical programs will only have access to a few megabytes, or perhaps several gigabytes. The operating system manages this virtual address space, translating virtual addresses into the physical addresses of values in the actual processor memoryA single machine instruction performs only a very elementary operation. For example, it might add two numbers stored in registers, transfer data between memory and a register, or conditionally branch to a new instruction address.]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.1-machine-level-code.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.1 Machine-Level Code.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 14 Aug 2025 20:38:22 GMT</pubDate></item><item><title><![CDATA[1.9.3 The Importance of Abstractions in Computer Systems]]></title><description><![CDATA[The use of abstractions is one of the most important concepts in computer science. For example, one aspect of good programming practice is to formulate a simple application program interface (API) for a set of functions that allow programmers to use the code without having to delve into its inner workings.
<img alt="Pasted image 20250715184855.png" src="canekzamudio.com/assets/pasted-image-20250715184855.png" target="_self">
On the processor side, the instruction set architecture provides an abstraction of the actual processor hardware. With this abstraction, a machine-code program behaves as if it were executed on a processor that performs just one instruction at a time. The underlying hardware is far more elaborate, executing multiple instructions in parallel, but always in a way that is consistent with the simple, sequential model. By keeping the same execution model, different processor implementations can execute the same machine code while offering a range of cost and performance.]]></description><link>canekzamudio.com/cs_app/i.-computer-systems/1.9-important-themes/1.9.3-the-importance-of-abstractions-in-computer-systems.html</link><guid isPermaLink="false">CS_APP/I. Computer Systems/1.9 Important Themes/1.9.3 The Importance of Abstractions in Computer Systems.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 14 Aug 2025 20:07:38 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.2.0 Program Encodings]]></title><description><![CDATA[Suppose we write a C program as two files p1.c and p2.c. We can then compile this code using:linux&gt; gcc -Og -o p p1.c p2.c gcc - indicates the GCC C compiler, the default <a data-tooltip-position="top" aria-label="Compiler - cc1" data-href="Compiler - cc1" href="canekzamudio.com/.html" class="internal-link" target="_self" rel="noopener nofollow">compiler</a> on Linux
-Og instructs the compiler to apply a level of optimization that yields machine code that follows the overall structure of the original C code(Invoking higher levels of optimization can generate code that is so heavily transformed that the relationship between the generated machine code and the original source code is difficult to understand. We will therefore use -Og optimization as a learning tool)
<br><img alt="Pasted image 20250814135551.png" src="canekzamudio.com/assets/pasted-image-20250814135551.png" target="_self">
The way to turn the source code into executable code:
The C preprocessor expands the source code to include any files specified with #include commands and to expand any macros, specified with #define declarations. <br>The compiler generates <a data-href="assembly" href="canekzamudio.com/assembly.html" class="internal-link" target="_self" rel="noopener nofollow">assembly</a> code versions of the two source files having names p1.s and p2.s.
The assembler converts the assembly code into binary object-code files p1.o and p2.o. Object code is one form of machine code—it contains binary representations of all of the instructions, but the addresses of global values are not yet filled in. Finally, the linker merges these two object-code files along with code implementing library functions (e.g., printf) and generates the final executable code file p (as specified by the command-line directive -o p). Executable code is te exact form of code that is executed by the processor
]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.0-program-encodings.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.0 Program Encodings.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 14 Aug 2025 20:03:33 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.0.0 Machine Level Representation of Programs]]></title><description><![CDATA[Computers execute machine code, sequences of bytes encoding the low-level operations that manipulate data, manage, read and write data on storage devices, and communicate over <a data-href="Network" href="canekzamudio.com/indexes/networking/network.html" class="internal-link" target="_self" rel="noopener nofollow">Network</a>s. A <a data-tooltip-position="top" aria-label="Compiler - cc1" data-href="Compiler - cc1" href="canekzamudio.com/.html" class="internal-link" target="_self" rel="noopener nofollow">compiler</a> generates machine code through a series of stages, based on the rules of the programming language, the instruction set of the target machine, and the conventions followed by the <a data-href="Operating System" href="canekzamudio.com/cs_app/glossary/operating-system.html" class="internal-link" target="_self" rel="noopener nofollow">Operating System</a>.<br>The GCC C compiler generates its output in the form of <a data-href="assembly" href="canekzamudio.com/assembly.html" class="internal-link" target="_self" rel="noopener nofollow">assembly</a> code a textual representation of the machine code giving the individual instructions to the program. GCC the invokes both an <a data-href="Assembler - as" href="canekzamudio.com/.html" class="internal-link" target="_self" rel="noopener nofollow">Assembler - as</a> and a <a data-href="Linker - ld" href="canekzamudio.com/.html" class="internal-link" target="_self" rel="noopener nofollow">Linker - ld</a> to generate the executable machine code from the assembly code]]></description><link>canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.1-a-historical-perspective/3.0.0-machine-level-representation-of-programs.html</link><guid isPermaLink="false">CS_APP/III. Machine-lever Representation of Programs/3.1 A Historical Perspective/3.0.0 Machine Level Representation of Programs.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 14 Aug 2025 19:02:37 GMT</pubDate></item><item><title><![CDATA[CS_APP]]></title><link>canekzamudio.com/cs_app/cs_app.html</link><guid isPermaLink="false">CS_APP/CS_APP.pdf</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 14 Aug 2025 18:53:06 GMT</pubDate></item><item><title><![CDATA[2.1.3 Addressing and Byte Ordering]]></title><description><![CDATA[For program objects that span multiple bytes, we must establish two conventions: what the address of the object will be, and how we will order the bytes in memory. In virtually all machines, a multi-byte object is stored as a contiguous sequence of bytes, with the address of the object given by the smallest address of the bytes used. For example, suppose a variable x of type int has address 0x100; that is, the value of the address expression &amp;x is 0x100. Then (assuming <a data-tooltip-position="top" aria-label="Data Types" data-href="Data Types" href="canekzamudio.com/indexes/coding/c井/data-types.html" class="internal-link" target="_self" rel="noopener nofollow">data type</a> int has a 32-bit representation) the 4 bytes of x would be stored in memory locations 0x100, 0x101, 0x102, and 0x103.For ordering the bytes representing an object, there are two common conventions. Consider a -bit integer having a bit representation , where is the most significant bit and is the least. Assuming w is a multiple of 8, these bits can be grouped as bytes, with the most significant byte having bits , the least significant byte having bits , and the other bytes having bits from the middle. Some machines choose to store the object in memory ordered from least significant byte to most, while other machines store them from most to least. The former convention—where the least significant byte comes first—is referred to as little endian. The latter convention—*where the most significant byte comes first—is referred to as big endian.<br>Suppose the variable x of type int and at address 0x100 has a <a data-tooltip-position="top" aria-label="2.1.1 Hexadecimal Notation" data-href="2.1.1 Hexadecimal Notation" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html" class="internal-link" target="_self" rel="noopener nofollow">hexadecimal</a> value of 0x01234567. The ordering of the bytes within the address range 0x100 through 0x103 depends on the type of machine:<br>
<img alt="Pasted image 20250716204848.png" src="canekzamudio.com/assets/pasted-image-20250716204848.png" target="_self">
Note that in the word 0x01234567 the high-order byte has a hexadecimal value 0x01, while the low-order byte has value 0x67.For most application programmers, the byte orderings used by their machines are totally invisible; programs compiled for either class of machine give identical results.
Most Intel-compatible machines operate exclusively in little-endian mode. On the other hand, most machines from IBM and Oracle operate in big-endian mode.
Many recent microprocessor chips are bi-endian, meaning that they can be configured to operate as either liitle or big endian machines The first is when binary data are communicated over a network between different machines. A common problem is for data produced by a little-endian machine to be sent to a big-endian machine, or vice versa, leading to the bytes within the words being in reverse order for the receiving program. To avoid such problems, code written for networking applications must follow established conventions for byte ordering to make sure the sending machine converts its internal representation to the network standard, while the receiving machine converts the network standard to its internal representation.
A second case where byte ordering becomes important is when looking at the byte sequences representing integer data. This occurs often when inspecting machine-level programs. As an example, the following line occurs in a file that gives a text representation of the machine-level code for an Intel x86-64 processor: 4004d3: 01 05 43 0b 20 00 add %eax,0x200b43(%rip) This line was generated by a disassembler, a tool that determines the instruction sequence represented by an executable program file.
We simply note that this line states that the hexadecimal byte sequence 01 05 43 0b 20 00 is the byte-level representation of an instruction that adds a word of data to the value stored at an address computed by adding 0x200b43 to the current value of the program counter, the address of the next instruction to be executed. If we take the final 4 bytes of the sequence 43 0b 20 00 and write them in reverse order, we have 00 20 0b 43. Dropping the leading 0, we have the value 0x200b43, the numeric value written on the right. Having bytes appear in reverse order is a common occurrence when reading machine-level program representations generated for little-endian machines such as this one. The natural way to write a byte sequence is to have the lowest-numbered byte on the left and the highest on the right, but this is contrary to the normal way of writing numbers with the most significant digit on the left and the least on the right.
A third case where byte ordering becomes visible is when programs are written that circumvent the normal type system. In the C language, this can be done using a cast or a union to allow an object to be referenced according to a different data type from which it was created. Such coding tricks are strongly discouraged for most application programming, but they can be quite useful and even necessary for system-level programming.
#include &lt;stdio.h&gt; typedef unsigned char *byte_pointer; void show_bytes(byte_pointer start, size_t len) { int i; for (i = 0; i &lt; len; i++) printf(" %.2x", start[i]); printf("\n");
} void show_int(int x) { show_bytes((byte_pointer) &amp;x, sizeof(int)); } void show_float(float x) { show_bytes((byte_pointer) &amp;x, sizeof(float));
} void show_pointer(void *x) {
show_bytes((byte_pointer) &amp;x, sizeof(void *));
}
//CODE TO PRINT THE BYTE REPRESENTATION OF PROGRAM OBJECTS
These procedures use the C sizeof operator to determine the number of bytes used by the object. In general, the expression sizeof(T ) returns the number of bytes required to store an object of type T.Using sizeof rather than a fixed value is one step toward writing code that is portable across different machine types.void test_show_bytes(int val)
{ int ival = val; float fval = (float) ival; int *pval = &amp;ival; show_int(ival); show_float(fval); show_pointer(pval);
}
//THIS CODE PRINTS THE BYTE REPRESENTATION OF SAMPLE DATA OBJECTS
<br><img alt="Pasted image 20250717130734.png" src="canekzamudio.com/assets/pasted-image-20250717130734.png" target="_self" style="width: 600px; max-width: 100%;"><br>
Our argument 12,345 has <a data-tooltip-position="top" aria-label="2.1.1 Hexadecimal Notation" data-href="2.1.1 Hexadecimal Notation" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html" class="internal-link" target="_self" rel="noopener nofollow">hexadecimal</a> representation (in big-endian). We can see that the leas significant byte value of is printed first for Linux 32, Windows and Linux 64, indicating little-endian machines, and last for Sun, indicating big-endian.
Note that the Linux 32, Windows and Sun machines use 4-byte addresses, while the Linux 64 uses 8-byte addresses.Although the floating-point and the int data both encode the numeric value 12,345, they have different patterns: for the integer and for floating point. In general, these two formats use different encoding schemes. If we expand these hexadecimal patterns into binary form and shift them appropriately, we find a sequence of 13 matching bits, indicated by a sequence of asterisks, as follows:<br>
<img alt="Pasted image 20250717141129.png" src="canekzamudio.com/assets/pasted-image-20250717141129.png" target="_self">]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.3-addressing-and-byte-ordering.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.3 Addressing and Byte Ordering.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 10 Aug 2025 23:40:49 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.3.7 Dividing by Powers of 2]]></title><description><![CDATA[Integer divisions in most machines is even slowe than multiplication, requiring 30 or more clock cycles,Dividing by a power of 2 can also be using <a data-tooltip-position="top" aria-label="2.1.9 Shift Operations in C" data-href="2.1.9 Shift Operations in C" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html" class="internal-link" target="_self" rel="noopener nofollow">shift operations</a>, but we use a right shift rather than a left shift. The two different right shifts—<a data-tooltip-position="top" aria-label="2.1.9 Shift Operations in C" data-href="2.1.9 Shift Operations in C" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html" class="internal-link" target="_self" rel="noopener nofollow">logical and arithmetic</a>—serve this purpose for unsigned and two’s-complement numbers, respectively. Integer division always rounds toward zero. To define this precisely, let us introduce some notation
For any real number , define to be the unique integer such that .
As examples, , , and . Similarly, define to be the unique integer such that . As examples, , , and . For and , integer division should yield , while for and , it should yield . That is, it should round down a positive result but round up a negative one.
The case for using shifts with unsigned arithmetic is straightforward, in part because
right shifting is guaranteed to be performed logically for unsigned values.Unsigned division by a power of 2
For C variables and with unsigned values and , such that , the C expression yields the value <br><img alt="Pasted image 20250808193539.png" src="canekzamudio.com/assets/pasted-image-20250808193539.png" target="_self">
Figure 2.28 shows the effects of performing logical right shifts on a 16-bit representation of 12,340 to perform division by 1, 2, 16, and 256. The zeros shifted in from the left are shown in italics. We also show the result we would obtain if we did these divisions with real arithmetic. These examples show that the result of shifting consistently rounds toward zero, as is the convention for integer division<br>
<img alt="Pasted image 20250808193628.png" src="canekzamudio.com/assets/pasted-image-20250808193628.png" target="_self">
The case for dividing by a power of 2 with two’s-complement arithmetic is slightly more complex. First, the shifting should be performed using an arithmetic right shift, to ensure that negative values remain negative. Let us investigate what value such a right shift would produce.Two's-complement division by a power of 2, rounding down
Let C variables and have two’s-complement value and unsigned value , respectively, such that . The C expression , when the shift is performed arithmetically, yields the value For , variable has as the most significant bit, and so the effect of an arithmetic shift is the same as for a logical right shift. Thus, an arithmetic right shift by is the same as division by for a nonnegative number. As an example of a negative number, Figure 2.29 shows the effect of applying arithmetic right shift to a -bit representation of for different shift amounts. For the case when no rounding is required , the result will be . When rounding is required, shifting causes the result to be rounded downward. For example, the shifting right by four has the effect of rounding down to . We will need to adjust our strategy to handle division for negative values of .<br>
<img alt="Pasted image 20250808194016.png" src="canekzamudio.com/assets/pasted-image-20250808194016.png" target="_self">
We can correct for the improper rounding that occurs when a negative number is shifted right by “biasing” the value before shifting.Two's-complement division by a power of 2, rounding up
...
... Continue...]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.7-dividing-by-powers-of-2.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.7 Dividing by Powers of 2.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sat, 09 Aug 2025 03:17:04 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.3.6 Multiplying by Constants]]></title><description><![CDATA[Integer multiply instruction on many machines is slower than other operations. Even on the Inter Core i7 Haswell we use as our reference machine, integer multiply requires 3 clock cycles. So, one important optimization used by compiler is to attempt to replace multiplications by constant factors with combinations of shift and addition operations. We will first consider the case of multiplying by a power of 2, and then we will generalize this to arbitrary constants.Multiplication by a power of 2
Let be the unsigned integer represented by bit pattern . Then for any , the -bit unsigned representation of is given by , where zeros have been added to the right.
So, for example, 11 can be represented for as . Shifting this left by yields the 6-bit vector, which encodes the unsigned number .When shifting left by for a fixed word size, the high-order bits are discarded, yieldingbut this is also the case when performing multiplication on fixed-size words. We can therefore see that shifting a value left is equivalent to performing unsigned multiplication by a power of 2:Unsigned multiplication by a power of 2
For C variables and with unsigned values and , such that , the C expression yields the value .
Since the bit-level operation of fixed-size two’s-complement arithmetic is equivalent to that for unsigned arithmetic, we can make a similar statement about the relationship between left shifts and multiplication by a power of 2 for two’s-complement arithmetic:Two's-complement multiplication by a power of 2
For C variables and with two's-complement value and unsigned value , such that , the C expression yields the value .
Note that multiplying by a power of 2 can cause overflow with either unsigned or two’s-complement arithmetic. Our result shows that even then we will get the same effect by shifting. Returning to our earlier example, we shifted the -bit pattern (numeric value ) left by two positions to get (numeric value ). Truncating this to bits gives (numeric value ).Given that integer multiplication is more costly than shifting and adding, many C compilers try to remove many cases where an integer is being multiplied by a constant with combinations of shifting, adding, and subtracting. For example, suppose a program contains the expression . Recognizing that , the compiler can rewrite the multiplication as , replacing one multiplication with three shifts and two additions. The two computations will yield the same result, regardless of whether is unsigned or two’s complement, and even if the multiplication would cause an overflow. Even better, the compiler can also use the property to rewrite the multiplication as , requiring only two shifts and a subtractionGeneralizing from our example, consider the task of generating code for the expression , for some constant . The compiler can express the binary representation of $K as an alternating sequence of zeros and ones: By adding together the results for each run, we are able to compute x * K without any multiplications. Of course, the trade-off between using combinations of shifting, adding, and subtracting versus a single multiplication instruction depends on the relative speeds of these instructions, and these can be highly machine dependent. Most compilers only perform this optimization when a small number of shifts, adds, and subtractions suffice.]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.6-multiplying-by-constants.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.6 Multiplying by Constants.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sat, 09 Aug 2025 01:18:10 GMT</pubDate></item><item><title><![CDATA[2.3.5 Two's-complement multiplication]]></title><description><![CDATA[Integers and in the range can be represented as -bit two’s-complement numbers, but their product can range between and . This could require as many as bits to represent in two’s-complement form. Instead, signed multiplication in C generally is performed by truncating the -bit product to bits. We denote this value as . Truncating a two’s-complement number to w bits is equivalent to first computing its value modulo and then converting from unsigned to two’s complement, giving the following:Two's-complement multiplication
For and such that : The bit-level representation of the product operation is identical for both unsigned and two’s-complement multiplication.
<img alt="Pasted image 20250808164737.png" src="canekzamudio.com/assets/pasted-image-20250808164737.png" target="_self">]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.5-two's-complement-multiplication.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.5 Two's-complement multiplication.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Fri, 08 Aug 2025 22:47:37 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.3.4 Unsigned Multiplication]]></title><description><![CDATA[Integers and in the range can be represented as -bit unsigned numbers, but their product can range between and . This could require as many as bits to represent. Instead, unsigned multiplication in C is defined to yield the -bit value given by the low-order bits of the -bit integer product. Let us denote this value as . Truncating an unsigned number to bits is equivalent to computing its value modulo , giving the following:Unsigned multiplication
For and such that : ]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.4-unsigned-multiplication.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.4 Unsigned Multiplication.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Fri, 08 Aug 2025 02:52:02 GMT</pubDate></item><item><title><![CDATA[2.3.3 Two's Complement Negation]]></title><description><![CDATA[We can see that every number in the range has an additive inverse under , which we denote as follows:Two's-complement negation
For in the range , its two’s-complement negation is given by the formula That is, for -bit two's-complement addition, is its own additive inverse, while any other value has as its additive inverse.
]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.3-two's-complement-negation.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.3 Two's Complement Negation.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Fri, 08 Aug 2025 02:37:23 GMT</pubDate></item><item><title><![CDATA[2.2.8 Advice on Signed versus Unsigned]]></title><description><![CDATA[So implicit casting of signed to unsigned leads to some non-intuitive behavior. Nonintuitive features often lead to program bugs, and ones involving the nuances of implicit casting can be especially difficult to see. Since the casting takes place without any clear indication in the code, programmer often overlook its effects.We have seen multiple ways in which the subtle features of unsigned arithmetic, and especially the implicit conversion of signed to unsigned, can lead to errors or vulnerabilities. One way to avoid such bugs is to never use unsigned numbers.Unsigned values are very useful when we want to think of words as just collections of bits with no numeric interpretation. This occurs, for example, when packing a word with flags describing various Boolean conditions. Addresses are naturally unsigned, so systems programmers find unsigned types to be helpful. Unsigned values are also useful when implementing mathematical packages for modular arithmetic and for multiprecision arithmetic, in which numbers are represented by arrays of words.]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.8-advice-on-signed-versus-unsigned.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.8 Advice on Signed versus Unsigned.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 06 Aug 2025 20:41:32 GMT</pubDate></item><item><title><![CDATA[2.2.7 Truncating Numbers]]></title><description><![CDATA[Suppose that, rather than extending a value with extra bits, we reduce the number of bits representing a number. This occurs in this codeint x = 53191;
short sx = (short) x; /* -12345 */
int y = sx; /* -12345 */
Casting x to be short will truncate a 32-bit int to a 16-bit short. As we saw before, this 16-bit pattern is the two’s-complement representation of −12,345. When casting this back to int, sign extension will set the high-order 16 bits to ones, yielding the 32-bit two’s-complement representation of −12,345.When truncating a -bit number to a -bit number, we drop the high-order bits, giving a bit vector . Truncating a number can alter its value—a form of overflow. For an unsigned number, we can readily characterize the numeric value that will result.Truncation of an unsigned number
Let be the bit vector , and let be the result of truncating it to bits: . Let and . Then mod .
The intuition behind this principle is simply that all of the bits that were truncated have weights of the form , where , and therefore each of these weights reduces to zero under the modulus operation. A similar property holds for truncating a two’s-complement number, except that it then converts the most significant bit into a sign bit:Truncation of a two's-complement number
Let be the bit vector , and let be the result of truncating it to bits: . Let and . Then mod .
In this formulation, mod will be a number between and . Applying function to it will have the effect of converting the most significant bit from having weight to having weight . We can see this with the example of converting value from int to short. Since , we have mod . But when we convert this number to a 16-bit two’s-complement number, we get .]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.7-truncating-numbers.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.7 Truncating Numbers.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 06 Aug 2025 19:48:38 GMT</pubDate></item><item><title><![CDATA[2.2.6 Expanding the Bit representation of a Number]]></title><description><![CDATA[One common operation is to convert between integers having different word sizes while retaining the same numeric value. Of course, this may not be possible when the destination data type is too small to represent the desired value. Converting from a smaller to a larger data type, however, should always be possible.To convert an unsigned number to a larger data type, we can simply add leading zeros to the representation; this operation is known as zero extension, expressed by the following principle:Expansion of an unsigned number by zero extension
Define bit vectors of widh and of width , where . Then .
For converting a two's-complement number to a larger data type, the rule is to perform a sign extension, assign copies of the most significant bit to the representation, expressed by the following principle. We show the sign bit in bold to highlight its role in sign extension.Expansion of a two's-complement number by sign extension
Define bit vectors of widh and of width , where . Then .
<img alt="Pasted image 20250806124238.png" src="canekzamudio.com/assets/pasted-image-20250806124238.png" target="_self">]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.6-expanding-the-bit-representation-of-a-number.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.6 Expanding the Bit representation of a Number.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 06 Aug 2025 18:42:39 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.2.5 Signed versus Unsigned in C]]></title><description><![CDATA[Almost all machines use two’s complement. Generally, most numbers are signed by default. For example, when declaring a constant such as 12345 or 0x1A2B, the value is considered signed. Adding character ‘U’ or ‘u’ as a suffix creates an unsigned constant; for example, 12345U or 0x1A2Bu.C allows conversion between unsigned and signed most systems apply the function <a data-tooltip-position="top" aria-label="2.2.4 T2U &amp; U2T" data-href="2.2.4 T2U &amp; U2T" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.4-t2u-&amp;-u2t.html" class="internal-link" target="_self" rel="noopener nofollow">U2T</a> when converting from unsigned to signed, and <a data-tooltip-position="top" aria-label="2.2.4 T2U &amp; U2T" data-href="2.2.4 T2U &amp; U2T" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.4-t2u-&amp;-u2t.html" class="internal-link" target="_self" rel="noopener nofollow">T2U</a> when converting from signed to unsigned, where is the number of bits for the data type.Some possibly nonintuitive behavior arises due to C’s handling of expressions containing combinations of signed and unsigned quantities. When an operation is performed where one operand is signed and the other is unsigned, C implicitly casts the signed argument to unsigned and performs the operations assuming the numbers are nonnegative.<br>
<img alt="Pasted image 20250805221658.png" src="canekzamudio.com/assets/pasted-image-20250805221658.png" target="_self">]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.5-signed-versus-unsigned-in-c.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.5 Signed versus Unsigned in C.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 06 Aug 2025 04:44:13 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.2.4 T2U & U2T]]></title><description><![CDATA[C allows casting between different numeric data types. For example, suppose variable x is declared as int and u as unsigned. The expression (unsigned) x converts the value of x to an unsigned value, and (int) u converts the value of u to a signed integer. In casting from unsigned to int, the underlying bit representation stays the same, the numeric values might change, but the bit patterns do not.Conversion from two's complement to unsigned
For such that : For example, we saw that , and also that .
<img alt="Pasted image 20250805215808.png" src="canekzamudio.com/assets/pasted-image-20250805215808.png" target="_self">
Figure 2.17 illustrates the general behavior of function . As it shows, when mapping a signed number to its unsigned counterpart, negative numbers are converted to large positive numbers, while nonnegative numbers remain unchanged.
Going in the other direction, we can state the relationship between an unsigned number u and its signed counterpart U2Tw (u):Unsigned to two's-complement conversion
For such that : <br><img alt="Pasted image 20250805220347.png" src="canekzamudio.com/assets/pasted-image-20250805220347.png" target="_self">]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.4-t2u-&amp;-u2t.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.4 T2U &amp; U2T.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 06 Aug 2025 04:03:53 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.2.3 Two's-Complement Encodings]]></title><description><![CDATA[The most common computer representation of signed numbers is known as two's-complement form. This is defined by interpreting the most significant bit of the word to have negative weight. We name this as a function (for "binary to two's complement" length )Definition of two's-complement encoding
For vector The most significant bit is also called the sign bit. Its "weight" is , the negation of its weight in an unsigned representation. When the sign bit is set to 1, the represented value is negative, and when set to 0, the value is nonnegative. <img alt="Pasted image 20250805133858.png" src="canekzamudio.com/assets/pasted-image-20250805133858.png" target="_self">
Let us consider the range of values that can be represented as a w-bit two’scomplement number. The least representable value is given by bit vector (set the bit with negative weight but clear all others), having integer value . The greatest value is given by bit vector (clear the bit with negative weight but set all others), having integer value . Using the 4-bit case as an example, we have and .Uniqueness of two's-complement encoding
Function is a bijection
We define function (for “two’s complement to binary”) to be the inverse of . That is, for a number , such that , is the (unique) -bit pattern that encodes .The two’s-complement range is asymmetric: ; that is, there is no positive counterpart to . As we shall see, this leads to some peculiar properties of two’s-complement arithmetic and can be the source of subtle program bugs.<br>
<img alt="Pasted image 20250805140636.png" src="canekzamudio.com/assets/pasted-image-20250805140636.png" target="_self"><br>
<img alt="Pasted image 20250805143818.png" src="canekzamudio.com/assets/pasted-image-20250805143818.png" target="_self">There are two other standard representations for signed numbers: Ones’ complement. This is the same as two’s complement, except that the most significant bit has weight rather than : Sign magnitude. The most significant bit is a sign bit that determines whether the remaining bits should be given negative or positive weight: ]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.3-two's-complement-encodings.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.3 Two's-Complement Encodings.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Tue, 05 Aug 2025 20:38:21 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.2.2 Unsigned Encodings]]></title><description><![CDATA[Let us consider an integer <a data-tooltip-position="top" aria-label="Data Types" data-href="Data Types" href="canekzamudio.com/indexes/coding/c井/data-types.html" class="internal-link" target="_self" rel="noopener nofollow">data type</a> of bits. We write a bit vector as either , to denote the entire vector, or as to denote the individual bits within the vector. Treating as a number written in binary notation, we obtain the unsigned interpretation of . In this encoding, each bit has value 0 or 1, with the latter case indicating that value should be included as part of the numeric value. We can express this interpretation as a function (for “binary to unsigned,” length ):<br>
<img alt="Pasted image 20250725183303.png" src="canekzamudio.com/assets/pasted-image-20250725183303.png" target="_self">
In this, we represent each bit position by a rightward-pointing blue bar of length . The numeric value associated with a bit vector then equals the sum of the lengths of the bars for which the corresponding bit values are 1.Definition of unsigned encoding
For vector In this equation, the notation means that the left-hand side is defined to be equal to the right-hand side. The function maps strings of zeros and ones of length to nonnegative integers. Let us consider the range of values that can be represented using bits. The least value is given by bit vector having integer value . Using the 4-bit case as an example, we have . Thus, the function can be defined as a mapping .The unsigned binary representation has the important property that every number between 0 and has a unique encoding as a -bit value. For example, there is only one representation of decimal value 11 as an unsigned 4-bit number— namely, . We highlight this as a mathematical principle, which we first state and then explain.Uniqueness of unsigned encoding
Function is a bijection
The mathematical term bijection refers to a function that goes two ways: it maps a value to a value where = , but it can also operate in reverse, since for every , there is a unique value such that . This is given by the inverse function , where, for our example, . The function maps each bit vector of length to a unique number between and , and it has an inverse, which we call (for “unsigned to binary”), that maps each number in the range to to a unique pattern of bits.]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.2-unsigned-encodings.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.2 Unsigned Encodings.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sat, 26 Jul 2025 01:54:30 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.2.1 Integral Data Types]]></title><description><![CDATA[C supports a variety of integral data types. Each type can specify a <a data-tooltip-position="top" aria-label="2.1.2 Data Sizes" data-href="2.1.2 Data Sizes" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.2-data-sizes.html" class="internal-link" target="_self" rel="noopener nofollow">data size</a> with keyword char, short, long, as well as an indication of whether the represented numbers are all nonnegative (declared as unsigned), or possibly negative (default).The number of bytes allocated for the different sizes varies according to whether the program is compiled for 32 or 64 bits. Based on the byte allocations, the different sizes allow different ranges of values to be represented. The only machine-dependent range indicated is for size designator long. Most 64-bit programs use an 8-byte representation, giving a much wider range of values than the 4-byte representation used with 32-bit programs.<br>
<img alt="Pasted image 20250725180054.png" src="canekzamudio.com/assets/pasted-image-20250725180054.png" target="_self" style="width: 590px; max-width: 100%;">
Ranges are not symmetric—the range of negative numbers extends one further than the range of positive numbers.<br>
<img alt="Pasted image 20250725180109.png" src="canekzamudio.com/assets/pasted-image-20250725180109.png" target="_self">]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.1-integral-data-types.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.1 Integral Data Types.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sat, 26 Jul 2025 00:01:31 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.2.0 Integer Representations]]></title><description><![CDATA[There are 2 ways bits can be used to encode integers, one that can only represent nonnegative numbers, and one that can represent negative, zero, and positive numbers.This list the mathematical terminology we introduce to precisely define and characterize how computers encode and operate on integer data.
<img alt="Pasted image 20250725174630.png" src="canekzamudio.com/assets/pasted-image-20250725174630.png" target="_self">]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.0-integer-representations.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.0 Integer Representations.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Fri, 25 Jul 2025 23:46:36 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.1.9 Shift Operations in C]]></title><description><![CDATA[Shift operators shift bit patterns to the left and to the right.For an operand x having bit representation , the C expression x &lt;&lt; k yields a value with bit representation . That is, x is shifted k bits to the left, dropping off the k most significant bits and filling the right end with k zeros. The shift amount should be a value between 0 and w − 1. Shift operations associate from left to right, so x &lt;&lt; j &lt;&lt; k is equivalent to (x &lt;&lt; j) &lt;&lt; k.
Machines support two forms of right shift: A logical right shift fills the left end with zeros, giving a result . An arithmetic right shift fills the left end with repetitions of the most significant bit, giving a result . This convention is useful for operating on signed integer data.
<img alt="Pasted image 20250724145251.png" src="canekzamudio.com/assets/pasted-image-20250724145251.png" target="_self">
Almost all computer/machine combinations use arithmetic right shifts for signed data, and many programmers assume this to be the case. For unsigned data, right shifts must be logical.
]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.9 Shift Operations in C.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 24 Jul 2025 20:55:07 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.1.7 Bitwise operators]]></title><description><![CDATA[C supports <a data-tooltip-position="top" aria-label="2.1.6 Intro To Boolean Algebra" data-href="2.1.6 Intro To Boolean Algebra" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.6-intro-to-boolean-algebra.html" class="internal-link" target="_self" rel="noopener nofollow">boolean operations</a>. Boolean operators |, &amp;, ~, ^ can be applied to any "integral" data type.<br>
<img alt="Pasted image 20250722131129.png" src="canekzamudio.com/assets/pasted-image-20250722131129.png" target="_self"><br>
The best way to determine the effect of a bit-level expression is to expand the <a data-tooltip-position="top" aria-label="2.1.1 Hexadecimal Notation" data-href="2.1.1 Hexadecimal Notation" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html" class="internal-link" target="_self" rel="noopener nofollow">hexadecimal</a> arguments to their binary representations, perform the operation in binary, and then convert back to hex.A mask is a bit pattern that indicates a selected set of bits within a word.As an example, the mask 0xFF (having ones for the last significant 8 bits) indicates the low-order byte of a word. The bit-level operation &amp; yields a value consisting of the least significant byte of x, but with all other bytes set to 0. For example, with x = 0x89ABCDEF, the expression would yield 0x000000EF. The expression ~0 will yield a mask of all ones, regardless of the size of the data representation. The same mask can be written 0xFFFFFFFF when data type int is 32 bits, but it would not be as portable.The expression ~0xFF creates a mask where the 8 least-significant bits equal 0 and the rest equal 1. Observe that such a mask will be generated regardless of the word size. By contrast, the expression 0xFFFFFF00 would only work when data type int is 32 bits.]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.7 Bitwise operators.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 24 Jul 2025 19:41:03 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Operating System]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Software" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Software">#Software</a>We can think of the operating system as a layer of software interposed between the application and the hardware. Any attempt by an application program to manipulate the hardware must go through the operating system.The OS has two many purposes:
To protect the hardware from misuse by runaway application
To provide applications with simple and uniform mechanisms for manipulating complicated and often wildly different low-level hardware devices
The OS achieves this both via the fundamental abstraction shown in pictures<br>
<img alt="Pasted image 20250712193205.png" src="canekzamudio.com/assets/pasted-image-20250712193205.png" target="_self">
file<br><a href="canekzamudio.com?query=tag:Software" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Software">#Software</a> A file is a sequence of bytes, nothing more and nothing less. Every I/O device, including disks, keyboards, displays, and even networks, is modeled as a file. All input and output in the system is performed by reading and writing files, using a small set of system calls known as Unix I/O. are abstractions for I/O devices is an abstraction for both the main memory and disk I/O devices are abstractions for the processor, main memory and I/O devices<br>Threads
Although we normally think of a process as having single control flow, in modern systems a process can actually consist of multiple execution units, called <a data-href="threads" href="canekzamudio.com/cs_app/glossary/threads.html" class="internal-link" target="_self" rel="noopener nofollow">threads</a>...
]]></description><link>canekzamudio.com/cs_app/glossary/operating-system.html</link><guid isPermaLink="false">CS_APP/Glossary/Operating System.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 24 Jul 2025 00:00:16 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.1.6 Intro To Boolean Algebra]]></title><description><![CDATA[See more on <a data-href="1.1.1 Boolean Algebra" href="canekzamudio.com/boolean-logic/background/1.1.1-boolean-algebra.html" class="internal-link" target="_self" rel="noopener nofollow">1.1.1 Boolean Algebra</a><br>The simplest <a data-tooltip-position="top" aria-label="1.1.1 Boolean Algebra" data-href="1.1.1 Boolean Algebra" href="canekzamudio.com/boolean-logic/background/1.1.1-boolean-algebra.html" class="internal-link" target="_self" rel="noopener nofollow">boolean algebra</a> is defined over the two-element set {0, 1}<br>
<img alt="Pasted image 20250720142153.png" src="canekzamudio.com/assets/pasted-image-20250720142153.png" target="_self">
We can extend the four boolean operations to also operate on bit vectors, strings of zeros and ones of some fixed length . We define the operations over bit vectors according to their applications to the matching elements of the arguments.
Let and denote the bit vectors and , respectively. We define &amp; also be a bit vector of length , where the th element equals &amp; , for . The operations |, ^, and ~ are extended to bit vectors in a similar fashion.<br>
<img alt="Pasted image 20250722122228.png" src="canekzamudio.com/assets/pasted-image-20250722122228.png" target="_self">One useful application of bit vectors is to represent finite sets. We can encode any subset with a bit vector , where = 1 if and only if .
For example, recalling that we write on the left and on the right, bit vector encodes the set , while bit vector encodes the set . With this way of encoding sets, Boolean operations | and &amp; correspond to set union and intersection, respectively, and ~ corresponds to set complement. Continuing our earlier example, the operation a &amp; b yields bit vector , while .]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.6-intro-to-boolean-algebra.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.6 Intro To Boolean Algebra.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Tue, 22 Jul 2025 18:57:20 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.1.5 Representing Code]]></title><description><![CDATA[int sum(int x, int y)
{ return x + y;
}
When compiled on our sample machines, we generate machine code having the following byte representations:Linux 32 55 89 e5 8b 45 0c 03 45 08 c9 c3
Windows 55 89 e5 8b 45 0c 03 45 08 5d c3
Sun 81 c3 e0 08 90 02 00 09
Linux 64 55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3Different machine types use different and incompatible instructions and encodings. Even identical <a data-tooltip-position="top" aria-label="CPU" data-href="CPU" href="canekzamudio.com/cs_app/glossary/cpu.html" class="internal-link" target="_self" rel="noopener nofollow">processors</a> running different <a data-href="Operating System" href="canekzamudio.com/cs_app/glossary/operating-system.html" class="internal-link" target="_self" rel="noopener nofollow">Operating System</a>s have differences in their coding conventions and hence are not binary compatible. Binary code is seldom portable across different combinations of machine and operating system.
A program, from the perspective of the machine, is simply a sequence of bytes. The machine has no information about the original source program, except perhaps some auxiliary tables maintained to aid in debugging.
]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.5-representing-code.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.5 Representing Code.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 20 Jul 2025 20:15:17 GMT</pubDate></item><item><title><![CDATA[Unicode]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Software" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Software">#Software</a> The current Unicode Standart (version 7.0) has a repertoire of over 100,000 characters supporting a wide range of languages.The base encoding, known as the "Universal Character Set" of Unicode, uses a 32-bit representation of characters. This would seem to require every string of text to consist of 4 bytes per character. However, alternative codings are possible where common characters require just 1 or 2 bytes, while less common ones require moreThe UTF-8 representation encodes each character as a sequence of bytes, such that the standart ASCII byte sequences have the same meaning in UTF-8 as they do in ASCII.]]></description><link>canekzamudio.com/cs_app/glossary/unicode.html</link><guid isPermaLink="false">CS_APP/Glossary/Unicode.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 20 Jul 2025 20:08:29 GMT</pubDate></item><item><title><![CDATA[2.1.4 Representing Strings]]></title><description><![CDATA[A string in C is encoded by an array of characters terminated by the null (having value 0) character. Each character is represented by some standard encoding, with the most common being the ASCII character code.In a string "12345" and 6 (to include the terminating character), we get the result 31 32 33 34 35 00. This same result would be obtained on any system using ASCII as its character code, independent of the <a data-tooltip-position="top" aria-label="2.1.3 Addressing and Byte Ordering" data-href="2.1.3 Addressing and Byte Ordering" href="canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.3-addressing-and-byte-ordering.html" class="internal-link" target="_self" rel="noopener nofollow">byte ordering</a> and word size conventions. As a consequence, text data are more platform independent than binary data.]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.4-representing-strings.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.4 Representing Strings.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 20 Jul 2025 18:48:26 GMT</pubDate></item><item><title><![CDATA[2.1.2 Data Sizes]]></title><description><![CDATA[Every computer has a word size, indicating the nominal size of pointer data. Since a virtual address is encoded by such a word, the most important system parameter determined by the word size is the maximum size of the <a data-tooltip-position="top" aria-label="virtual memory > Virtual Address Space" data-href="virtual memory#Virtual Address Space" href="canekzamudio.com/cs_app/glossary/virtual-memory.html#Virtual Address Space" class="internal-link" target="_self" rel="noopener nofollow">virtual address space</a>. That is, for a machine with a -bit word size, the virtual addresses can range from 0 to , giving the program access to at most bytes.A 32-bit word size limits the virtual address space to 4GB, that is, just over bytes. Scaling up to a 64-bit word size leads to a virtual address space of 16 exabytes, or around Most 64-bit machines can also run programs for 32-bit machines with
gcc -m32 prog.c
The C lang supports multiple data formats for both integer and floating-point data. The exact numbers of bytes for some data types depends on how the program is compiled.<br>
<img alt="Pasted image 20250716183124.png" src="canekzamudio.com/assets/pasted-image-20250716183124.png" target="_self">
Integer data can be either signed, able to represent negative, zero, and positive values, or unsigned, only allowing nonnegative values. Data type char represents a single byte. Although the name char derives from the fact that it is used to store a single character in a text string, it can also be used to store integer values. Data types short, int, and long are intended to provide a range of sizesData types int32_t and int64_t have fixed data sizes regardless of compiler and machine settings. Using fixed-size integer types is the best way for programmers to have close control over data representations.Programmers should strive to make their programs portable across different machines and compilers. One aspect of portability is to make the program insensitive to the exact sizes of the different data types.]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.2-data-sizes.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.2 Data Sizes.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Thu, 17 Jul 2025 01:23:52 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.1.1 Hexadecimal Notation]]></title><description><![CDATA[Hexadecimal (or simply "hex") uses digits "0" through "9" along with characters "A" to "F" to represent 16 possible values, written in hexadecimal , the value of a single byte can range from to .A single byte consists of 8 bits. In binary notation, its values range from to . When viewed as a decimal integer, its value ranges from to .
Neither notation is very convenient for describing bit patterns. Binary notation is too verbose, while with decimal notation it is tedious to convert to and from bit patterns.. Instead, we write bit patterns as base-16, or hexadecimal numbers
<img alt="Pasted image 20250716131144.png" src="canekzamudio.com/assets/pasted-image-20250716131144.png" target="_self">
In C, numeric constants starting with 0x or 0X are interpreted as being in hexadecimal. The characters ‘A’ through ‘F’ may be written in either upper- or lowercase. For example, we could write the number FA1D37B16 as 0xFA1D37B, as 0xfa1d37b, or even mixing upper- and lowercase (e.g., 0xFa1D37b).When a value x is a power of 2, that is, x = 2n for some nonnegative integer n, we can readily write x in hexadecimal form by remembering that the binary representation of x is simply 1 followed by n zeros. The hexadecimal digit 0 represents 4 binary zeros. So, for n written in the form i + 4j , where 0 ≤ i ≤ 3, we can write x with a leading hex digit of 1 (i = 0), 2 (i = 1), 4 (i = 2), or 8 (i = 3), followed by j hexadecimal 0s. As an example, for x = 2,048 = 2 11, we have n = 11 = 3 + 4 . 2, giving hexadecimal representation 0x800.To convert a decimal number x to hexadecimal, we can repeatedly divide x by 16, giving a quotient q and a remainder r, such that x = q . 16 + r. We then use the hexadecimal digit representing r as the least significant digit and generate the remaining digits by repeating the process on q. As an example, consider the conversion of decimal 314,156: From this we can read off the hexadecimal representation as 0x4CB2C.Conversely, to convert a hexadecimal number to decimal, we can multiply each of the hexadecimal digits by the appropriate power of 16. For example, given the number 0x7AF, we compute its decimal equivalent as ]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.1 Hexadecimal Notation.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 16 Jul 2025 21:45:31 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2.1.0 Information Storage]]></title><description><![CDATA[Most computers use bytes (blocks of 8 bits), as the smallest addressable unit of memory. A machine-level program views memory as a very large array of bytes, referred to as <a data-href="virtual memory" href="canekzamudio.com/cs_app/glossary/virtual-memory.html" class="internal-link" target="_self" rel="noopener nofollow">virtual memory</a>. Every byte of memory is identified by a unique number, known as its address, and the set of all possible addresses is known as the virtual address space.<br>
<img alt="Pasted image 20250715224120.png" src="canekzamudio.com/assets/pasted-image-20250715224120.png" target="_self" style="width: 600px; max-width: 100%;"><br>
This virtual address space is just a conceptual image presented to the machine-level program. The actual implementation uses a combination of dynamic random access memory (DRAM), flash memory, disk storage, special hardware, and <a data-href="Operating System" href="canekzamudio.com/cs_app/glossary/operating-system.html" class="internal-link" target="_self" rel="noopener nofollow">Operating System</a> software to provide the program with what appears to be a monolithic byte array<br>Various mechanisms are used to allocate and manage the storage for different parts of the program. This management is all performed within the virtual address space. For example, the value of a <a data-tooltip-position="top" aria-label="Pointers" data-href="Pointers" href="canekzamudio.com/indexes/coding/c/pointers.html" class="internal-link" target="_self" rel="noopener nofollow">pointer</a> in C --whether it points to an integer, a structure, or some other program object-- is the virtual address of the first byte of some block storage. The C compiler also associates type information with each pointer, so that it can generate different machine-level code to access the value stored at the location designated by the pointer depending on the type of that value. Although the C compiler maintains this type information, the actual machine-level program it generates has no information about data types. It simply treats each program object as a block of bytes and the program itself as a sequence of bytes.]]></description><link>canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.0-information-storage.html</link><guid isPermaLink="false">CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.0 Information Storage.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 16 Jul 2025 04:57:11 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1.0 Computer Systems]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:CS_Architecture" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CS_Architecture">#CS_Architecture</a>A computer system consists of hardware and systems software that cooperate to run application programs. Information inside the computer is represented as groups of bits that are interpreted in different ways, depending on the context. Programs are translated by other programs into different forms, beginning as ASCII text and then translated by compilers and linkers into binary executable files.
Processors read and interpret binary instructions that are stored in main memory. Since computers spend most of their time copying data between memory, I/O devices, and the CPU registers, the storage devices in a system are arranged in a hierarchy, with the CPU registers at the top, followed by multiple levels of hardware cache memories, DRAM main memory, and disk storage. Storage devices that are higher in the hierarchy are faster and more costly per bit than those lower in the hierarchy. Storage devices that are higher in the hierarchy serve as caches for devices that are lower in the hierarchy. Programmers can optimize the performance of their C programs by understanding and exploiting the memory hierarchy.The operating system kernel serves as an intermediary between the application and the hardware. It provides three fundamental abstractions: (1) Files are abstractions for I/O devices. (2) Virtual memory is an abstraction for both main memory and disks. (3) Processes are abstractions for the processor, main memory, and I/O devices. Finally, networks provide ways for computer systems to communicate with one another. From the viewpoint of a particular system, the network is just another I/O device.]]></description><link>canekzamudio.com/cs_app/i.-computer-systems/1.0-computer-systems.html</link><guid isPermaLink="false">CS_APP/I. Computer Systems/1.0 Computer Systems.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 16 Jul 2025 00:53:02 GMT</pubDate></item><item><title><![CDATA[1.9.2 Concurrency and Parallelism]]></title><description><![CDATA[Throughout the history of digital computers, two demands have been constant forces in driving improvements: we want them to do more, and we want them to run faster. Both of these factors improve when the processor does more things at once.<a data-href="Parallelism" href="canekzamudio.com/cs_app/glossary/parallelism.html" class="internal-link" target="_self" rel="noopener nofollow">Parallelism</a> can be exploited at multiple levels of abstraction in a computer system. We highlight three levels here, working from the highest to the lowest level in the system hierarchy.<br>We are able to execute multiple processes at the same time, leading to <a data-href="concurrency" href="canekzamudio.com/cs_app/glossary/concurrency.html" class="internal-link" target="_self" rel="noopener nofollow">concurrency</a>. With <a data-href="threads" href="canekzamudio.com/cs_app/glossary/threads.html" class="internal-link" target="_self" rel="noopener nofollow">threads</a>, we can even have multiple control flows executing within a single process<br>When we construct a system consisting of multiple processors all under the control of a single OS <a data-href="kernel" href="canekzamudio.com/cs_app/glossary/kernel.html" class="internal-link" target="_self" rel="noopener nofollow">kernel</a>, we have a multiprocessor system (or <a data-href="multi-core processor" href="canekzamudio.com/cs_app/glossary/multi-core-processor.html" class="internal-link" target="_self" rel="noopener nofollow">multi-core processor</a>).multi-core processor<br>Multi-core processors have several <a data-href="CPU" href="canekzamudio.com/cs_app/glossary/cpu.html" class="internal-link" target="_self" rel="noopener nofollow">CPU</a>s referred to as "cores", integrated onto a single integrated-circuit chip.<br>
<img alt="Pasted image 20250715174131.png" src="canekzamudio.com/assets/pasted-image-20250715174131.png" target="_self"><br>
<img alt="Pasted image 20250715174158.png" src="canekzamudio.com/assets/pasted-image-20250715174158.png" target="_self"><br>
Typical multi-core processors have four CPU cores in a single chip, each with its own L1 and L2 <a data-tooltip-position="top" aria-label="cache memories" data-href="cache memories" href="canekzamudio.com/cs_app/glossary/cache-memories.html" class="internal-link" target="_self" rel="noopener nofollow">caches</a>, and with each L1 cache split into two parts - one to hold recently fetched instructions and one to hold data. The cores share higher levels of cache as well as the interface to <a data-href="Main Memory" href="canekzamudio.com/cs_app/glossary/main-memory.html" class="internal-link" target="_self" rel="noopener nofollow">Main Memory</a>. In future a single chip may have hundreds of cores.hyperthreading<br>*Hyperthreading, sometimes called "simultaneous multi-threading", is a technique that allows a single CPU to execute multiple flows of control. It involves having multiple copies of some of the CPU hardware, such as program counters and <a data-href="register file" href="canekzamudio.com/cs_app/glossary/register-file.html" class="internal-link" target="_self" rel="noopener nofollow">register file</a>s, while having only single copies of other parts of the hardware, such as the units that perform floating-point arithmetic (<a data-href="ALU" href="canekzamudio.com/cs_app/glossary/alu.html" class="internal-link" target="_self" rel="noopener nofollow">ALU</a>)*.Whereas a conventional processor requires around 20,000 clock cycles to shift between different threads, a hyperthreaded processor decides which of its threads to execute on a cycle-bycycle basis. It enables the CPU to take better advantage of its processing resources. For example, if one thread must wait for some data to be loaded into a cache, the CPU can proceed with the execution of a different thread. As an example, the Intel Core i7 processor can have each core executing two threads, and so a four-core system can actually execute eight threads in parallel.The use of multiprocessing can improve system performance in two ways. First, it reduces the need to simulate concurrency when performing multiple tasks. As mentioned, even a personal computer being used by a single person is expected to perform many activities concurrently. Second, it can run a single application program faster, but only if that program is expressed in terms of multiple threads that can effectively execute in parallel. At a much lower level of abstraction, modern processors can execute multiple instructions at one time, a property known as instruction-level parallelism.
i.e., early microprocessors, required multiple (typically 3-10) clock cycles to execute a single instruction. More recent processors can sustain execution rates of 2-4 instructions per clock cycle. Any given instruction requires much longer from start to finish, perhaps 20 cycles or more, but the processor uses a number of clever tricks to process as many as 100 instructions at a timeIn Chapter 4, we will explore the use of pipelining, where the actions required to execute an instruction are partitioned into different steps and the processor hardware is organized as a series of stages, each performing one of these steps. The stages can operate in parallel, working on different parts of different instructions. We will see that a fairly simple hardware design can sustain an execution rate close to 1 instruction per clock cycle.Processors that can sustain execution rates faster than 1 instruction per cycle are known as superscalar processors. Most modern processors support superscalar operationAt the lowest level, many modern processors have special hardware that allows a single instruction to cause multiple operations to be performed in parallel, a mode known as single-instruction, multiple data (SIMD) parallelism.Recent generations of Intel and AMD processors have instructions that can add 8 pairs of single-precision floating-point numbers (C data type float) in parallelThese SIMD instructions are provided mostly to speed up applications that process image, sound, and video data. Although some compilers attempt to automatically extract SIMD parallelism from C programs, a more reliable method is to write programs using special vector data types supported in compilers such as GCC.]]></description><link>canekzamudio.com/cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html</link><guid isPermaLink="false">CS_APP/I. Computer Systems/1.9 Important Themes/1.9.2 Concurrency and Parallelism.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 16 Jul 2025 00:44:40 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hyperthreading]]></title><description><![CDATA[*Hyperthreading, sometimes called "simultaneous multi-threading", is a technique that allows a single CPU to execute multiple flows of control. It involves having multiple copies of some of the CPU hardware, such as program counters and <a data-href="register file" href="canekzamudio.com/cs_app/glossary/register-file.html" class="internal-link" target="_self" rel="noopener nofollow">register file</a>s, while having only single copies of other parts of the hardware, such as the units that perform floating-point arithmetic (<a data-href="ALU" href="canekzamudio.com/cs_app/glossary/alu.html" class="internal-link" target="_self" rel="noopener nofollow">ALU</a>)*.Whereas a conventional processor requires around 20,000 clock cycles to shift between different threads, a hyperthreaded processor decides which of its threads to execute on a cycle-bycycle basis. It enables the CPU to take better advantage of its processing resources. For example, if one thread must wait for some data to be loaded into a cache, the CPU can proceed with the execution of a different thread. As an example, the Intel Core i7 processor can have each core executing two threads, and so a four-core system can actually execute eight threads in parallel.]]></description><link>canekzamudio.com/cs_app/glossary/hyperthreading.html</link><guid isPermaLink="false">CS_APP/Glossary/hyperthreading.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Wed, 16 Jul 2025 00:04:29 GMT</pubDate></item><item><title><![CDATA[Parallelism]]></title><description><![CDATA[We use the term paralelism to refer to the use of <a data-href="concurrency" href="canekzamudio.com/cs_app/glossary/concurrency.html" class="internal-link" target="_self" rel="noopener nofollow">concurrency</a> to make a system run faster]]></description><link>canekzamudio.com/cs_app/glossary/parallelism.html</link><guid isPermaLink="false">CS_APP/Glossary/Parallelism.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Tue, 15 Jul 2025 23:38:44 GMT</pubDate></item><item><title><![CDATA[1.9.0 Important Themes]]></title><description><![CDATA[An important idea to take away from this is that system is more than just hardware. It is a collection of intertwined hardware and systems software that must cooperate in order to achieve the ultimate goal of running application programs.Throughout the history of digital computers, two demands have been constant forces in driving improvements: we want them to do more, and we want them to run faster. Both of these factors improve when the processor does more things at once.Parallelism can be exploited at multiple levels of abstraction in a computer system. We highlight three levels here, working from the highest to the lowest level in the system hierarchy.]]></description><link>canekzamudio.com/cs_app/i.-computer-systems/1.9-important-themes/1.9.0-important-themes.html</link><guid isPermaLink="false">CS_APP/I. Computer Systems/1.9 Important Themes/1.9.0 Important Themes.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Tue, 15 Jul 2025 23:38:42 GMT</pubDate></item><item><title><![CDATA[concurrency]]></title><description><![CDATA[We use the term concurrency to refer to the general concept of a system with multiple, simultaneous activities]]></description><link>canekzamudio.com/cs_app/glossary/concurrency.html</link><guid isPermaLink="false">CS_APP/Glossary/concurrency.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Tue, 15 Jul 2025 21:41:16 GMT</pubDate></item><item><title><![CDATA[Amdahl's Law]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Maths" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Maths">#Maths</a>The main idea is that when we speed up one part of a system, the effect on the overall system performance depends on both how insignificant this part was and how much it sped up.Consider a system in which executing some application requires time . Suppose some part of the system requires a fraction of this time, and that we improve its performance by a factor of . That is, the component originally required time , and it now requires time . The overall execution time would thus beFrom this, we can compute the speedup asConsider the case where a part of the system that initially consumed 60% of the time is sped up by a factor of 3 . Then we get a speedup of . Even though we made a substantial improvement to a major part of the system, our net speedup was significantly less than the speedup for the one part. This is the major insight of Amdahl's law - to significantly speed up the entire system, we must improve the speed of a very large fraction of the overall system.One interesting special case of Amdahl’s law is to consider the effect of setting k to ∞. That is, we are able to take some part of the system and speed it up to the point at which it takes a negligible amount of time. We then get So, for example, if we can speed up 60% of the system to the point where it requires close to no time, our net speedup will still only be .Amdahl's law describes a general principle for improving any process. In addition to its application to speeding up computer systems, it can guide a company trying to reduce the cost of manufacturing razor blades, or a student trying to improve his or her grade point average. Perhaps it is most meaningful in the world of computers, where we routinely improve performance by factors of 2 or more. Such high factors can only be achieved by optimizing large parts of a system.]]></description><link>canekzamudio.com/cs_app/i.-computer-systems/1.9-important-themes/amdahl's-law.html</link><guid isPermaLink="false">CS_APP/I. Computer Systems/1.9 Important Themes/Amdahl's Law.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Tue, 15 Jul 2025 21:19:44 GMT</pubDate></item><item><title><![CDATA[1.8.0 Systems Communicate with Other Systems Using Networks]]></title><description><![CDATA[Modern systems are often linked to other systems by networks. From the point of view of an individual system, the network can be viewed as just another <a data-href="I-O Devices" href="canekzamudio.com/cs_app/glossary/i-o-devices.html" class="internal-link" target="_self" rel="noopener nofollow">I-O Devices</a>. When the system copies a sequence of bytes from <a data-href="Main Memory" href="canekzamudio.com/cs_app/glossary/main-memory.html" class="internal-link" target="_self" rel="noopener nofollow">Main Memory</a> to the network <a data-href="Adapter" href="canekzamudio.com/cs_app/glossary/adapter.html" class="internal-link" target="_self" rel="noopener nofollow">Adapter</a>, the data flow across the network to another machine, instead of, say, to a local disk drive, and the system can read data sent from other machines and copy these data to its main memory.<br>Cause of <a data-href="Internet" href="canekzamudio.com/indexes/networking/internet.html" class="internal-link" target="_self" rel="noopener nofollow">Internet</a>, copying information from one machine to another has become one of the most important uses of computer systems. i.e. applications such as email, instant messaging, the World Wide Web, FTP, and telnet are all based on the ability to copy information over a network.<br>
<img alt="Pasted image 20250715124434.png" src="canekzamudio.com/assets/pasted-image-20250715124434.png" target="_self">]]></description><link>canekzamudio.com/cs_app/i.-computer-systems/1.8-systems-comunicate-with-other-systems-using-networks/1.8.0-systems-communicate-with-other-systems-using-networks.html</link><guid isPermaLink="false">CS_APP/I. Computer Systems/1.8 Systems Comunicate with Other Systems Using Networks/1.8.0 Systems Communicate with Other Systems Using Networks.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Tue, 15 Jul 2025 18:44:36 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[file]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Software" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Software">#Software</a> A file is a sequence of bytes, nothing more and nothing less. Every I/O device, including disks, keyboards, displays, and even networks, is modeled as a file. All input and output in the system is performed by reading and writing files, using a small set of system calls known as Unix I/O.]]></description><link>canekzamudio.com/cs_app/glossary/file.html</link><guid isPermaLink="false">CS_APP/Glossary/file.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Tue, 15 Jul 2025 18:29:44 GMT</pubDate></item><item><title><![CDATA[kernel]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Software" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Software">#Software</a> <br>The kernel is the portion of the <a data-href="Operating System" href="canekzamudio.com/cs_app/glossary/operating-system.html" class="internal-link" target="_self" rel="noopener nofollow">Operating System</a> code that is always resident in memory, it is a collection of code and data structures that the system uses to manage all the <a data-href="processes" href="canekzamudio.com/cs_app/glossary/processes.html" class="internal-link" target="_self" rel="noopener nofollow">processes</a>.When an application program requires some action by the operating system, such as to read or write a file, it executes a special system call instruction, transferring control to the kernel. The kernel then performs the requested operation and returns back to the application program]]></description><link>canekzamudio.com/cs_app/glossary/kernel.html</link><guid isPermaLink="false">CS_APP/Glossary/kernel.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 13 Jul 2025 02:19:02 GMT</pubDate></item><item><title><![CDATA[Shell]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Software" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Software">#Software</a>The shell is a command-line interpreter that prints a prompt, waits for you to type a command line, and then performs the commandIf the first word of the command line does not correspond to a built-in shell command, then the shell assumes that it is the name of an executable file that it should load and run. ]]></description><link>canekzamudio.com/cs_app/glossary/shell.html</link><guid isPermaLink="false">CS_APP/Glossary/Shell.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 13 Jul 2025 00:34:50 GMT</pubDate></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/i.-computer-systems/1.7-os-manages-the-hardware/1.7.0-the-os-manages-the-hardware.html</link><guid isPermaLink="false">CS_APP/I. Computer Systems/1.7 OS Manages the Hardware/1.7.0 The OS Manages the Hardware.md</guid></item><item><title><![CDATA[1.6.1 Storage Devices Form a Hierarchy]]></title><description><![CDATA[The storage devices in evey computer systems are organized as a memory hierarchy.As we move from the top of the hierarchy to the bottom, the devices become slower, larger, and less costly per byte. The register file occupies the top level in the hierarchy, which is known as level 0 or L0. We show three levels of caching L1 to L3, occupying memory hierarchy levels 1 to 3. Main memory occupies level 4, and so on.<img alt="Pasted image 20250712180214.png" src="canekzamudio.com/assets/pasted-image-20250712180214.png" target="_self">
Just as programmers can exploit knowledge of the different caches to improve performance, programmers can exploit their understanding of the entire memory hierarchy.r]]></description><link>canekzamudio.com/cs_app/i.-computer-systems/1.6-storage-devices-form-a-hierarchy/1.6.1-storage-devices-form-a-hierarchy.html</link><guid isPermaLink="false">CS_APP/I. Computer Systems/1.6 Storage Devices Form a Hierarchy/1.6.1 Storage Devices Form a Hierarchy.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 13 Jul 2025 00:26:19 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cache memories]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Hardware" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hardware">#Hardware</a> <br>Caches serve as temporary staging areas for information that the <a data-tooltip-position="top" aria-label="CPU" data-href="CPU" href="canekzamudio.com/cs_app/glossary/cpu.html" class="internal-link" target="_self" rel="noopener nofollow">processor</a> is likely to need in the near future.<br>
<img alt="Pasted image 20250712174037.png" src="canekzamudio.com/assets/pasted-image-20250712174037.png" target="_self">
The idea behind caching is that a system can get the effect of both a very large memory and a very fast one by exploiting locality, the tendency for programs to access data and code in localized regions.By setting up caches to hold data that they are likely to be accessed often, we can perform most memory operations using the fast caches.<br>An L1 cache on the processor chip holds tens of thousands of bytes and can be accessed nearly as fast as the <a data-href="register file" href="canekzamudio.com/cs_app/glossary/register-file.html" class="internal-link" target="_self" rel="noopener nofollow">register file</a>.<br>A larger L2 cache with hundreds of thousands to millions of bytes is connected to the processor by a special bus. It might take 5 times longer for the processor to access the L2 cache than the L1 cache, but this is still 5 to 10 times faster than accessing the <a data-href="Main Memory" href="canekzamudio.com/cs_app/glossary/main-memory.html" class="internal-link" target="_self" rel="noopener nofollow">Main Memory</a>.The L1 and L2 caches are implemented with a hardware technology known as static random access memory (SRAM). Newer and more powerful systems even have three levels of cache: L1, L2 and L3. Memory Hierarchy
Applications programmers who are aware of the cache memories can exploit them to improve the performance of their programs by an order of magnitude<br>
<img alt="Pasted image 20250712175559.png" src="canekzamudio.com/assets/pasted-image-20250712175559.png" target="_self" style="width: 600px; max-width: 100%;">
]]></description><link>canekzamudio.com/cs_app/glossary/cache-memories.html</link><guid isPermaLink="false">CS_APP/Glossary/cache memories.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sat, 12 Jul 2025 23:56:36 GMT</pubDate><enclosure url="canekzamudio.com" length="0" type="application/x-msdownload"/><content:encoded>&lt;figure&gt;&lt;img src="canekzamudio.com"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html</link><guid isPermaLink="false">CS_APP/I. Computer Systems/1.5 Caches Matter/1.5.0 Caches Matter.md</guid></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html</link><guid isPermaLink="false">CS_APP/I. Computer Systems/1.4 Processors Read and Interpret Instrucions Stored in Memory/1.4.1 Hardware Organization of a System.md</guid></item><item><title><![CDATA[CPU]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Hardware" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hardware">#Hardware</a> *The central processing unit (CPU), or simply processor, is the engine that interprets (or executes) instructions stored in main memory. At its core is a word-size storage device (or register) called the program counter (PC). At any point in time, the PC points at (contains the address of) some machine-language instruction in main memory.From the time that power is applied to the system until the time that the power is shut off, a processor repeatedly executes the instruction pointed at by the program counter and updates the program counter to point to the next instruction. A processor appears to operate according to a very simple instruction execution model, defined by its instruction set architecture.
In this model, instructions execute in strict sequence, and executing a single instruction involves performing a series of steps. The processor reads the instruction from memory pointed at by the program counter (PC), interprets the bits in the instruction, performs some simple operation dictated by the instruction, which may or may not be contiguous in memory to the instruction that was just executed.<br>
There are only a few of these simple operations, and they revolve around <a data-href="Main Memory" href="canekzamudio.com/cs_app/glossary/main-memory.html" class="internal-link" target="_self" rel="noopener nofollow">Main Memory</a>, the <a data-href="register file" href="canekzamudio.com/cs_app/glossary/register-file.html" class="internal-link" target="_self" rel="noopener nofollow">register file</a>, and the arithmetic/logic unit (<a data-href="ALU" href="canekzamudio.com/cs_app/glossary/alu.html" class="internal-link" target="_self" rel="noopener nofollow">ALU</a>).Simple operations that the CPU might carry out at the request of an instruction:
Load: Copy a byte or a word from main memory into a register, overwriting the previous contents of the register.
Store: Copy a byte or a word from a register to a location in main memory, overwriting the previous contents of that location.
<br>Operate: Copy the contents of two registers to the <a data-href="ALU" href="canekzamudio.com/cs_app/glossary/alu.html" class="internal-link" target="_self" rel="noopener nofollow">ALU</a>, perform an arithmetic operation on the two words, and store the result in a register, overwriting the previous contents of that register.
Jump: Extract a word from the instruction itself and copy that word into the program counter (PC), overwriting the previous value of the PC
A processor appears to be a simple implementation of its instruction set architecture, but in fact modern processors use far more complex mechanisms to speed up program execution.]]></description><link>canekzamudio.com/cs_app/glossary/cpu.html</link><guid isPermaLink="false">CS_APP/Glossary/CPU.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sat, 12 Jul 2025 23:06:28 GMT</pubDate></item><item><title><![CDATA[Adapter]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Hardware" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hardware">#Hardware</a> An adapter is a card that plugs into a slot on the motherboardThe main purpose is to transfer information back and forth between the I/O bus and an I/O device.]]></description><link>canekzamudio.com/cs_app/glossary/adapter.html</link><guid isPermaLink="false">CS_APP/Glossary/Adapter.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 06 Jul 2025 21:52:17 GMT</pubDate></item><item><title><![CDATA[I-O Devices]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Hardware" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hardware">#Hardware</a> *Input/output (I/O) devices are the system's connection to the external world. i.e., a keyboard and a mouse for user input, a display for user output, and a disk drive (or simply disk) for long-term storage of data and programs.Each I/O device is connected to the I/O bus by either a controller or an adapter. The distinction between these two is mainly one of packaging.Controller<br><a href="canekzamudio.com?query=tag:Hardware" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hardware">#Hardware</a> Controllers are chip sets in the device itself or on the system's main printed circuit board (motherboard).The main purpose is to transfer information back and forth between the I/O bus and an I/O device.Adapter<br><a href="canekzamudio.com?query=tag:Hardware" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hardware">#Hardware</a> An adapter is a card that plugs into a slot on the motherboardThe main purpose is to transfer information back and forth between the I/O bus and an I/O device.]]></description><link>canekzamudio.com/cs_app/glossary/i-o-devices.html</link><guid isPermaLink="false">CS_APP/Glossary/I-O Devices.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 06 Jul 2025 21:52:17 GMT</pubDate></item><item><title><![CDATA[ALU]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Hardware" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hardware">#Hardware</a> The ALU computes new data and address values]]></description><link>canekzamudio.com/cs_app/glossary/alu.html</link><guid isPermaLink="false">CS_APP/Glossary/ALU.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 06 Jul 2025 21:52:17 GMT</pubDate></item><item><title><![CDATA[Buses]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Hardware" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hardware">#Hardware</a>Running throughout the system is a collection of electrical conduits called buses that carry bytes of information back and forth between the components. Buses are typically designed to transfer fixed-size chunks of bytes known as words.The number of bytes in a word ( the word size) is a fundamental system parameter that varies across systems. Most machines today have word sizes of either 4 bytes(32 bits) or 8 bytes(64 bits). ]]></description><link>canekzamudio.com/cs_app/glossary/buses.html</link><guid isPermaLink="false">CS_APP/Glossary/Buses.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 06 Jul 2025 21:52:17 GMT</pubDate></item><item><title><![CDATA[Controller]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Hardware" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hardware">#Hardware</a> Controllers are chip sets in the device itself or on the system's main printed circuit board (motherboard).The main purpose is to transfer information back and forth between the I/O bus and an I/O device.]]></description><link>canekzamudio.com/cs_app/glossary/controller.html</link><guid isPermaLink="false">CS_APP/Glossary/Controller.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 06 Jul 2025 21:52:17 GMT</pubDate></item><item><title><![CDATA[Main Memory]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Hardware" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hardware">#Hardware</a> The main memory is a temporary storage device that holds both a program and the data it manipulates while the processor is executing the program.Physically, main memory consists of a collection of dynamic random access memory(DRAM)
chips. Logically, memory is organized as a linear array of bytes, each with its own unique address (array index) starting at 0. In general, each of the machine instructions that constitute a program can consist of a variable number of bytes.The size of data items that correspond to C program variables vary according to type. For example, on an x86-64 machine running linux, data of type short require 2 bytes, types int and float 4 bytes, and types long and double 8 bytes]]></description><link>canekzamudio.com/cs_app/glossary/main-memory.html</link><guid isPermaLink="false">CS_APP/Glossary/Main Memory.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 06 Jul 2025 21:52:17 GMT</pubDate></item><item><title><![CDATA[register file]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:Hardware" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hardware">#Hardware</a> The register file is a small storage device that consists of a collection of word-size registers, each with its own unique name.]]></description><link>canekzamudio.com/cs_app/glossary/register-file.html</link><guid isPermaLink="false">CS_APP/Glossary/register file.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 06 Jul 2025 21:52:16 GMT</pubDate></item><item><title><![CDATA[1.4.0 Processors Read and Interpret Instructions Stored in Memory]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:CompilationSystem" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CompilationSystem">#CompilationSystem</a> <br>At this point, our hello.c source program has been translated by the compilation system into an executable object file called hello that is stored on disk. To run the executable file on a Unix system, we type its name to an application program known as a <a data-href="Shell" href="canekzamudio.com/cs_app/glossary/shell.html" class="internal-link" target="_self" rel="noopener nofollow">Shell</a>:linux&gt; ./hello hello, world
In this case, the shell loads and runs the hello program and then waits for it to terminate. The hello program prints its message to the screen and then terminates. The shell then prints a prompt and waits for the next input command line.]]></description><link>canekzamudio.com/cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.0-processors-read-and-interpret-instructions-stored-in-memory.html</link><guid isPermaLink="false">CS_APP/I. Computer Systems/1.4 Processors Read and Interpret Instrucions Stored in Memory/1.4.0 Processors Read and Interpret Instructions Stored in Memory.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 06 Jul 2025 21:52:16 GMT</pubDate></item><item><title><![CDATA[1.3 It pays to Understand How Compilation Systems Work]]></title><description><![CDATA[<a href="canekzamudio.com?query=tag:CompilationSystem" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CompilationSystem">#CompilationSystem</a>For simple programs such as hello.c we can rely on the compilation system to produce correct and efficient machine code, but there are some important reasons why programmers need to understand how compilation systems work: In order to make good coding decisions in our C programs, we do need a basic understanding of machine-level code and how the compiler translates different C statements into machine code. Is a switch statement always more efficient than a sequence of if-else statements?**
Is a while loop more efficient than a for loop?
Are pointer references more efficient than array indexes?
How can a function run faster when we simply rearrange the parentheses in an arithmetic expression? Some of the most perplexing programming errors are related to the operation of the linker, especially in large software systems what does it mean when the linker reports that it cannot resolve a reference?
What is the difference between a static variable and a global variable?
What happens if you define two global variables in different C files with the same name?
What is the difference between a static library and a dynamic library?
Why does it matter what order we list libraries on the command line? Why do some linker-related errors not appear until run time? Buffer overflow vulnerabilities have accounted for many of the security holes in network and Internet servers. These vulnerabilities exist because too few programmers understand the need to carefully restrict the quantity and forms of data they accept from untrusted sources.
A first step in learning secure programming is to understand the consequences of the way data and control information are stored on the program stack
]]></description><link>canekzamudio.com/cs_app/i.-computer-systems/1.3-pays-to-understand-how-compilation-systems-work/1.3-it-pays-to-understand-how-compilation-systems-work.html</link><guid isPermaLink="false">CS_APP/I. Computer Systems/1.3 Pays to Understand How Compilation Systems Work/1.3 It pays to Understand How Compilation Systems Work.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 06 Jul 2025 21:52:16 GMT</pubDate></item><item><title><![CDATA[No title]]></title><link>canekzamudio.com/cs_app/i.-computer-systems/1.2-programs-are-translated-by-other-programs-in-different-forms/1.2-programs-are-translated-by-other-programs-into-different-forms.html</link><guid isPermaLink="false">CS_APP/I. Computer Systems/1.2 Programs are Translated by other Programs in Different Forms/1.2 Programs Are Translated by Other Programs into Different Forms.md</guid></item><item><title><![CDATA[1.1 Information is Bits + Context]]></title><description><![CDATA[hello program begins life as a source program (or source file) that the programmer creates with an editor and saves in a text file called hello.c. The program is a sequence of bits, each with a value of 0 or 1, organized in 8-bit chunks called <a data-href="bytes" href="canekzamudio.com/.html" class="internal-link" target="_self" rel="noopener nofollow">bytes</a>, each byte represents some text character in the program.Most computer systems represent text characters using the ASCII standard that represents each character with a unique byte-size integer value.Files such as hello.c that consist exclusively of ASCII characters are known as text files, all other files are known as binary files.
All information in a system, including disk files, programs stored in memory, user data stores in memory, and data transferred across a network, is represented as a bunch of bits.
The only thing that distinguishes different data objects is the context in which we view them. ie, in different contexts, the same sequence of bytes might represent an integer, floating-point number, character string, or machine instruction.
<br>...<a data-href="1.2 Programs Are Translated by Other Programs into Different Forms" href="canekzamudio.com/cs_app/i.-computer-systems/1.2-programs-are-translated-by-other-programs-in-different-forms/1.2-programs-are-translated-by-other-programs-into-different-forms.html" class="internal-link" target="_self" rel="noopener nofollow">1.2 Programs Are Translated by Other Programs into Different Forms</a>]]></description><link>canekzamudio.com/cs_app/i.-computer-systems/1.1-information-is-bits-+-context/1.1-information-is-bits-+-context.html</link><guid isPermaLink="false">CS_APP/I. Computer Systems/1.1 Information is Bits + Context/1.1 Information is Bits + Context.md</guid><dc:creator><![CDATA[Canek]]></dc:creator><pubDate>Sun, 06 Jul 2025 21:52:16 GMT</pubDate></item></channel></rss>