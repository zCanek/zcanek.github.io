{"createdTime":1769640479154,"shownInTree":["cs_app/glossary/adapter.html","cs_app/glossary/alu.html","cs_app/glossary/buses.html","cs_app/glossary/cache-memories.html","cs_app/glossary/concurrency.html","cs_app/glossary/controller.html","cs_app/glossary/cpu.html","cs_app/glossary/file.html","cs_app/glossary/hyperthreading.html","cs_app/glossary/i-o-devices.html","cs_app/glossary/isa-instruction-set-architecture.html","cs_app/glossary/kernel.html","cs_app/glossary/main-memory.html","cs_app/glossary/multi-core-processor.html","cs_app/glossary/operating-system.html","cs_app/glossary/parallelism.html","cs_app/glossary/processes.html","cs_app/glossary/program-stack.html","cs_app/glossary/register.html","cs_app/glossary/register-file.html","cs_app/glossary/shell.html","cs_app/glossary/threads.html","cs_app/glossary/tib,-teb-&-peb.html","cs_app/glossary/transistor.html","cs_app/glossary/unicode.html","cs_app/glossary/virtual-memory.html","cs_app/i.-computer-systems/1.1-information-is-bits-+-context/1.1-information-is-bits-+-context.html","cs_app/i.-computer-systems/1.2-programs-are-translated-by-other-programs-in-different-forms/1.2-programs-are-translated-by-other-programs-into-different-forms.html","cs_app/i.-computer-systems/1.3-pays-to-understand-how-compilation-systems-work/1.3-it-pays-to-understand-how-compilation-systems-work.html","cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.0-processors-read-and-interpret-instructions-stored-in-memory.html","cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html","cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html","cs_app/i.-computer-systems/1.6-storage-devices-form-a-hierarchy/1.6.1-storage-devices-form-a-hierarchy.html","cs_app/i.-computer-systems/1.7-os-manages-the-hardware/1.7.0-the-os-manages-the-hardware.html","cs_app/i.-computer-systems/1.8-systems-comunicate-with-other-systems-using-networks/1.8.0-systems-communicate-with-other-systems-using-networks.html","cs_app/i.-computer-systems/1.9-important-themes/1.9.0-important-themes.html","cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html","cs_app/i.-computer-systems/1.9-important-themes/1.9.3-the-importance-of-abstractions-in-computer-systems.html","cs_app/i.-computer-systems/1.9-important-themes/amdahl's-law.html","cs_app/i.-computer-systems/1.0-computer-systems.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.0-information-storage.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.2-data-sizes.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.3-addressing-and-byte-ordering.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.4-representing-strings.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.5-representing-code.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.6-intro-to-boolean-algebra.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.8-logical-operations-in-c.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.0-integer-representations.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.1-integral-data-types.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.2-unsigned-encodings.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.3-two's-complement-encodings.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.4-t2u-&-u2t.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.5-signed-versus-unsigned-in-c.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.6-expanding-the-bit-representation-of-a-number.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.7-truncating-numbers.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.8-advice-on-signed-versus-unsigned.html","cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.1-unsigned-addition.html","cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.2-two's-complement-addition.html","cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.3-two's-complement-negation.html","cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.4-unsigned-multiplication.html","cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.5-two's-complement-multiplication.html","cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.6-multiplying-by-constants.html","cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.7-dividing-by-powers-of-2.html","cs_app/iii.-machine-lever-representation-of-programs/3.1-a-historical-perspective/3.0.0-machine-level-representation-of-programs.html","cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.0-program-encodings.html","cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.1-machine-level-code.html","cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.2-code-examples.html","cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.3-notes-on-formatting.html","cs_app/iii.-machine-lever-representation-of-programs/3.3-data-formats/3.3.0-data-formats.html","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.0-accessing-information.html","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.2-data-movement-instructions.html","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.3-data-movement-example.html","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.4-pushing-and-popping-stack-data.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.0-arithmetic-and-logical-operations.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.1-load-effective-address.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.2-unary-and-binary-operations.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.3-shift-operations.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.2-accessing-the-condition-codes.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.3-jump-instructions.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.4-jump-instruction-encodings.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.5-conditional-branches-with-conditional-control.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.6-conditional-branches-with-conditional-moves.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.7-loops.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.8-switch-statements.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7-procedures.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.2-control-transfer.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.3-data-transfer.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.4-local-storage-on-the-stack.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.5-local-storage-in-registers.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.6-recursive-procedures.html","cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html","cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.2-pointer-arithmetic.html","cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.3-nested-arrays.html","cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.4-fixed-size-arrays.html","cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.5-variable-size-arrays.html","cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.1-structures.html","cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.2-unions.html","cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.3-data-alignment.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.1-understanding-pointers.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.4-thwarting-buffer-overflow-attacks.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.5-supporting-variable-size-stack-frames.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.1-programmer-visible-state.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.2-y86-64-instructions.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.3-instruction-encoding.html","cs_app/iv.-processor-arch/intro.html","cs_app/cs_app.pdf","cs_app/cs_app.html","indexes/cryptography/cbc-cyber-block-chaining.html"],"attachments":["cs_app/cs_app.pdf","site-lib/scripts/graph-wasm.wasm","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/fonts/c504db5c06caaf7cdfba.woff2","site-lib/fonts/01dcbad1bac635f9c9cd.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/fonts/mathjax_zero.woff","site-lib/fonts/mathjax_main-regular.woff","site-lib/fonts/mathjax_main-bold.woff","site-lib/fonts/mathjax_math-italic.woff","site-lib/fonts/mathjax_main-italic.woff","site-lib/fonts/mathjax_math-bolditalic.woff","site-lib/fonts/mathjax_size1-regular.woff","site-lib/fonts/mathjax_size2-regular.woff","site-lib/fonts/mathjax_size3-regular.woff","site-lib/fonts/mathjax_size4-regular.woff","site-lib/fonts/mathjax_ams-regular.woff","site-lib/fonts/mathjax_calligraphic-regular.woff","site-lib/fonts/mathjax_calligraphic-bold.woff","site-lib/fonts/mathjax_fraktur-regular.woff","site-lib/fonts/mathjax_fraktur-bold.woff","site-lib/fonts/mathjax_sansserif-regular.woff","site-lib/fonts/mathjax_sansserif-bold.woff","site-lib/fonts/mathjax_sansserif-italic.woff","site-lib/fonts/mathjax_script-regular.woff","site-lib/fonts/mathjax_typewriter-regular.woff","site-lib/fonts/mathjax_vector-regular.woff","site-lib/fonts/mathjax_vector-bold.woff","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/scripts/graph-wasm.js","site-lib/scripts/graph-render-worker.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/theme.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css","assets/pasted-image-20250807171802.png","assets/pasted-image-20250724134626.png","assets/pasted-image-20260122194808.png","assets/pasted-image-20260122211607.png","assets/pasted-image-20260122212355.png","assets/pasted-image-20260122172120.png","assets/pasted-image-20260122171049.png","assets/pasted-image-20251020154933.png","assets/pasted-image-20251018225151.png","assets/pasted-image-20250908124256.png","assets/pasted-image-20250908121209.png","assets/pasted-image-20250908121735.png","assets/pasted-image-20250715115553.png","assets/pasted-image-20250917213940.png","assets/pasted-image-20250908115829.png","assets/pasted-image-20250817140128.png","indexes/coding/assembly-x86/call.md","assets/pasted-image-20250904134956.png","assets/pasted-image-20250904135618.png","assets/pasted-image-20250904135903.png","assets/pasted-image-20250904141340.png","assets/pasted-image-20250825133158.png","assets/pasted-image-20250819153309.png","indexes/coding/assembly-x86/jump.md","assets/pasted-image-20250821143128.png","assets/pasted-image-20250821143052.png","indexes/coding/assembly-x86/mov.md","assets/pasted-image-20250818123607.png","assets/pasted-image-20250818124727.png","assets/pasted-image-20250818133441.png","assets/pasted-image-20250818134520.png","assets/pasted-image-20250818135026.png","assets/pasted-image-20250818141612.png","indexes/coding/assembly-x86/set.md","assets/pasted-image-20250821131150.png","assets/pasted-image-20250821131322.png","indexes/coding/assembly-x86/operands-as.md","assets/pasted-image-20250817144946.png","assets/pasted-image-20250817164321.png","indexes/coding/assembly-x86/unary-operations-as.md","assets/pasted-image-20250819172841.png","indexes/coding/assembly-x86/binary-operations-as.md","assets/pasted-image-20250819173309.png","indexes/coding/assembly-x86/shift-operations-as.md","assets/pasted-image-20250820121350.png","indexes/coding/assembly-x86/leaq.md","indexes/coding/assembly-x86/push-&-pop.md","assets/pasted-image-20250819150715.png","assets/pasted-image-20250807193243.png","assets/pasted-image-20250807193302.png","assets/pasted-image-20250807193731.png","assets/pasted-image-20250815131351.png","assets/pasted-image-20250815133752.png","assets/pasted-image-20250715184855.png","assets/pasted-image-20250814135551.png","assets/pasted-image-20250716204848.png","assets/pasted-image-20250717130734.png","assets/pasted-image-20250717141129.png","assets/pasted-image-20250808193539.png","assets/pasted-image-20250808193628.png","assets/pasted-image-20250808194016.png","assets/pasted-image-20250808164737.png","assets/pasted-image-20250806124238.png","assets/pasted-image-20250805221658.png","assets/pasted-image-20250805215808.png","assets/pasted-image-20250805220347.png","assets/pasted-image-20250805133858.png","assets/pasted-image-20250805140636.png","assets/pasted-image-20250805143818.png","assets/pasted-image-20250725183303.png","assets/pasted-image-20250725180054.png","assets/pasted-image-20250725180109.png","assets/pasted-image-20250725174630.png","assets/pasted-image-20250724145251.png","assets/pasted-image-20250722131129.png","assets/pasted-image-20250712193205.png","assets/pasted-image-20250720142153.png","assets/pasted-image-20250722122228.png","assets/pasted-image-20250716183124.png","assets/pasted-image-20250716131144.png","assets/pasted-image-20250715224120.png","assets/pasted-image-20250715174131.png","assets/pasted-image-20250715174158.png","assets/pasted-image-20250715124434.png","assets/pasted-image-20250712180214.png","assets/pasted-image-20250712174037.png","assets/pasted-image-20250712175559.png","site-lib/rss.xml","assets/pasted-image-20260128110417.png","assets/pasted-image-20260128110814.png"],"allFiles":["indexes/cryptography/cbc-cyber-block-chaining.html","assets/pasted-image-20260128110814.png","assets/pasted-image-20260128110417.png","cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.1-unsigned-addition.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.8-logical-operations-in-c.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.3-instruction-encoding.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.2-y86-64-instructions.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.1-programmer-visible-state.html","cs_app/iv.-processor-arch/intro.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.5-supporting-variable-size-stack-frames.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.4-thwarting-buffer-overflow-attacks.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html","cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html","cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.4-fixed-size-arrays.html","cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.3-nested-arrays.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.1-understanding-pointers.html","cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.3-data-alignment.html","cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.2-unions.html","cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.1-structures.html","cs_app/glossary/transistor.html","cs_app/glossary/tib,-teb-&-peb.html","cs_app/glossary/threads.html","cs_app/glossary/virtual-memory.html","cs_app/glossary/processes.html","cs_app/glossary/multi-core-processor.html","cs_app/glossary/isa-instruction-set-architecture.html","cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.5-variable-size-arrays.html","cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.2-pointer-arithmetic.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.6-recursive-procedures.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.5-local-storage-in-registers.html","cs_app/glossary/register.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.4-local-storage-on-the-stack.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.3-data-transfer.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.2-control-transfer.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7-procedures.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.8-switch-statements.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.7-loops.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.6-conditional-branches-with-conditional-moves.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.5-conditional-branches-with-conditional-control.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.4-jump-instruction-encodings.html","cs_app/glossary/program-stack.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.3-jump-instructions.html","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.2-data-movement-instructions.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.2-accessing-the-condition-codes.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.0-arithmetic-and-logical-operations.html","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.2-unary-and-binary-operations.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.3-shift-operations.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.1-load-effective-address.html","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.4-pushing-and-popping-stack-data.html","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.3-data-movement-example.html","cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.2-two's-complement-addition.html","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.0-accessing-information.html","cs_app/iii.-machine-lever-representation-of-programs/3.3-data-formats/3.3.0-data-formats.html","cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.3-notes-on-formatting.html","cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.2-code-examples.html","cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.1-machine-level-code.html","cs_app/i.-computer-systems/1.9-important-themes/1.9.3-the-importance-of-abstractions-in-computer-systems.html","cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.0-program-encodings.html","cs_app/iii.-machine-lever-representation-of-programs/3.1-a-historical-perspective/3.0.0-machine-level-representation-of-programs.html","cs_app/cs_app.pdf","cs_app/cs_app.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.3-addressing-and-byte-ordering.html","cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.7-dividing-by-powers-of-2.html","cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.6-multiplying-by-constants.html","cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.5-two's-complement-multiplication.html","cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.4-unsigned-multiplication.html","cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.3-two's-complement-negation.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.8-advice-on-signed-versus-unsigned.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.7-truncating-numbers.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.6-expanding-the-bit-representation-of-a-number.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.5-signed-versus-unsigned-in-c.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.4-t2u-&-u2t.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.3-two's-complement-encodings.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.2-unsigned-encodings.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.1-integral-data-types.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.0-integer-representations.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html","cs_app/glossary/operating-system.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.6-intro-to-boolean-algebra.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.5-representing-code.html","cs_app/glossary/unicode.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.4-representing-strings.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.2-data-sizes.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.0-information-storage.html","cs_app/i.-computer-systems/1.0-computer-systems.html","cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html","cs_app/glossary/hyperthreading.html","cs_app/glossary/parallelism.html","cs_app/i.-computer-systems/1.9-important-themes/1.9.0-important-themes.html","cs_app/glossary/concurrency.html","cs_app/i.-computer-systems/1.9-important-themes/amdahl's-law.html","cs_app/i.-computer-systems/1.8-systems-comunicate-with-other-systems-using-networks/1.8.0-systems-communicate-with-other-systems-using-networks.html","cs_app/glossary/file.html","cs_app/glossary/kernel.html","cs_app/glossary/shell.html","cs_app/i.-computer-systems/1.7-os-manages-the-hardware/1.7.0-the-os-manages-the-hardware.html","cs_app/i.-computer-systems/1.6-storage-devices-form-a-hierarchy/1.6.1-storage-devices-form-a-hierarchy.html","cs_app/glossary/cache-memories.html","cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html","cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html","cs_app/glossary/cpu.html","cs_app/glossary/adapter.html","cs_app/glossary/i-o-devices.html","cs_app/glossary/alu.html","cs_app/glossary/buses.html","cs_app/glossary/controller.html","cs_app/glossary/main-memory.html","cs_app/glossary/register-file.html","cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.0-processors-read-and-interpret-instructions-stored-in-memory.html","cs_app/i.-computer-systems/1.3-pays-to-understand-how-compilation-systems-work/1.3-it-pays-to-understand-how-compilation-systems-work.html","cs_app/i.-computer-systems/1.2-programs-are-translated-by-other-programs-in-different-forms/1.2-programs-are-translated-by-other-programs-into-different-forms.html","cs_app/i.-computer-systems/1.1-information-is-bits-+-context/1.1-information-is-bits-+-context.html","site-lib/scripts/graph-wasm.wasm","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/fonts/c504db5c06caaf7cdfba.woff2","site-lib/fonts/01dcbad1bac635f9c9cd.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/fonts/mathjax_zero.woff","site-lib/fonts/mathjax_main-regular.woff","site-lib/fonts/mathjax_main-bold.woff","site-lib/fonts/mathjax_math-italic.woff","site-lib/fonts/mathjax_main-italic.woff","site-lib/fonts/mathjax_math-bolditalic.woff","site-lib/fonts/mathjax_size1-regular.woff","site-lib/fonts/mathjax_size2-regular.woff","site-lib/fonts/mathjax_size3-regular.woff","site-lib/fonts/mathjax_size4-regular.woff","site-lib/fonts/mathjax_ams-regular.woff","site-lib/fonts/mathjax_calligraphic-regular.woff","site-lib/fonts/mathjax_calligraphic-bold.woff","site-lib/fonts/mathjax_fraktur-regular.woff","site-lib/fonts/mathjax_fraktur-bold.woff","site-lib/fonts/mathjax_sansserif-regular.woff","site-lib/fonts/mathjax_sansserif-bold.woff","site-lib/fonts/mathjax_sansserif-italic.woff","site-lib/fonts/mathjax_script-regular.woff","site-lib/fonts/mathjax_typewriter-regular.woff","site-lib/fonts/mathjax_vector-regular.woff","site-lib/fonts/mathjax_vector-bold.woff","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/scripts/graph-wasm.js","site-lib/scripts/graph-render-worker.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/theme.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css"],"webpages":{"cs_app/glossary/adapter.html":{"title":"Adapter","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Hardware\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Hardware\">#Hardware</a> An adapter is a card that plugs into a slot on the motherboardThe main purpose is to transfer information back and forth between the I/O bus and an I/O device.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:Hardware"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/adapter.html","pathToRoot":"../..","attachments":[],"createdTime":1762229051907,"modifiedTime":1751838737126,"sourceSize":175,"sourcePath":"CS_APP/Glossary/Adapter.md","exportPath":"cs_app/glossary/adapter.html","showInTree":true,"treeOrder":2,"backlinks":["cs_app/glossary/i-o-devices.html","cs_app/i.-computer-systems/1.8-systems-comunicate-with-other-systems-using-networks/1.8.0-systems-communicate-with-other-systems-using-networks.html"],"type":"markdown"},"cs_app/glossary/alu.html":{"title":"ALU","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Hardware\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Hardware\">#Hardware</a> The ALU computes new data and address values","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:Hardware"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/alu.html","pathToRoot":"../..","attachments":[],"createdTime":1762229049262,"modifiedTime":1751838737094,"sourceSize":58,"sourcePath":"CS_APP/Glossary/ALU.md","exportPath":"cs_app/glossary/alu.html","showInTree":true,"treeOrder":3,"backlinks":["cs_app/glossary/cpu.html","cs_app/glossary/hyperthreading.html"],"type":"markdown"},"cs_app/glossary/buses.html":{"title":"Buses","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Hardware\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Hardware\">#Hardware</a>Running throughout the system is a collection of electrical conduits called buses that carry bytes of information back and forth between the components. Buses are typically designed to transfer fixed-size chunks of bytes known as words.The number of bytes in a word ( the word size) is a fundamental system parameter that varies across systems. Most machines today have word sizes of either 4 bytes(32 bits) or 8 bytes(64 bits). ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:Hardware"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/buses.html","pathToRoot":"../..","attachments":[],"createdTime":1762229052064,"modifiedTime":1751838737054,"sourceSize":450,"sourcePath":"CS_APP/Glossary/Buses.md","exportPath":"cs_app/glossary/buses.html","showInTree":true,"treeOrder":4,"backlinks":["cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html"],"type":"markdown"},"cs_app/glossary/cache-memories.html":{"title":"cache memories","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Hardware\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Hardware\">#Hardware</a> <br>Caches serve as temporary staging areas for information that the <a data-tooltip-position=\"top\" aria-label=\"CPU\" data-href=\"CPU\" href=\"canekzamudio.com/cs_app/glossary/cpu.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">processor</a> is likely to need in the near future.<br>\n<img alt=\"Pasted image 20250712174037.png\" src=\"canekzamudio.com/assets/pasted-image-20250712174037.png\" target=\"_self\">\nThe idea behind caching is that a system can get the effect of both a very large memory and a very fast one by exploiting locality, the tendency for programs to access data and code in localized regions.By setting up caches to hold data that they are likely to be accessed often, we can perform most memory operations using the fast caches.<br>An L1 cache on the processor chip holds tens of thousands of bytes and can be accessed nearly as fast as the <a data-href=\"register file\" href=\"canekzamudio.com/cs_app/glossary/register-file.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register file</a>.<br>A larger L2 cache with hundreds of thousands to millions of bytes is connected to the processor by a special bus. It might take 5 times longer for the processor to access the L2 cache than the L1 cache, but this is still 5 to 10 times faster than accessing the <a data-href=\"Main Memory\" href=\"canekzamudio.com/cs_app/glossary/main-memory.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Main Memory</a>.The L1 and L2 caches are implemented with a hardware technology known as static random access memory (SRAM). Newer and more powerful systems even have three levels of cache: L1, L2 and L3. Memory Hierarchy\nApplications programmers who are aware of the cache memories can exploit them to improve the performance of their programs by an order of magnitude<br>\n<img alt=\"Pasted image 20250712175559.png\" src=\"canekzamudio.com/assets/pasted-image-20250712175559.png\" target=\"_self\" style=\"width: 600px; max-width: 100%;\">\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"L1 cache","level":1,"id":"L1_cache_0"},{"heading":"L2 cache","level":1,"id":"L2_cache_0"}],"links":["?query=tag:Hardware","cs_app/glossary/cpu.html","cs_app/glossary/register-file.html","cs_app/glossary/main-memory.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/glossary/cache-memories.html","pathToRoot":"../..","attachments":["assets/pasted-image-20250712174037.png","assets/pasted-image-20250712175559.png"],"createdTime":1762229048949,"modifiedTime":1752364596404,"sourceSize":1375,"sourcePath":"CS_APP/Glossary/cache memories.md","exportPath":"cs_app/glossary/cache-memories.html","showInTree":true,"treeOrder":5,"backlinks":["cs_app/glossary/multi-core-processor.html","cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html"],"type":"markdown"},"cs_app/glossary/concurrency.html":{"title":"concurrency","icon":"","description":"We use the term concurrency to refer to the general concept of a system with multiple, simultaneous activities","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/concurrency.html","pathToRoot":"../..","attachments":[],"createdTime":1762229049673,"modifiedTime":1752615676565,"sourceSize":112,"sourcePath":"CS_APP/Glossary/concurrency.md","exportPath":"cs_app/glossary/concurrency.html","showInTree":true,"treeOrder":6,"backlinks":["cs_app/glossary/parallelism.html","cs_app/i.-computer-systems/1.9-important-themes/1.9.0-important-themes.html","cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html"],"type":"markdown"},"cs_app/glossary/controller.html":{"title":"Controller","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Hardware\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Hardware\">#Hardware</a> Controllers are chip sets in the device itself or on the system's main printed circuit board (motherboard).The main purpose is to transfer information back and forth between the I/O bus and an I/O device.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:Hardware"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/controller.html","pathToRoot":"../..","attachments":[],"createdTime":1762229051922,"modifiedTime":1751838737054,"sourceSize":220,"sourcePath":"CS_APP/Glossary/Controller.md","exportPath":"cs_app/glossary/controller.html","showInTree":true,"treeOrder":7,"backlinks":["cs_app/glossary/i-o-devices.html"],"type":"markdown"},"cs_app/glossary/cpu.html":{"title":"CPU","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Hardware\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Hardware\">#Hardware</a> *The central processing unit (CPU), or simply processor, is the engine that interprets (or executes) instructions stored in main memory. At its core is a word-size storage device (or register) called the program counter (PC). At any point in time, the PC points at (contains the address of) some machine-language instruction in main memory.From the time that power is applied to the system until the time that the power is shut off, a processor repeatedly executes the instruction pointed at by the program counter and updates the program counter to point to the next instruction. A processor appears to operate according to a very simple instruction execution model, defined by its instruction set architecture.\nIn this model, instructions execute in strict sequence, and executing a single instruction involves performing a series of steps. The processor reads the instruction from memory pointed at by the program counter (PC), interprets the bits in the instruction, performs some simple operation dictated by the instruction, which may or may not be contiguous in memory to the instruction that was just executed.<br>\nThere are only a few of these simple operations, and they revolve around <a data-href=\"Main Memory\" href=\"canekzamudio.com/cs_app/glossary/main-memory.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Main Memory</a>, the <a data-href=\"register file\" href=\"canekzamudio.com/cs_app/glossary/register-file.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register file</a>, and the arithmetic/logic unit (<a data-href=\"ALU\" href=\"canekzamudio.com/cs_app/glossary/alu.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">ALU</a>).Simple operations that the CPU might carry out at the request of an instruction:\nLoad: Copy a byte or a word from main memory into a register, overwriting the previous contents of the register.\nStore: Copy a byte or a word from a register to a location in main memory, overwriting the previous contents of that location.\n<br>Operate: Copy the contents of two registers to the <a data-href=\"ALU\" href=\"canekzamudio.com/cs_app/glossary/alu.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">ALU</a>, perform an arithmetic operation on the two words, and store the result in a register, overwriting the previous contents of that register.\nJump: Extract a word from the instruction itself and copy that word into the program counter (PC), overwriting the previous value of the PC\nA processor appears to be a simple implementation of its instruction set architecture, but in fact modern processors use far more complex mechanisms to speed up program execution.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:Hardware","cs_app/glossary/main-memory.html","cs_app/glossary/register-file.html","cs_app/glossary/alu.html","cs_app/glossary/alu.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/cpu.html","pathToRoot":"../..","attachments":[],"createdTime":1762229050732,"modifiedTime":1752361588877,"sourceSize":2158,"sourcePath":"CS_APP/Glossary/CPU.md","exportPath":"cs_app/glossary/cpu.html","showInTree":true,"treeOrder":8,"backlinks":["cs_app/glossary/cache-memories.html","cs_app/glossary/multi-core-processor.html","cs_app/glossary/processes.html","cs_app/glossary/register.html","cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html","cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.5-representing-code.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html","cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.3-data-alignment.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.3-instruction-encoding.html","cs_app/iv.-processor-arch/intro.html"],"type":"markdown"},"cs_app/glossary/file.html":{"title":"file","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Software\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Software\">#Software</a> A file is a sequence of bytes, nothing more and nothing less. Every I/O device, including disks, keyboards, displays, and even networks, is modeled as a file. All input and output in the system is performed by reading and writing files, using a small set of system calls known as Unix I/O.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:Software"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/file.html","pathToRoot":"../..","attachments":[],"createdTime":1762228985144,"modifiedTime":1752604184596,"sourceSize":303,"sourcePath":"CS_APP/Glossary/file.md","exportPath":"cs_app/glossary/file.html","showInTree":true,"treeOrder":9,"backlinks":["cs_app/glossary/operating-system.html","cs_app/glossary/processes.html"],"type":"markdown"},"cs_app/glossary/hyperthreading.html":{"title":"hyperthreading","icon":"","description":"*Hyperthreading, sometimes called \"simultaneous multi-threading\", is a technique that allows a single CPU to execute multiple flows of control. It involves having multiple copies of some of the CPU hardware, such as program counters and <a data-href=\"register file\" href=\"canekzamudio.com/cs_app/glossary/register-file.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register file</a>s, while having only single copies of other parts of the hardware, such as the units that perform floating-point arithmetic (<a data-href=\"ALU\" href=\"canekzamudio.com/cs_app/glossary/alu.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">ALU</a>)*.Whereas a conventional processor requires around 20,000 clock cycles to shift between different threads, a hyperthreaded processor decides which of its threads to execute on a cycle-bycycle basis. It enables the CPU to take better advantage of its processing resources. For example, if one thread must wait for some data to be loaded into a cache, the CPU can proceed with the execution of a different thread. As an example, the Intel Core i7 processor can have each core executing two threads, and so a four-core system can actually execute eight threads in parallel.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/glossary/register-file.html","cs_app/glossary/alu.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/hyperthreading.html","pathToRoot":"../..","attachments":[],"createdTime":1762229051411,"modifiedTime":1752624269358,"sourceSize":963,"sourcePath":"CS_APP/Glossary/hyperthreading.md","exportPath":"cs_app/glossary/hyperthreading.html","showInTree":true,"treeOrder":10,"backlinks":["cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html"],"type":"markdown"},"cs_app/glossary/i-o-devices.html":{"title":"I-O Devices","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Hardware\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Hardware\">#Hardware</a> *Input/output (I/O) devices are the system's connection to the external world. i.e., a keyboard and a mouse for user input, a display for user output, and a disk drive (or simply disk) for long-term storage of data and programs.Each I/O device is connected to the I/O bus by either a controller or an adapter. The distinction between these two is mainly one of packaging.Controller<br><a href=\"canekzamudio.com?query=tag:Hardware\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Hardware\">#Hardware</a> Controllers are chip sets in the device itself or on the system's main printed circuit board (motherboard).The main purpose is to transfer information back and forth between the I/O bus and an I/O device.Adapter<br><a href=\"canekzamudio.com?query=tag:Hardware\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Hardware\">#Hardware</a> An adapter is a card that plugs into a slot on the motherboardThe main purpose is to transfer information back and forth between the I/O bus and an I/O device.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:Hardware","?query=tag:Hardware","?query=tag:Hardware"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/i-o-devices.html","pathToRoot":"../..","attachments":["cs_app/glossary/controller.html","cs_app/glossary/adapter.html"],"createdTime":1762229050321,"modifiedTime":1751838737106,"sourceSize":435,"sourcePath":"CS_APP/Glossary/I-O Devices.md","exportPath":"cs_app/glossary/i-o-devices.html","showInTree":true,"treeOrder":11,"backlinks":["cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html","cs_app/i.-computer-systems/1.8-systems-comunicate-with-other-systems-using-networks/1.8.0-systems-communicate-with-other-systems-using-networks.html"],"type":"markdown"},"cs_app/glossary/isa-instruction-set-architecture.html":{"title":"ISA - Instruction Set Architecture","icon":"","description":"The ISA defines the format and behaviour of a machine-level program.Defines:\nProcessor state\nFormat of the instructions\nThe effect each of these instructions will have on the state\nMost ISAs, like x86 one, describe the behavior of a program as if each instruction is executed in sequence, with one instruction completing before the next one begins.\nThe processor hardware is far more elaborate, executing many instructions concurrently, but it employs safeguards to ensure that the overall behavior matches the sequential operation dictated by the ISA. Two big groups of architectures define main <a data-href=\"assembly\" href=\"canekzamudio.com/assembly.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">assembly</a> languages :CISC assembly languages, such as Intel IA-32 and x64, have more complex instructions. They generally focus on completing tasks using as few lines of assembly instructions as possible.\nTo do so, some instructions can perform multiple operations, such as mul in Intel assembly,\nwhich performs data access, multiplication, and data store operations in one go.In the RISC assembly language, assembly instructions are simple and generally perform only one operation each. This may lead to more lines of code to complete a specific task, but it may also be more efficient, as this omits the execution of any unnecessary operations.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Complex Instruction Set Computer (CISC)","level":2,"id":"Complex_Instruction_Set_Computer_(CISC)_0"},{"heading":"Reduced Instruction Set Computer (RISC)","level":2,"id":"Reduced_Instruction_Set_Computer_(RISC)_0"}],"links":["assembly.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/isa-instruction-set-architecture.html","pathToRoot":"../..","attachments":[],"createdTime":1762229050574,"modifiedTime":1757563062724,"sourceSize":1355,"sourcePath":"CS_APP/Glossary/ISA - Instruction Set Architecture.md","exportPath":"cs_app/glossary/isa-instruction-set-architecture.html","showInTree":true,"treeOrder":12,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.1-machine-level-code.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html"],"type":"markdown"},"cs_app/glossary/kernel.html":{"title":"kernel","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Software\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Software\">#Software</a> <br>The kernel is the portion of the <a data-href=\"Operating System\" href=\"canekzamudio.com/cs_app/glossary/operating-system.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Operating System</a> code that is always resident in memory, it is a collection of code and data structures that the system uses to manage all the <a data-href=\"processes\" href=\"canekzamudio.com/cs_app/glossary/processes.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">processes</a>.When an application program requires some action by the operating system, such as to read or write a file, it executes a special system call instruction, transferring control to the kernel. The kernel then performs the requested operation and returns back to the application program","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:Software","cs_app/glossary/operating-system.html","cs_app/glossary/processes.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/kernel.html","pathToRoot":"../..","attachments":[],"createdTime":1762229049797,"modifiedTime":1752373142933,"sourceSize":494,"sourcePath":"CS_APP/Glossary/kernel.md","exportPath":"cs_app/glossary/kernel.html","showInTree":true,"treeOrder":13,"backlinks":["cs_app/glossary/processes.html","cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html"],"type":"markdown"},"cs_app/glossary/main-memory.html":{"title":"Main Memory","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Hardware\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Hardware\">#Hardware</a> The main memory is a temporary storage device that holds both a program and the data it manipulates while the processor is executing the program.Physically, main memory consists of a collection of dynamic random access memory(DRAM)\nchips. Logically, memory is organized as a linear array of bytes, each with its own unique address (array index) starting at 0. In general, each of the machine instructions that constitute a program can consist of a variable number of bytes.The size of data items that correspond to C program variables vary according to type. For example, on an x86-64 machine running linux, data of type short require 2 bytes, types int and float 4 bytes, and types long and double 8 bytes","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:Hardware"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/main-memory.html","pathToRoot":"../..","attachments":[],"createdTime":1762229050864,"modifiedTime":1751838737046,"sourceSize":731,"sourcePath":"CS_APP/Glossary/Main Memory.md","exportPath":"cs_app/glossary/main-memory.html","showInTree":true,"treeOrder":14,"backlinks":["cs_app/glossary/cpu.html","cs_app/glossary/cache-memories.html","cs_app/glossary/multi-core-processor.html","cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html","cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html","cs_app/i.-computer-systems/1.8-systems-comunicate-with-other-systems-using-networks/1.8.0-systems-communicate-with-other-systems-using-networks.html","cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.3-data-alignment.html"],"type":"markdown"},"cs_app/glossary/multi-core-processor.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762229050766,"modifiedTime":1758163434417,"sourceSize":566,"sourcePath":"CS_APP/Glossary/multi-core processor.md","exportPath":"cs_app/glossary/multi-core-processor.html","showInTree":true,"treeOrder":15,"backlinks":[],"type":"markdown"},"cs_app/glossary/operating-system.html":{"title":"Operating System","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Software\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Software\">#Software</a>We can think of the operating system as a layer of software interposed between the application and the hardware. Any attempt by an application program to manipulate the hardware must go through the operating system.The OS has two many purposes:\nTo protect the hardware from misuse by runaway application\nTo provide applications with simple and uniform mechanisms for manipulating complicated and often wildly different low-level hardware devices\nThe OS achieves this both via the fundamental abstraction shown in pictures<br>\n<img alt=\"Pasted image 20250712193205.png\" src=\"canekzamudio.com/assets/pasted-image-20250712193205.png\" target=\"_self\">\nfile<br><a href=\"canekzamudio.com?query=tag:Software\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Software\">#Software</a> A file is a sequence of bytes, nothing more and nothing less. Every I/O device, including disks, keyboards, displays, and even networks, is modeled as a file. All input and output in the system is performed by reading and writing files, using a small set of system calls known as Unix I/O. are abstractions for I/O devices is an abstraction for both the main memory and disk I/O devices are abstractions for the processor, main memory and I/O devices<br>Threads\nAlthough we normally think of a process as having single control flow, in modern systems a process can actually consist of multiple execution units, called <a data-href=\"threads\" href=\"canekzamudio.com/cs_app/glossary/threads.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">threads</a>...\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:Software","?query=tag:Software","cs_app/glossary/threads.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/glossary/operating-system.html","pathToRoot":"../..","attachments":["assets/pasted-image-20250712193205.png","cs_app/glossary/file.html","cs_app/glossary/virtual-memory.html","cs_app/glossary/processes.html"],"createdTime":1762229051331,"modifiedTime":1753315216661,"sourceSize":998,"sourcePath":"CS_APP/Glossary/Operating System.md","exportPath":"cs_app/glossary/operating-system.html","showInTree":true,"treeOrder":16,"backlinks":["cs_app/glossary/kernel.html","cs_app/glossary/virtual-memory.html","cs_app/i.-computer-systems/1.7-os-manages-the-hardware/1.7.0-the-os-manages-the-hardware.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.0-information-storage.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.5-representing-code.html","cs_app/iii.-machine-lever-representation-of-programs/3.1-a-historical-perspective/3.0.0-machine-level-representation-of-programs.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html","cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.1-machine-level-code.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.1-programmer-visible-state.html"],"type":"markdown"},"cs_app/glossary/parallelism.html":{"title":"Parallelism","icon":"","description":"We use the term paralelism to refer to the use of <a data-href=\"concurrency\" href=\"canekzamudio.com/cs_app/glossary/concurrency.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">concurrency</a> to make a system run faster","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/glossary/concurrency.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/parallelism.html","pathToRoot":"../..","attachments":[],"createdTime":1762229050172,"modifiedTime":1752622724150,"sourceSize":100,"sourcePath":"CS_APP/Glossary/Parallelism.md","exportPath":"cs_app/glossary/parallelism.html","showInTree":true,"treeOrder":17,"backlinks":["cs_app/i.-computer-systems/1.9-important-themes/1.9.0-important-themes.html","cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html"],"type":"markdown"},"cs_app/glossary/processes.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228984073,"modifiedTime":1758164317809,"sourceSize":2828,"sourcePath":"CS_APP/Glossary/processes.md","exportPath":"cs_app/glossary/processes.html","showInTree":true,"treeOrder":18,"backlinks":[],"type":"markdown"},"cs_app/glossary/program-stack.html":{"title":"program stack","icon":"","description":"A stack is a data structure where values can be added or deleted, but only according to a \"last-in, first-out\" discipline.We add data to a stack via a <a data-tooltip-position=\"top\" aria-label=\"push &amp; pop\" data-href=\"push &amp; pop\" href=\"canekzamudio.com/indexes/coding/assembly-x86/push-&amp;-pop.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">push</a> operation and remove it via a <a data-tooltip-position=\"top\" aria-label=\"push &amp; pop\" data-href=\"push &amp; pop\" href=\"canekzamudio.com/indexes/coding/assembly-x86/push-&amp;-pop.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">pop</a> operation, with the property that the value popped will always be the value that was most recently pushed and is still on the stack.A stack can be implemented as an array, where we always insert and remove elements from one end of the array. This end is called the top of the stack. With x86, the program stack is stored in some region of memory.<br>\n<img alt=\"Pasted image 20250819153309.png\" src=\"canekzamudio.com/assets/pasted-image-20250819153309.png\" target=\"_self\" style=\"width: 550px; max-width: 100%;\">\nThe stack grows downward such that the top element of the stack has the lowest address of all stack elements. The stack pointer %rsp holds the address of the top stack element.<br>The pushq instruction provides the ability to push data onto the stack, while the popq instruction pops it. Each of these instructions takes a single <a data-tooltip-position=\"top\" aria-label=\"3.4.1 Operand Specifiers\" data-href=\"3.4.1 Operand Specifiers\" href=\"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">operand</a>, the data source for pushing and the data destination por popping.Pushing a quad word value onto the stack involves first decrementing the stack pointer by 8 and then writing the value at the new top-of-stack address. Therefore, the behavior of the instruction pushq %rbp is equivalent to this of the pair of instructions:subq $8, %rsp //Decrement stack pointer\nmovq %rbp, (%rsp) //Store %rbp on stack\nexcept that the pushq instruction is encoded in the machine code as a single byte, whereas the pair of instructions shown above requires a total of 8 bytes. The first two columns in Figure 3.9 illustrate the effect of executing the instruction pushq %rax when %rsp is 0x108 and %rax is 0x123. First %rsp is decremented by 8, giving 0x100, and then 0x123 is stored at memory address 0x100. Popping a quad word involves reading from the top-of-stack location and then incrementing the stack pointer by 8. Therefore, the instruction popq %rax is equivalent to the following pair of instructions:movq (%rsp), %rax //Read %rax from stack\naddq $8, %rsp //Increment stack pointer\nThe third column of Figure 3.9 illustrates the effect of executing the instruction popq %edx immediately after executing the pushq. Value 0x123 is read from memory and written to register %rdx. Register %rsp is incremented back to 0x108. As shown in the figure, the value 0x123 remains at memory location 0x104 until it is overwritten (e.g., by another push operation). However, the stack top is always considered to be the address indicated by %rsp. <br>Since the stack is contained in the same memory as the program code and other forms of program data, programs can access arbitrary positions within the stack using the standard memory addressing methods. For example, assuming the topmost element of the stack is a quad word, the instruction movq 8(%rsp),%rdx will copy the second quad word from the stack to <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a> %rdx.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["indexes/coding/assembly-x86/push-&-pop.html","indexes/coding/assembly-x86/push-&-pop.html","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html","cs_app/glossary/register.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/glossary/program-stack.html","pathToRoot":"../..","attachments":["assets/pasted-image-20250819153309.png"],"createdTime":1762229052442,"modifiedTime":1755815298270,"sourceSize":3023,"sourcePath":"CS_APP/Glossary/program stack.md","exportPath":"cs_app/glossary/program-stack.html","showInTree":true,"treeOrder":19,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.6-recursive-procedures.html"],"type":"markdown"},"cs_app/glossary/register.html":{"title":"register","icon":"","description":"An x86 <a data-href=\"CPU\" href=\"canekzamudio.com/cs_app/glossary/cpu.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">CPU</a> contains a set of 16 general-purpose registers storing 64-bit values. These registers are used to store integer data as well as <a data-href=\"Pointers\" href=\"canekzamudio.com/indexes/coding/c/pointers.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Pointers</a>. Their names all begin with %r, but otherwise follow multiple different naming conventions, owing to the historical evolution of the instruction set.<br>\n<img alt=\"Pasted image 20250817140128.png\" src=\"canekzamudio.com/assets/pasted-image-20250817140128.png\" target=\"_self\" style=\"width: 500px; max-width: 100%;\">\nFigure 3.2 Integer registers. The low-order portions of all 16 registers can be accessed as byte, word (16-bit), double word (32-bit), and quad word (64-bit) quantities.As the nested boxes above indicate, instructions can operate on data of different sizes stored in the low-order bytes of the 16 registers. Byte-level operations can access the least significant byte, 16-bit operations can access the least significant 2 bytes, 32-bit operations can access the least significant 4 bytes, and 64-bit operations can access entire registers.There are also a number of instructions for copying and generating 1, 2, 4, and 8-byte values. When these instructions have registers as destinations, two conventions arise for what happens to the remaining bytes in the register for instructions that generate less than 8 bytes: Those that generate 1 or 2-byte quantities leave the remaining bytes unchanged. Those that generate 4-byte quantities set the upper 4 bytes of the register to zero.x86 adopts a uniform set of conventions for register usage that must be respected by all procedures. By convention, registers %rbx, %rbp, and %r12 - %r15 are classified as callee-saved registers. When procedure P calls procedure Q, Q must preserve the values of these registers, ensuring that they have the same values when Q returns to P as they did when Q was called.\nProcedure Q can preserve a register value by either not changing it at all or by pushing<br>\nthe original value on the stack, altering it, and then popping the old value from the stack before returning. The pushing of register values has the effect of creating the portion of the stack frame labeled <a data-tooltip-position=\"top\" aria-label=\"Pasted image 20250904115435.png\" data-href=\"Pasted image 20250904115435.png\" href=\"canekzamudio.com/assets/pasted-image-20250904115435.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Saved registers</a> in Figure 3.25. With this convention, the code for P can safely store a value in a callee-saved register (after saving the previous value on the stack, of course), call Q, and then use the value in the register without risk of it having been corrupted. <br>All other registers, except for the <a data-tooltip-position=\"top\" aria-label=\"3.7.1 The Run-Time Stack\" data-href=\"3.7.1 The Run-Time Stack\" href=\"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">stack</a> pointer %rsp, are classified as caller-saved registers. This means that they can be modified by any function. The name caller saved can be understood in the context of a procedure P having some local data in such a register and calling procedure Q. Since Q is free to alter this register, it is incumbent upon P (the caller) to first save the data before it makes the call. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Callee-saved registers","level":7,"id":"Callee-saved_registers_0"},{"heading":"Caller-saved registers","level":8,"id":"Caller-saved_registers_0"}],"links":["cs_app/glossary/cpu.html","indexes/coding/c/pointers.html","assets/pasted-image-20250904115435.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/glossary/register.html","pathToRoot":"../..","attachments":["assets/pasted-image-20250817140128.png"],"createdTime":1762229050215,"modifiedTime":1757189827265,"sourceSize":1411,"sourcePath":"CS_APP/Glossary/register.md","exportPath":"cs_app/glossary/register.html","showInTree":true,"treeOrder":20,"backlinks":["cs_app/glossary/tib,-teb-&-peb.html","cs_app/glossary/program-stack.html","cs_app/glossary/threads.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.4-thwarting-buffer-overflow-attacks.html","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.0-accessing-information.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.6-conditional-branches-with-conditional-moves.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.7-loops.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7-procedures.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.3-data-transfer.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.4-local-storage-on-the-stack.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.5-local-storage-in-registers.html","cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.4-fixed-size-arrays.html","cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.1-structures.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.1-programmer-visible-state.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.3-instruction-encoding.html"],"type":"markdown"},"cs_app/glossary/register-file.html":{"title":"register file","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Hardware\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Hardware\">#Hardware</a> The register file is a small storage device that consists of a collection of word-size registers, each with its own unique name.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:Hardware"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/register-file.html","pathToRoot":"../..","attachments":[],"createdTime":1762229049788,"modifiedTime":1751838736470,"sourceSize":143,"sourcePath":"CS_APP/Glossary/register file.md","exportPath":"cs_app/glossary/register-file.html","showInTree":true,"treeOrder":21,"backlinks":["cs_app/glossary/cpu.html","cs_app/glossary/cache-memories.html","cs_app/glossary/hyperthreading.html","cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html"],"type":"markdown"},"cs_app/glossary/shell.html":{"title":"Shell","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Software\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Software\">#Software</a>The shell is a command-line interpreter that prints a prompt, waits for you to type a command line, and then performs the commandIf the first word of the command line does not correspond to a built-in shell command, then the shell assumes that it is the name of an executable file that it should load and run. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:Software"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/shell.html","pathToRoot":"../..","attachments":[],"createdTime":1762229051314,"modifiedTime":1752366890546,"sourceSize":325,"sourcePath":"CS_APP/Glossary/Shell.md","exportPath":"cs_app/glossary/shell.html","showInTree":true,"treeOrder":22,"backlinks":["cs_app/glossary/processes.html","cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.0-processors-read-and-interpret-instructions-stored-in-memory.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html"],"type":"markdown"},"cs_app/glossary/threads.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762229049147,"modifiedTime":1758168321019,"sourceSize":1309,"sourcePath":"CS_APP/Glossary/threads.md","exportPath":"cs_app/glossary/threads.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/glossary/tib,-teb-&-peb.html":{"title":"TIB, TEB & PEB","icon":"","description":"These structures are stored inside the process memory, and their main function is to include all the information about the process and each thread, as well as make them accessible to the code so that it can easily know the process filename, the loaded <a data-href=\"DLL\" href=\"canekzamudio.com/indexes/malware/dll.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">DLL</a>s, and other related information.<br>They can all be accessed through a special segment <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a>, either FS (32-bit) or GS ( 64-bit), like this:mov eax, DWORD PTR FS:[XX]\n<br>This contains the context of the <a data-tooltip-position=\"top\" aria-label=\"threads\" data-href=\"threads\" href=\"canekzamudio.com/cs_app/glossary/threads.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">thread</a>.This structure starts with the TIB, which is then followed by additional thread-related fields. In many cases, the terms TIB and TEB are used interchangeably. <br>This includes various information about the process, such as its name, ID (PID), and a list of modules (which includes all the <a data-tooltip-position=\"top\" aria-label=\"PE Header\" data-href=\"PE Header\" href=\"canekzamudio.com/indexes/malware/windows/pe-structure/pe-header.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PE</a> files that have been loaded in memory  mainly the program itself and the <a data-href=\"DLL\" href=\"canekzamudio.com/indexes/malware/dll.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">DLL</a>s).","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"TIB, TEB &amp; PEB","level":1,"id":"TIB,_TEB_&_PEB_0"},{"heading":"<em>Thread Information Block (TIB)</em>","level":2,"id":"*Thread_Information_Block_(TIB)*_0"},{"heading":"<em>Thread Environment Block (TEB)</em>","level":2,"id":"*Thread_Environment_Block_(TEB)*_0"},{"heading":"<em>Process Environment Block (PEB)</em>","level":2,"id":"*Process_Environment_Block_(PEB)*_0"}],"links":["indexes/malware/dll.html","cs_app/glossary/register.html","cs_app/glossary/threads.html","indexes/malware/windows/pe-structure/pe-header.html","indexes/malware/dll.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/tib,-teb-&-peb.html","pathToRoot":"../..","attachments":[],"createdTime":1762229052544,"modifiedTime":1758255453732,"sourceSize":1016,"sourcePath":"CS_APP/Glossary/TIB, TEB & PEB.md","exportPath":"cs_app/glossary/tib,-teb-&-peb.html","showInTree":true,"treeOrder":24,"backlinks":[],"type":"markdown"},"cs_app/glossary/transistor.html":{"title":"Transistor","icon":"","description":"Transistors are microscopic crystals of silicon that use electrical properties of silicon to act as switches. Modern computers have what are referred to as field-effect transistors","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/transistor.html","pathToRoot":"../..","attachments":[],"createdTime":1762229049551,"modifiedTime":1760135980409,"sourceSize":180,"sourcePath":"CS_APP/Glossary/Transistor.md","exportPath":"cs_app/glossary/transistor.html","showInTree":true,"treeOrder":25,"backlinks":[],"type":"markdown"},"cs_app/glossary/unicode.html":{"title":"Unicode","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Software\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Software\">#Software</a> The current Unicode Standart (version 7.0) has a repertoire of over 100,000 characters supporting a wide range of languages.The base encoding, known as the \"Universal Character Set\" of Unicode, uses a 32-bit representation of characters. This would seem to require every string of text to consist of 4 bytes per character. However, alternative codings are possible where common characters require just 1 or 2 bytes, while less common ones require moreThe UTF-8 representation encodes each character as a sequence of bytes, such that the standart ASCII byte sequences have the same meaning in UTF-8 as they do in ASCII.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:Software"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/glossary/unicode.html","pathToRoot":"../..","attachments":[],"createdTime":1762229051875,"modifiedTime":1753042109232,"sourceSize":658,"sourcePath":"CS_APP/Glossary/Unicode.md","exportPath":"cs_app/glossary/unicode.html","showInTree":true,"treeOrder":26,"backlinks":[],"type":"markdown"},"cs_app/glossary/virtual-memory.html":{"title":"virtual memory","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Software\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Software\">#Software</a> Virtual memory is an abstraction that provides each process with the illusion that it has exclusive use of the main memory. Each process has the same uniform view of memory, which is known as its virtual address space.<br><img alt=\"Pasted image 20250715115553.png\" src=\"canekzamudio.com/assets/pasted-image-20250715115553.png\" target=\"_self\"><br>\nIn Linux, the topmost region of the address space is reserved for code and data in the <a data-tooltip-position=\"top\" aria-label=\"Operating System\" data-href=\"Operating System\" href=\"canekzamudio.com/cs_app/glossary/operating-system.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">OS</a> that is common to all <a data-href=\"processes\" href=\"canekzamudio.com/cs_app/glossary/processes.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">processes</a>. The lower region of the address space holds the code and data defined by the user's process. Note that addresses in the figure increase from the bottom to the top. Code begins at the same fixed address for all processes, followed by data locations that correspond to global C variables. The code and data areas are initialized directly from the contents of an executable object file (in this case the hello executable) The code and data areas are followed immediately by the run-time heap. Unlike the code and data areas, which are fixed in size once the process begins running, the heap expands and contracts dynamically at run time as a result of calls to C standard library routines such as malloc and free. Near the middle of the address space is an area that holds the code and data for shared libraries such as the C standard library and the math library. The notion of a shared library is a powerful but somewhat difficult concept. At the top of the user's virtual address space is the user stack that the compiler uses to implement function calls. Like the heap, the user stack expands and contracts dynamically during the execution of the program. In particular, each time we call a function, the stack grows. Each time we return from a function, it contracts. The top region of the address space is reversed for the kernel. Application programs are not allowed to read or write the contents of this area or to directly call functions defined in the kernel code. Instead, they must invoke the kernel to perform these operations.\nFor virtual memory to work, a hardware translation of every address generated by the processor is required. The basic idea is to store the contents of a process's virtual memory on disk and then use the main memory as a cache for the disk.This virtual memory has a mapper to the equivalent physical memory. Not all virtual memory addresses are mapped to physical memory, and each one thats been mapped has a permission (READ|WRITE, READ|EXECUTE, or maybe READ|WRITE|EXECUTE), as shown in the following diagram:<br>\n<img alt=\"Pasted image 20250917213940.png\" src=\"canekzamudio.com/assets/pasted-image-20250917213940.png\" target=\"_self\" style=\"width: 570px; max-width: 100%;\">\nVirtual memory allows you to create a security layer between one process and another and allows the operating system to manage different processes and suspend one process to give resources to another.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Virtual Address Space","level":1,"id":"Virtual_Address_Space_0"},{"heading":"Program code and data","level":2,"id":"Program_code_and_data_0"},{"heading":"Heap","level":2,"id":"Heap_0"},{"heading":"Shared libraries","level":2,"id":"Shared_libraries_0"},{"heading":"Stack","level":2,"id":"Stack_0"},{"heading":"Kernel virtual memory","level":2,"id":"Kernel_virtual_memory_0"},{"heading":"Mapping virtual memory to physical one","level":1,"id":"Mapping_virtual_memory_to_physical_one_0"}],"links":["?query=tag:Software","cs_app/glossary/operating-system.html","cs_app/glossary/processes.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/glossary/virtual-memory.html","pathToRoot":"../..","attachments":["assets/pasted-image-20250715115553.png","assets/pasted-image-20250917213940.png"],"createdTime":1762229051315,"modifiedTime":1758166802612,"sourceSize":2905,"sourcePath":"CS_APP/Glossary/virtual memory.md","exportPath":"cs_app/glossary/virtual-memory.html","showInTree":true,"treeOrder":27,"backlinks":["cs_app/glossary/operating-system.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.0-information-storage.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.2-data-sizes.html","cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.1-machine-level-code.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.1-programmer-visible-state.html"],"type":"markdown"},"cs_app/i.-computer-systems/1.1-information-is-bits-+-context/1.1-information-is-bits-+-context.html":{"title":"1.1 Information is Bits + Context","icon":"","description":"hello program begins life as a source program (or source file) that the programmer creates with an editor and saves in a text file called hello.c. The program is a sequence of bits, each with a value of 0 or 1, organized in 8-bit chunks called <a data-href=\"bytes\" href=\"canekzamudio.com/.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">bytes</a>, each byte represents some text character in the program.Most computer systems represent text characters using the ASCII standard that represents each character with a unique byte-size integer value.Files such as hello.c that consist exclusively of ASCII characters are known as text files, all other files are known as binary files.\nAll information in a system, including disk files, programs stored in memory, user data stores in memory, and data transferred across a network, is represented as a bunch of bits.\nThe only thing that distinguishes different data objects is the context in which we view them. ie, in different contexts, the same sequence of bytes might represent an integer, floating-point number, character string, or machine instruction.\n<br>...<a data-href=\"1.2 Programs Are Translated by Other Programs into Different Forms\" href=\"canekzamudio.com/cs_app/i.-computer-systems/1.2-programs-are-translated-by-other-programs-in-different-forms/1.2-programs-are-translated-by-other-programs-into-different-forms.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">1.2 Programs Are Translated by Other Programs into Different Forms</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Hello.c Lifecycle","level":1,"id":"Hello.c_Lifecycle_0"}],"links":[".html","cs_app/i.-computer-systems/1.2-programs-are-translated-by-other-programs-in-different-forms/1.2-programs-are-translated-by-other-programs-into-different-forms.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/i.-computer-systems/1.1-information-is-bits-+-context/1.1-information-is-bits-+-context.html","pathToRoot":"../../..","attachments":[],"createdTime":1762228983942,"modifiedTime":1751838736418,"sourceSize":1130,"sourcePath":"CS_APP/I. Computer Systems/1.1 Information is Bits + Context/1.1 Information is Bits + Context.md","exportPath":"cs_app/i.-computer-systems/1.1-information-is-bits-+-context/1.1-information-is-bits-+-context.html","showInTree":true,"treeOrder":30,"backlinks":["cs_app/i.-computer-systems/1.2-programs-are-translated-by-other-programs-in-different-forms/1.2-programs-are-translated-by-other-programs-into-different-forms.html"],"type":"markdown"},"cs_app/i.-computer-systems/1.2-programs-are-translated-by-other-programs-in-different-forms/1.2-programs-are-translated-by-other-programs-into-different-forms.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228984177,"modifiedTime":1751838736426,"sourceSize":2719,"sourcePath":"CS_APP/I. Computer Systems/1.2 Programs are Translated by other Programs in Different Forms/1.2 Programs Are Translated by Other Programs into Different Forms.md","exportPath":"cs_app/i.-computer-systems/1.2-programs-are-translated-by-other-programs-in-different-forms/1.2-programs-are-translated-by-other-programs-into-different-forms.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/i.-computer-systems/1.3-pays-to-understand-how-compilation-systems-work/1.3-it-pays-to-understand-how-compilation-systems-work.html":{"title":"1.3 It pays to Understand How Compilation Systems Work","icon":"","description":"<a href=\"canekzamudio.com?query=tag:CompilationSystem\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#CompilationSystem\">#CompilationSystem</a>For simple programs such as hello.c we can rely on the compilation system to produce correct and efficient machine code, but there are some important reasons why programmers need to understand how compilation systems work: In order to make good coding decisions in our C programs, we do need a basic understanding of machine-level code and how the compiler translates different C statements into machine code. Is a switch statement always more efficient than a sequence of if-else statements?**\nIs a while loop more efficient than a for loop?\nAre pointer references more efficient than array indexes?\nHow can a function run faster when we simply rearrange the parentheses in an arithmetic expression? Some of the most perplexing programming errors are related to the operation of the linker, especially in large software systems what does it mean when the linker reports that it cannot resolve a reference?\nWhat is the difference between a static variable and a global variable?\nWhat happens if you define two global variables in different C files with the same name?\nWhat is the difference between a static library and a dynamic library?\nWhy does it matter what order we list libraries on the command line? Why do some linker-related errors not appear until run time? Buffer overflow vulnerabilities have accounted for many of the security holes in network and Internet servers. These vulnerabilities exist because too few programmers understand the need to carefully restrict the quantity and forms of data they accept from untrusted sources.\nA first step in learning secure programming is to understand the consequences of the way data and control information are stored on the program stack\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Optimizing program performance","level":2,"id":"Optimizing_program_performance_0"},{"heading":"Understanding link-time errors","level":2,"id":"Understanding_link-time_errors_0"},{"heading":"Avoiding security holes","level":2,"id":"Avoiding_security_holes_0"}],"links":["?query=tag:CompilationSystem"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/i.-computer-systems/1.3-pays-to-understand-how-compilation-systems-work/1.3-it-pays-to-understand-how-compilation-systems-work.html","pathToRoot":"../../..","attachments":[],"createdTime":1762228981914,"modifiedTime":1751838736438,"sourceSize":1894,"sourcePath":"CS_APP/I. Computer Systems/1.3 Pays to Understand How Compilation Systems Work/1.3 It pays to Understand How Compilation Systems Work.md","exportPath":"cs_app/i.-computer-systems/1.3-pays-to-understand-how-compilation-systems-work/1.3-it-pays-to-understand-how-compilation-systems-work.html","showInTree":true,"treeOrder":34,"backlinks":[],"type":"markdown"},"cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.0-processors-read-and-interpret-instructions-stored-in-memory.html":{"title":"1.4.0 Processors Read and Interpret Instructions Stored in Memory","icon":"","description":"<a href=\"canekzamudio.com?query=tag:CompilationSystem\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#CompilationSystem\">#CompilationSystem</a> <br>At this point, our hello.c source program has been translated by the compilation system into an executable object file called hello that is stored on disk. To run the executable file on a Unix system, we type its name to an application program known as a <a data-href=\"Shell\" href=\"canekzamudio.com/cs_app/glossary/shell.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Shell</a>:linux&gt; ./hello hello, world\nIn this case, the shell loads and runs the hello program and then waits for it to terminate. The hello program prints its message to the screen and then terminates. The shell then prints a prompt and waits for the next input command line.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:CompilationSystem","cs_app/glossary/shell.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.0-processors-read-and-interpret-instructions-stored-in-memory.html","pathToRoot":"../../..","attachments":[],"createdTime":1762228982210,"modifiedTime":1751838736446,"sourceSize":570,"sourcePath":"CS_APP/I. Computer Systems/1.4 Processors Read and Interpret Instrucions Stored in Memory/1.4.0 Processors Read and Interpret Instructions Stored in Memory.md","exportPath":"cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.0-processors-read-and-interpret-instructions-stored-in-memory.html","showInTree":true,"treeOrder":36,"backlinks":[],"type":"markdown"},"cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228982367,"modifiedTime":1752362380381,"sourceSize":280,"sourcePath":"CS_APP/I. Computer Systems/1.4 Processors Read and Interpret Instrucions Stored in Memory/1.4.1 Hardware Organization of a System.md","exportPath":"cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228982430,"modifiedTime":1752363668993,"sourceSize":1070,"sourcePath":"CS_APP/I. Computer Systems/1.5 Caches Matter/1.5.0 Caches Matter.md","exportPath":"cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/i.-computer-systems/1.6-storage-devices-form-a-hierarchy/1.6.1-storage-devices-form-a-hierarchy.html":{"title":"1.6.1 Storage Devices Form a Hierarchy","icon":"","description":"The storage devices in evey computer systems are organized as a memory hierarchy.As we move from the top of the hierarchy to the bottom, the devices become slower, larger, and less costly per byte. The register file occupies the top level in the hierarchy, which is known as level 0 or L0. We show three levels of caching L1 to L3, occupying memory hierarchy levels 1 to 3. Main memory occupies level 4, and so on.<img alt=\"Pasted image 20250712180214.png\" src=\"canekzamudio.com/assets/pasted-image-20250712180214.png\" target=\"_self\">\nJust as programmers can exploit knowledge of the different caches to improve performance, programmers can exploit their understanding of the entire memory hierarchy.r","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/i.-computer-systems/1.6-storage-devices-form-a-hierarchy/1.6.1-storage-devices-form-a-hierarchy.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250712180214.png"],"createdTime":1762228982647,"modifiedTime":1752366379753,"sourceSize":621,"sourcePath":"CS_APP/I. Computer Systems/1.6 Storage Devices Form a Hierarchy/1.6.1 Storage Devices Form a Hierarchy.md","exportPath":"cs_app/i.-computer-systems/1.6-storage-devices-form-a-hierarchy/1.6.1-storage-devices-form-a-hierarchy.html","showInTree":true,"treeOrder":41,"backlinks":[],"type":"markdown"},"cs_app/i.-computer-systems/1.7-os-manages-the-hardware/1.7.0-the-os-manages-the-hardware.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228983505,"modifiedTime":1752366765123,"sourceSize":285,"sourcePath":"CS_APP/I. Computer Systems/1.7 OS Manages the Hardware/1.7.0 The OS Manages the Hardware.md","exportPath":"cs_app/i.-computer-systems/1.7-os-manages-the-hardware/1.7.0-the-os-manages-the-hardware.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/i.-computer-systems/1.8-systems-comunicate-with-other-systems-using-networks/1.8.0-systems-communicate-with-other-systems-using-networks.html":{"title":"1.8.0 Systems Communicate with Other Systems Using Networks","icon":"","description":"Modern systems are often linked to other systems by networks. From the point of view of an individual system, the network can be viewed as just another <a data-href=\"I-O Devices\" href=\"canekzamudio.com/cs_app/glossary/i-o-devices.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">I-O Devices</a>. When the system copies a sequence of bytes from <a data-href=\"Main Memory\" href=\"canekzamudio.com/cs_app/glossary/main-memory.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Main Memory</a> to the network <a data-href=\"Adapter\" href=\"canekzamudio.com/cs_app/glossary/adapter.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Adapter</a>, the data flow across the network to another machine, instead of, say, to a local disk drive, and the system can read data sent from other machines and copy these data to its main memory.<br>Cause of <a data-href=\"Internet\" href=\"canekzamudio.com/indexes/networking/internet.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Internet</a>, copying information from one machine to another has become one of the most important uses of computer systems. i.e. applications such as email, instant messaging, the World Wide Web, FTP, and telnet are all based on the ability to copy information over a network.<br>\n<img alt=\"Pasted image 20250715124434.png\" src=\"canekzamudio.com/assets/pasted-image-20250715124434.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/glossary/i-o-devices.html","cs_app/glossary/main-memory.html","cs_app/glossary/adapter.html","indexes/networking/internet.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/i.-computer-systems/1.8-systems-comunicate-with-other-systems-using-networks/1.8.0-systems-communicate-with-other-systems-using-networks.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250715124434.png"],"createdTime":1762228982786,"modifiedTime":1752605076565,"sourceSize":773,"sourcePath":"CS_APP/I. Computer Systems/1.8 Systems Comunicate with Other Systems Using Networks/1.8.0 Systems Communicate with Other Systems Using Networks.md","exportPath":"cs_app/i.-computer-systems/1.8-systems-comunicate-with-other-systems-using-networks/1.8.0-systems-communicate-with-other-systems-using-networks.html","showInTree":true,"treeOrder":45,"backlinks":[],"type":"markdown"},"cs_app/i.-computer-systems/1.9-important-themes/1.9.0-important-themes.html":{"title":"1.9.0 Important Themes","icon":"","description":"An important idea to take away from this is that system is more than just hardware. It is a collection of intertwined hardware and systems software that must cooperate in order to achieve the ultimate goal of running application programs.Throughout the history of digital computers, two demands have been constant forces in driving improvements: we want them to do more, and we want them to run faster. Both of these factors improve when the processor does more things at once.Parallelism can be exploited at multiple levels of abstraction in a computer system. We highlight three levels here, working from the highest to the lowest level in the system hierarchy.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1.9.1 <a data-href=\"Amdahl's Law\" href=\"Amdahl's Law\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">Amdahl's Law</a>","level":1,"id":"1.9.1_[[Amdahl's_Law]]_0"},{"heading":"1.9.2 <a data-href=\"concurrency\" href=\"concurrency\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">concurrency</a> and <a data-href=\"Parallelism\" href=\"Parallelism\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">Parallelism</a>","level":1,"id":"1.9.2_[[concurrency]]_and_[[Parallelism]]_0"},{"heading":"Thread-Level Concurrency","level":1,"id":"Thread-Level_Concurrency_0"}],"links":["cs_app/i.-computer-systems/1.9-important-themes/amdahl's-law.html","cs_app/glossary/concurrency.html","cs_app/glossary/parallelism.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/i.-computer-systems/1.9-important-themes/1.9.0-important-themes.html","pathToRoot":"../../..","attachments":[],"createdTime":1762228983363,"modifiedTime":1752622722978,"sourceSize":768,"sourcePath":"CS_APP/I. Computer Systems/1.9 Important Themes/1.9.0 Important Themes.md","exportPath":"cs_app/i.-computer-systems/1.9-important-themes/1.9.0-important-themes.html","showInTree":true,"treeOrder":47,"backlinks":[],"type":"markdown"},"cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html":{"title":"1.9.2 Concurrency and Parallelism","icon":"","description":"Throughout the history of digital computers, two demands have been constant forces in driving improvements: we want them to do more, and we want them to run faster. Both of these factors improve when the processor does more things at once.<a data-href=\"Parallelism\" href=\"canekzamudio.com/cs_app/glossary/parallelism.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Parallelism</a> can be exploited at multiple levels of abstraction in a computer system. We highlight three levels here, working from the highest to the lowest level in the system hierarchy.<br>We are able to execute multiple processes at the same time, leading to <a data-href=\"concurrency\" href=\"canekzamudio.com/cs_app/glossary/concurrency.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">concurrency</a>. With <a data-href=\"threads\" href=\"canekzamudio.com/cs_app/glossary/threads.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">threads</a>, we can even have multiple control flows executing within a single process<br>When we construct a system consisting of multiple processors all under the control of a single OS <a data-href=\"kernel\" href=\"canekzamudio.com/cs_app/glossary/kernel.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">kernel</a>, we have a multiprocessor system (or <a data-href=\"multi-core processor\" href=\"canekzamudio.com/cs_app/glossary/multi-core-processor.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">multi-core processor</a>).multi-core processor<br>Multi-core processors have several <a data-href=\"CPU\" href=\"canekzamudio.com/cs_app/glossary/cpu.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">CPU</a>s referred to as \"cores\", integrated onto a single integrated-circuit chip.<br>\n<img alt=\"Pasted image 20250715174131.png\" src=\"canekzamudio.com/assets/pasted-image-20250715174131.png\" target=\"_self\"><br>\n<img alt=\"Pasted image 20250715174158.png\" src=\"canekzamudio.com/assets/pasted-image-20250715174158.png\" target=\"_self\"><br>\nTypical multi-core processors have four CPU cores in a single chip, each with its own L1 and L2 <a data-tooltip-position=\"top\" aria-label=\"cache memories\" data-href=\"cache memories\" href=\"canekzamudio.com/cs_app/glossary/cache-memories.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">caches</a>, and with each L1 cache split into two parts - one to hold recently fetched instructions and one to hold data. The cores share higher levels of cache as well as the interface to <a data-href=\"Main Memory\" href=\"canekzamudio.com/cs_app/glossary/main-memory.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Main Memory</a>. In future a single chip may have hundreds of cores.hyperthreading<br>*Hyperthreading, sometimes called \"simultaneous multi-threading\", is a technique that allows a single CPU to execute multiple flows of control. It involves having multiple copies of some of the CPU hardware, such as program counters and <a data-href=\"register file\" href=\"canekzamudio.com/cs_app/glossary/register-file.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register file</a>s, while having only single copies of other parts of the hardware, such as the units that perform floating-point arithmetic (<a data-href=\"ALU\" href=\"canekzamudio.com/cs_app/glossary/alu.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">ALU</a>)*.Whereas a conventional processor requires around 20,000 clock cycles to shift between different threads, a hyperthreaded processor decides which of its threads to execute on a cycle-bycycle basis. It enables the CPU to take better advantage of its processing resources. For example, if one thread must wait for some data to be loaded into a cache, the CPU can proceed with the execution of a different thread. As an example, the Intel Core i7 processor can have each core executing two threads, and so a four-core system can actually execute eight threads in parallel.The use of multiprocessing can improve system performance in two ways. First, it reduces the need to simulate concurrency when performing multiple tasks. As mentioned, even a personal computer being used by a single person is expected to perform many activities concurrently. Second, it can run a single application program faster, but only if that program is expressed in terms of multiple threads that can effectively execute in parallel. At a much lower level of abstraction, modern processors can execute multiple instructions at one time, a property known as instruction-level parallelism.\ni.e., early microprocessors, required multiple (typically 3-10) clock cycles to execute a single instruction. More recent processors can sustain execution rates of 2-4 instructions per clock cycle. Any given instruction requires much longer from start to finish, perhaps 20 cycles or more, but the processor uses a number of clever tricks to process as many as 100 instructions at a timeIn Chapter 4, we will explore the use of pipelining, where the actions required to execute an instruction are partitioned into different steps and the processor hardware is organized as a series of stages, each performing one of these steps. The stages can operate in parallel, working on different parts of different instructions. We will see that a fairly simple hardware design can sustain an execution rate close to 1 instruction per clock cycle.Processors that can sustain execution rates faster than 1 instruction per cycle are known as superscalar processors. Most modern processors support superscalar operationAt the lowest level, many modern processors have special hardware that allows a single instruction to cause multiple operations to be performed in parallel, a mode known as single-instruction, multiple data (SIMD) parallelism.Recent generations of Intel and AMD processors have instructions that can add 8 pairs of single-precision floating-point numbers (C data type float) in parallelThese SIMD instructions are provided mostly to speed up applications that process image, sound, and video data. Although some compilers attempt to automatically extract SIMD parallelism from C programs, a more reliable method is to write programs using special vector data types supported in compilers such as GCC.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Thread-Level Concurrency","level":1,"id":"Thread-Level_Concurrency_0"},{"heading":"Instruction-Level Parallelism","level":1,"id":"Instruction-Level_Parallelism_0"},{"heading":"SIMD - SingleInstruction, Multiple-Data Parallelism","level":1,"id":"SIMD_-_SingleInstruction,_Multiple-Data_Parallelism_0"}],"links":["cs_app/glossary/parallelism.html","cs_app/glossary/concurrency.html","cs_app/glossary/threads.html","cs_app/glossary/kernel.html","cs_app/glossary/multi-core-processor.html","cs_app/glossary/cpu.html","cs_app/glossary/cache-memories.html","cs_app/glossary/main-memory.html","cs_app/glossary/register-file.html","cs_app/glossary/alu.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html","pathToRoot":"../../..","attachments":["cs_app/glossary/multi-core-processor.html","assets/pasted-image-20250715174131.png","assets/pasted-image-20250715174158.png","cs_app/glossary/hyperthreading.html"],"createdTime":1762228983347,"modifiedTime":1752626680991,"sourceSize":3284,"sourcePath":"CS_APP/I. Computer Systems/1.9 Important Themes/1.9.2 Concurrency and Parallelism.md","exportPath":"cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html","showInTree":true,"treeOrder":48,"backlinks":[],"type":"markdown"},"cs_app/i.-computer-systems/1.9-important-themes/1.9.3-the-importance-of-abstractions-in-computer-systems.html":{"title":"1.9.3 The Importance of Abstractions in Computer Systems","icon":"","description":"The use of abstractions is one of the most important concepts in computer science. For example, one aspect of good programming practice is to formulate a simple application program interface (API) for a set of functions that allow programmers to use the code without having to delve into its inner workings.\n<img alt=\"Pasted image 20250715184855.png\" src=\"canekzamudio.com/assets/pasted-image-20250715184855.png\" target=\"_self\">\nOn the processor side, the instruction set architecture provides an abstraction of the actual processor hardware. With this abstraction, a machine-code program behaves as if it were executed on a processor that performs just one instruction at a time. The underlying hardware is far more elaborate, executing multiple instructions in parallel, but always in a way that is consistent with the simple, sequential model. By keeping the same execution model, different processor implementations can execute the same machine code while offering a range of cost and performance.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/i.-computer-systems/1.9-important-themes/1.9.3-the-importance-of-abstractions-in-computer-systems.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250715184855.png"],"createdTime":1762228982971,"modifiedTime":1755202058510,"sourceSize":923,"sourcePath":"CS_APP/I. Computer Systems/1.9 Important Themes/1.9.3 The Importance of Abstractions in Computer Systems.md","exportPath":"cs_app/i.-computer-systems/1.9-important-themes/1.9.3-the-importance-of-abstractions-in-computer-systems.html","showInTree":true,"treeOrder":49,"backlinks":[],"type":"markdown"},"cs_app/i.-computer-systems/1.9-important-themes/amdahl's-law.html":{"title":"Amdahl's Law","icon":"","description":"<a href=\"canekzamudio.com?query=tag:Maths\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#Maths\">#Maths</a>The main idea is that when we speed up one part of a system, the effect on the overall system performance depends on both how insignificant this part was and how much it sped up.Consider a system in which executing some application requires time . Suppose some part of the system requires a fraction of this time, and that we improve its performance by a factor of . That is, the component originally required time , and it now requires time . The overall execution time would thus beFrom this, we can compute the speedup asConsider the case where a part of the system that initially consumed 60% of the time is sped up by a factor of 3 . Then we get a speedup of . Even though we made a substantial improvement to a major part of the system, our net speedup was significantly less than the speedup for the one part. This is the major insight of Amdahl's law - to significantly speed up the entire system, we must improve the speed of a very large fraction of the overall system.One interesting special case of Amdahls law is to consider the effect of setting k to . That is, we are able to take some part of the system and speed it up to the point at which it takes a negligible amount of time. We then get So, for example, if we can speed up 60% of the system to the point where it requires close to no time, our net speedup will still only be .Amdahl's law describes a general principle for improving any process. In addition to its application to speeding up computer systems, it can guide a company trying to reduce the cost of manufacturing razor blades, or a student trying to improve his or her grade point average. Perhaps it is most meaningful in the world of computers, where we routinely improve performance by factors of 2 or more. Such high factors can only be achieved by optimizing large parts of a system.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Example","level":3,"id":"Example_0"}],"links":["?query=tag:Maths"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/i.-computer-systems/1.9-important-themes/amdahl's-law.html","pathToRoot":"../../..","attachments":[],"createdTime":1762228983146,"modifiedTime":1752614384658,"sourceSize":2158,"sourcePath":"CS_APP/I. Computer Systems/1.9 Important Themes/Amdahl's Law.md","exportPath":"cs_app/i.-computer-systems/1.9-important-themes/amdahl's-law.html","showInTree":true,"treeOrder":50,"backlinks":["cs_app/i.-computer-systems/1.9-important-themes/1.9.0-important-themes.html"],"type":"markdown"},"cs_app/i.-computer-systems/1.0-computer-systems.html":{"title":"1.0 Computer Systems","icon":"","description":"<a href=\"canekzamudio.com?query=tag:CS_Architecture\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#CS_Architecture\">#CS_Architecture</a>A computer system consists of hardware and systems software that cooperate to run application programs. Information inside the computer is represented as groups of bits that are interpreted in different ways, depending on the context. Programs are translated by other programs into different forms, beginning as ASCII text and then translated by compilers and linkers into binary executable files.\nProcessors read and interpret binary instructions that are stored in main memory. Since computers spend most of their time copying data between memory, I/O devices, and the CPU registers, the storage devices in a system are arranged in a hierarchy, with the CPU registers at the top, followed by multiple levels of hardware cache memories, DRAM main memory, and disk storage. Storage devices that are higher in the hierarchy are faster and more costly per bit than those lower in the hierarchy. Storage devices that are higher in the hierarchy serve as caches for devices that are lower in the hierarchy. Programmers can optimize the performance of their C programs by understanding and exploiting the memory hierarchy.The operating system kernel serves as an intermediary between the application and the hardware. It provides three fundamental abstractions: (1) Files are abstractions for I/O devices. (2) Virtual memory is an abstraction for both main memory and disks. (3) Processes are abstractions for the processor, main memory, and I/O devices. Finally, networks provide ways for computer systems to communicate with one another. From the viewpoint of a particular system, the network is just another I/O device.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:CS_Architecture"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/i.-computer-systems/1.0-computer-systems.html","pathToRoot":"../..","attachments":[],"createdTime":1762228984101,"modifiedTime":1752627182902,"sourceSize":1646,"sourcePath":"CS_APP/I. Computer Systems/1.0 Computer Systems.md","exportPath":"cs_app/i.-computer-systems/1.0-computer-systems.html","showInTree":true,"treeOrder":51,"backlinks":[],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.0-information-storage.html":{"title":"2.1.0 Information Storage","icon":"","description":"Most computers use bytes (blocks of 8 bits), as the smallest addressable unit of memory. A machine-level program views memory as a very large array of bytes, referred to as <a data-href=\"virtual memory\" href=\"canekzamudio.com/cs_app/glossary/virtual-memory.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">virtual memory</a>. Every byte of memory is identified by a unique number, known as its address, and the set of all possible addresses is known as the virtual address space.<br>\n<img alt=\"Pasted image 20250715224120.png\" src=\"canekzamudio.com/assets/pasted-image-20250715224120.png\" target=\"_self\" style=\"width: 600px; max-width: 100%;\"><br>\nThis virtual address space is just a conceptual image presented to the machine-level program. The actual implementation uses a combination of dynamic random access memory (DRAM), flash memory, disk storage, special hardware, and <a data-href=\"Operating System\" href=\"canekzamudio.com/cs_app/glossary/operating-system.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Operating System</a> software to provide the program with what appears to be a monolithic byte array<br>Various mechanisms are used to allocate and manage the storage for different parts of the program. This management is all performed within the virtual address space. For example, the value of a <a data-tooltip-position=\"top\" aria-label=\"Pointers\" data-href=\"Pointers\" href=\"canekzamudio.com/indexes/coding/c/pointers.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">pointer</a> in C --whether it points to an integer, a structure, or some other program object-- is the virtual address of the first byte of some block storage. The C compiler also associates type information with each pointer, so that it can generate different machine-level code to access the value stored at the location designated by the pointer depending on the type of that value. Although the C compiler maintains this type information, the actual machine-level program it generates has no information about data types. It simply treats each program object as a block of bytes and the program itself as a sequence of bytes.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/glossary/virtual-memory.html","cs_app/glossary/operating-system.html","indexes/coding/c/pointers.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.0-information-storage.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250715224120.png"],"createdTime":1762229047436,"modifiedTime":1752641831778,"sourceSize":1571,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.0 Information Storage.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.0-information-storage.html","showInTree":true,"treeOrder":54,"backlinks":[],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html":{"title":"2.1.1 Hexadecimal Notation","icon":"","description":"Hexadecimal (or simply \"hex\") uses digits \"0\" through \"9\" along with characters \"A\" to \"F\" to represent 16 possible values, written in hexadecimal , the value of a single byte can range from to .A single byte consists of 8 bits. In binary notation, its values range from to . When viewed as a decimal integer, its value ranges from to .\nNeither notation is very convenient for describing bit patterns. Binary notation is too verbose, while with decimal notation it is tedious to convert to and from bit patterns.. Instead, we write bit patterns as base-16, or hexadecimal numbers\n<img alt=\"Pasted image 20250716131144.png\" src=\"canekzamudio.com/assets/pasted-image-20250716131144.png\" target=\"_self\">\nIn C, numeric constants starting with 0x or 0X are interpreted as being in hexadecimal. The characters A through F may be written in either upper- or lowercase. For example, we could write the number FA1D37B16 as 0xFA1D37B, as 0xfa1d37b, or even mixing upper- and lowercase (e.g., 0xFa1D37b).When a value x is a power of 2, that is, x = 2n for some nonnegative integer n, we can readily write x in hexadecimal form by remembering that the binary representation of x is simply 1 followed by n zeros. The hexadecimal digit 0 represents 4 binary zeros. So, for n written in the form i + 4j , where 0  i  3, we can write x with a leading hex digit of 1 (i = 0), 2 (i = 1), 4 (i = 2), or 8 (i = 3), followed by j hexadecimal 0s. As an example, for x = 2,048 = 2 11, we have n = 11 = 3 + 4 . 2, giving hexadecimal representation 0x800.To convert a decimal number x to hexadecimal, we can repeatedly divide x by 16, giving a quotient q and a remainder r, such that x = q . 16 + r. We then use the hexadecimal digit representing r as the least significant digit and generate the remaining digits by repeating the process on q. As an example, consider the conversion of decimal 314,156: From this we can read off the hexadecimal representation as 0x4CB2C.Conversely, to convert a hexadecimal number to decimal, we can multiply each of the hexadecimal digits by the appropriate power of 16. For example, given the number 0x7AF, we compute its decimal equivalent as ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"<span class=\"math math-inline is-loaded\"><mjx-container class=\"MathJax\" jax=\"CHTML\"><mjx-math class=\"MJX-TEX\"><mjx-mi class=\"mjx-i\"><mjx-c class=\"mjx-c1D45B TEX-I\"></mjx-c></mjx-mi><mjx-texatom texclass=\"ORD\"><mjx-mo class=\"mjx-n\"><mjx-utext variant=\"normal\" style=\"font-family: MJXZERO, serif;\"></mjx-utext></mjx-mo></mjx-texatom></mjx-math></mjx-container></span> to hex","level":1,"id":"$n$_to_hex_0"},{"heading":"decimal to hex","level":1,"id":"decimal_to_hex_0"},{"heading":"hex to decimal","level":1,"id":"hex_to_decimal_0"}],"links":[],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250716131144.png"],"createdTime":1762229047808,"modifiedTime":1752702331821,"sourceSize":2466,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.1 Hexadecimal Notation.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html","showInTree":true,"treeOrder":55,"backlinks":["cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.3-addressing-and-byte-ordering.html","cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.2-code-examples.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.4-jump-instruction-encodings.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html"],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.2-data-sizes.html":{"title":"2.1.2 Data Sizes","icon":"","description":"Every computer has a word size, indicating the nominal size of pointer data. Since a virtual address is encoded by such a word, the most important system parameter determined by the word size is the maximum size of the <a data-tooltip-position=\"top\" aria-label=\"virtual memory > Virtual Address Space\" data-href=\"virtual memory#Virtual Address Space\" href=\"canekzamudio.com/cs_app/glossary/virtual-memory.html#Virtual Address Space\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">virtual address space</a>. That is, for a machine with a -bit word size, the virtual addresses can range from 0 to , giving the program access to at most bytes.A 32-bit word size limits the virtual address space to 4GB, that is, just over bytes. Scaling up to a 64-bit word size leads to a virtual address space of 16 exabytes, or around Most 64-bit machines can also run programs for 32-bit machines with\ngcc -m32 prog.c\nThe C lang supports multiple data formats for both integer and floating-point data. The exact numbers of bytes for some data types depends on how the program is compiled.<br>\n<img alt=\"Pasted image 20250716183124.png\" src=\"canekzamudio.com/assets/pasted-image-20250716183124.png\" target=\"_self\">\nInteger data can be either signed, able to represent negative, zero, and positive values, or unsigned, only allowing nonnegative values. Data type char represents a single byte. Although the name char derives from the fact that it is used to store a single character in a text string, it can also be used to store integer values. Data types short, int, and long are intended to provide a range of sizesData types int32_t and int64_t have fixed data sizes regardless of compiler and machine settings. Using fixed-size integer types is the best way for programmers to have close control over data representations.Programmers should strive to make their programs portable across different machines and compilers. One aspect of portability is to make the program insensitive to the exact sizes of the different data types.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/glossary/virtual-memory.html#Virtual Address Space"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.2-data-sizes.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250716183124.png"],"createdTime":1762229049064,"modifiedTime":1752715432362,"sourceSize":1781,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.2 Data Sizes.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.2-data-sizes.html","showInTree":true,"treeOrder":56,"backlinks":["cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.1-integral-data-types.html"],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.3-addressing-and-byte-ordering.html":{"title":"2.1.3 Addressing and Byte Ordering","icon":"","description":"For program objects that span multiple bytes, we must establish two conventions: what the address of the object will be, and how we will order the bytes in memory. In virtually all machines, a multi-byte object is stored as a contiguous sequence of bytes, with the address of the object given by the smallest address of the bytes used. For example, suppose a variable x of type int has address 0x100; that is, the value of the address expression &amp;x is 0x100. Then (assuming <a data-tooltip-position=\"top\" aria-label=\"Data Types\" data-href=\"Data Types\" href=\"canekzamudio.com/indexes/coding/c/data-types.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">data type</a> int has a 32-bit representation) the 4 bytes of x would be stored in memory locations 0x100, 0x101, 0x102, and 0x103.For ordering the bytes representing an object, there are two common conventions. Consider a -bit integer having a bit representation , where is the most significant bit and is the least. Assuming w is a multiple of 8, these bits can be grouped as bytes, with the most significant byte having bits , the least significant byte having bits , and the other bytes having bits from the middle. Some machines choose to store the object in memory ordered from least significant byte to most, while other machines store them from most to least. The former conventionwhere the least significant byte comes firstis referred to as little endian. The latter convention*where the most significant byte comes firstis referred to as big endian.<br>Suppose the variable x of type int and at address 0x100 has a <a data-tooltip-position=\"top\" aria-label=\"2.1.1 Hexadecimal Notation\" data-href=\"2.1.1 Hexadecimal Notation\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">hexadecimal</a> value of 0x01234567. The ordering of the bytes within the address range 0x100 through 0x103 depends on the type of machine:<br>\n<img alt=\"Pasted image 20250716204848.png\" src=\"canekzamudio.com/assets/pasted-image-20250716204848.png\" target=\"_self\">\nNote that in the word 0x01234567 the high-order byte has a hexadecimal value 0x01, while the low-order byte has value 0x67.For most application programmers, the byte orderings used by their machines are totally invisible; programs compiled for either class of machine give identical results.\nMost Intel-compatible machines operate exclusively in little-endian mode. On the other hand, most machines from IBM and Oracle operate in big-endian mode.\nMany recent microprocessor chips are bi-endian, meaning that they can be configured to operate as either liitle or big endian machines The first is when binary data are communicated over a network between different machines. A common problem is for data produced by a little-endian machine to be sent to a big-endian machine, or vice versa, leading to the bytes within the words being in reverse order for the receiving program. To avoid such problems, code written for networking applications must follow established conventions for byte ordering to make sure the sending machine converts its internal representation to the network standard, while the receiving machine converts the network standard to its internal representation.\nA second case where byte ordering becomes important is when looking at the byte sequences representing integer data. This occurs often when inspecting machine-level programs. As an example, the following line occurs in a file that gives a text representation of the machine-level code for an Intel x86-64 processor: 4004d3: 01 05 43 0b 20 00 add %eax,0x200b43(%rip) This line was generated by a disassembler, a tool that determines the instruction sequence represented by an executable program file.\nWe simply note that this line states that the hexadecimal byte sequence 01 05 43 0b 20 00 is the byte-level representation of an instruction that adds a word of data to the value stored at an address computed by adding 0x200b43 to the current value of the program counter, the address of the next instruction to be executed. If we take the final 4 bytes of the sequence 43 0b 20 00 and write them in reverse order, we have 00 20 0b 43. Dropping the leading 0, we have the value 0x200b43, the numeric value written on the right. Having bytes appear in reverse order is a common occurrence when reading machine-level program representations generated for little-endian machines such as this one. The natural way to write a byte sequence is to have the lowest-numbered byte on the left and the highest on the right, but this is contrary to the normal way of writing numbers with the most significant digit on the left and the least on the right.\nA third case where byte ordering becomes visible is when programs are written that circumvent the normal type system. In the C language, this can be done using a cast or a union to allow an object to be referenced according to a different data type from which it was created. Such coding tricks are strongly discouraged for most application programming, but they can be quite useful and even necessary for system-level programming.\n#include &lt;stdio.h&gt; typedef unsigned char *byte_pointer; void show_bytes(byte_pointer start, size_t len) { int i; for (i = 0; i &lt; len; i++) printf(\" %.2x\", start[i]); printf(\"\\n\");\n} void show_int(int x) { show_bytes((byte_pointer) &amp;x, sizeof(int)); } void show_float(float x) { show_bytes((byte_pointer) &amp;x, sizeof(float));\n} void show_pointer(void *x) {\nshow_bytes((byte_pointer) &amp;x, sizeof(void *));\n}\n//CODE TO PRINT THE BYTE REPRESENTATION OF PROGRAM OBJECTS\nThese procedures use the C sizeof operator to determine the number of bytes used by the object. In general, the expression sizeof(T ) returns the number of bytes required to store an object of type T.Using sizeof rather than a fixed value is one step toward writing code that is portable across different machine types.void test_show_bytes(int val)\n{ int ival = val; float fval = (float) ival; int *pval = &amp;ival; show_int(ival); show_float(fval); show_pointer(pval);\n}\n//THIS CODE PRINTS THE BYTE REPRESENTATION OF SAMPLE DATA OBJECTS\n<br><img alt=\"Pasted image 20250717130734.png\" src=\"canekzamudio.com/assets/pasted-image-20250717130734.png\" target=\"_self\" style=\"width: 600px; max-width: 100%;\"><br>\nOur argument 12,345 has <a data-tooltip-position=\"top\" aria-label=\"2.1.1 Hexadecimal Notation\" data-href=\"2.1.1 Hexadecimal Notation\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">hexadecimal</a> representation (in big-endian). We can see that the leas significant byte value of is printed first for Linux 32, Windows and Linux 64, indicating little-endian machines, and last for Sun, indicating big-endian.\nNote that the Linux 32, Windows and Sun machines use 4-byte addresses, while the Linux 64 uses 8-byte addresses.Although the floating-point and the int data both encode the numeric value 12,345, they have different patterns: for the integer and for floating point. In general, these two formats use different encoding schemes. If we expand these hexadecimal patterns into binary form and shift them appropriately, we find a sequence of 13 matching bits, indicated by a sequence of asterisks, as follows:<br>\n<img alt=\"Pasted image 20250717141129.png\" src=\"canekzamudio.com/assets/pasted-image-20250717141129.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Issues with Byte Ordering","level":1,"id":"Issues_with_Byte_Ordering_0"},{"heading":"Byte Representing","level":1,"id":"Byte_Representing_0"}],"links":["indexes/coding/c/data-types.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.3-addressing-and-byte-ordering.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250716204848.png","assets/pasted-image-20250717130734.png","assets/pasted-image-20250717141129.png"],"createdTime":1762229048004,"modifiedTime":1754869249755,"sourceSize":6912,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.3 Addressing and Byte Ordering.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.3-addressing-and-byte-ordering.html","showInTree":true,"treeOrder":57,"backlinks":["cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.4-representing-strings.html"],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.4-representing-strings.html":{"title":"2.1.4 Representing Strings","icon":"","description":"A string in C is encoded by an array of characters terminated by the null (having value 0) character. Each character is represented by some standard encoding, with the most common being the ASCII character code.In a string \"12345\" and 6 (to include the terminating character), we get the result 31 32 33 34 35 00. This same result would be obtained on any system using ASCII as its character code, independent of the <a data-tooltip-position=\"top\" aria-label=\"2.1.3 Addressing and Byte Ordering\" data-href=\"2.1.3 Addressing and Byte Ordering\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.3-addressing-and-byte-ordering.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">byte ordering</a> and word size conventions. As a consequence, text data are more platform independent than binary data.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.3-addressing-and-byte-ordering.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.4-representing-strings.html","pathToRoot":"../../..","attachments":[],"createdTime":1762229047601,"modifiedTime":1753037306456,"sourceSize":581,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.4 Representing Strings.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.4-representing-strings.html","showInTree":true,"treeOrder":58,"backlinks":[],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.5-representing-code.html":{"title":"2.1.5 Representing Code","icon":"","description":"int sum(int x, int y)\n{ return x + y;\n}\nWhen compiled on our sample machines, we generate machine code having the following byte representations:Linux 32 55 89 e5 8b 45 0c 03 45 08 c9 c3\nWindows 55 89 e5 8b 45 0c 03 45 08 5d c3\nSun 81 c3 e0 08 90 02 00 09\nLinux 64 55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3Different machine types use different and incompatible instructions and encodings. Even identical <a data-tooltip-position=\"top\" aria-label=\"CPU\" data-href=\"CPU\" href=\"canekzamudio.com/cs_app/glossary/cpu.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">processors</a> running different <a data-href=\"Operating System\" href=\"canekzamudio.com/cs_app/glossary/operating-system.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Operating System</a>s have differences in their coding conventions and hence are not binary compatible. Binary code is seldom portable across different combinations of machine and operating system.\nA program, from the perspective of the machine, is simply a sequence of bytes. The machine has no information about the original source program, except perhaps some auxiliary tables maintained to aid in debugging.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/glossary/cpu.html","cs_app/glossary/operating-system.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.5-representing-code.html","pathToRoot":"../../..","attachments":[],"createdTime":1762229048309,"modifiedTime":1753042517336,"sourceSize":934,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.5 Representing Code.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.5-representing-code.html","showInTree":true,"treeOrder":59,"backlinks":[],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.6-intro-to-boolean-algebra.html":{"title":"2.1.6 Intro To Boolean Algebra","icon":"","description":"See more on <a data-href=\"1.1.1 Boolean Algebra\" href=\"canekzamudio.com/boolean-logic/background/1.1.1-boolean-algebra.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">1.1.1 Boolean Algebra</a><br>The simplest <a data-tooltip-position=\"top\" aria-label=\"1.1.1 Boolean Algebra\" data-href=\"1.1.1 Boolean Algebra\" href=\"canekzamudio.com/boolean-logic/background/1.1.1-boolean-algebra.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">boolean algebra</a> is defined over the two-element set {0, 1}<br>\n<img alt=\"Pasted image 20250720142153.png\" src=\"canekzamudio.com/assets/pasted-image-20250720142153.png\" target=\"_self\">\nWe can extend the four boolean operations to also operate on bit vectors, strings of zeros and ones of some fixed length . We define the operations over bit vectors according to their applications to the matching elements of the arguments.\nLet and denote the bit vectors and , respectively. We define &amp; also be a bit vector of length , where the th element equals &amp; , for . The operations |, ^, and ~ are extended to bit vectors in a similar fashion.<br>\n<img alt=\"Pasted image 20250722122228.png\" src=\"canekzamudio.com/assets/pasted-image-20250722122228.png\" target=\"_self\">One useful application of bit vectors is to represent finite sets. We can encode any subset with a bit vector , where = 1 if and only if .\nFor example, recalling that we write on the left and on the right, bit vector encodes the set , while bit vector encodes the set . With this way of encoding sets, Boolean operations | and &amp; correspond to set union and intersection, respectively, and ~ corresponds to set complement. Continuing our earlier example, the operation a &amp; b yields bit vector , while .","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["boolean-logic/background/1.1.1-boolean-algebra.html","boolean-logic/background/1.1.1-boolean-algebra.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.6-intro-to-boolean-algebra.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250720142153.png","assets/pasted-image-20250722122228.png"],"createdTime":1762229048670,"modifiedTime":1753210640634,"sourceSize":1478,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.6 Intro To Boolean Algebra.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.6-intro-to-boolean-algebra.html","showInTree":true,"treeOrder":60,"backlinks":["cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html"],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html":{"title":"2.1.7 Bitwise operators","icon":"","description":"C supports <a data-tooltip-position=\"top\" aria-label=\"2.1.6 Intro To Boolean Algebra\" data-href=\"2.1.6 Intro To Boolean Algebra\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.6-intro-to-boolean-algebra.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">boolean operations</a>. Boolean operators |, &amp;, ~, ^ can be applied to any \"integral\" data type.<br>\n<img alt=\"Pasted image 20250722131129.png\" src=\"canekzamudio.com/assets/pasted-image-20250722131129.png\" target=\"_self\"><br>\nThe best way to determine the effect of a bit-level expression is to expand the <a data-tooltip-position=\"top\" aria-label=\"2.1.1 Hexadecimal Notation\" data-href=\"2.1.1 Hexadecimal Notation\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">hexadecimal</a> arguments to their binary representations, perform the operation in binary, and then convert back to hex.A mask is a bit pattern that indicates a selected set of bits within a word.As an example, the mask 0xFF (having ones for the last significant 8 bits) indicates the low-order byte of a word. The bit-level operation &amp; yields a value consisting of the least significant byte of x, but with all other bytes set to 0. For example, with x = 0x89ABCDEF, the expression would yield 0x000000EF. The expression ~0 will yield a mask of all ones, regardless of the size of the data representation. The same mask can be written 0xFFFFFFFF when data type int is 32 bits, but it would not be as portable.The expression ~0xFF creates a mask where the 8 least-significant bits equal 0 and the rest equal 1. Observe that such a mask will be generated regardless of the word size. By contrast, the expression 0xFFFFFF00 would only work when data type int is 32 bits.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Masking Operations","level":1,"id":"Masking_Operations_0"}],"links":["cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.6-intro-to-boolean-algebra.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250722131129.png"],"createdTime":1762229048100,"modifiedTime":1753386063393,"sourceSize":1305,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.7 Bitwise operators.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html","showInTree":true,"treeOrder":61,"backlinks":["cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.8-logical-operations-in-c.html"],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.8-logical-operations-in-c.html":{"title":"2.1.8 Logical Operations in C","icon":"","description":"Operators ||, &amp;&amp;, and ! treat any nonzero argument as representing TRUE and argument 0 FALSE. They return either 1 or 0 (true or false).\n<img alt=\"Pasted image 20250724134626.png\" src=\"canekzamudio.com/assets/pasted-image-20250724134626.png\" target=\"_self\"><br>\nAn important distinction between the logical operators &amp;&amp; and || versus their <a data-tooltip-position=\"top\" aria-label=\"2.1.7 Bitwise operators\" data-href=\"2.1.7 Bitwise operators\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">bit-level</a> counterparts &amp; and | is that the logical operators do not evaluate their second argument if the result of the expression can be determined by evaluating the first argument. Thus, for example, the expression a &amp;&amp; 5/a will never cause a division by zero, and the expression p &amp;&amp; *p++ will never cause the dereferencing of a null <a data-tooltip-position=\"top\" aria-label=\"Pointers\" data-href=\"Pointers\" href=\"canekzamudio.com/indexes/coding/c/pointers.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">pointer</a>.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html","indexes/coding/c/pointers.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.8-logical-operations-in-c.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250724134626.png"],"createdTime":1762229048550,"modifiedTime":1769558307961,"sourceSize":678,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.8 Logical Operations in C.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.8-logical-operations-in-c.html","showInTree":true,"treeOrder":62,"backlinks":[],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html":{"title":"2.1.9 Shift Operations in C","icon":"","description":"Shift operators shift bit patterns to the left and to the right.For an operand x having bit representation , the C expression x &lt;&lt; k yields a value with bit representation . That is, x is shifted k bits to the left, dropping off the k most significant bits and filling the right end with k zeros. The shift amount should be a value between 0 and w  1. Shift operations associate from left to right, so x &lt;&lt; j &lt;&lt; k is equivalent to (x &lt;&lt; j) &lt;&lt; k.\nMachines support two forms of right shift: A logical right shift fills the left end with zeros, giving a result . An arithmetic right shift fills the left end with repetitions of the most significant bit, giving a result . This convention is useful for operating on signed integer data.\n<img alt=\"Pasted image 20250724145251.png\" src=\"canekzamudio.com/assets/pasted-image-20250724145251.png\" target=\"_self\">\nAlmost all computer/machine combinations use arithmetic right shifts for signed data, and many programmers assume this to be the case. For unsigned data, right shifts must be logical.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Logical","level":2,"id":"Logical_0"},{"heading":"Arithmetic","level":2,"id":"Arithmetic_0"}],"links":[],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250724145251.png"],"createdTime":1762229048370,"modifiedTime":1753390507152,"sourceSize":1172,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.9 Shift Operations in C.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html","showInTree":true,"treeOrder":63,"backlinks":["cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.7-dividing-by-powers-of-2.html"],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.0-integer-representations.html":{"title":"2.2.0 Integer Representations","icon":"","description":"There are 2 ways bits can be used to encode integers, one that can only represent nonnegative numbers, and one that can represent negative, zero, and positive numbers.This list the mathematical terminology we introduce to precisely define and characterize how computers encode and operate on integer data.\n<img alt=\"Pasted image 20250725174630.png\" src=\"canekzamudio.com/assets/pasted-image-20250725174630.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.0-integer-representations.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250725174630.png"],"createdTime":1762229045349,"modifiedTime":1753487196042,"sourceSize":345,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.0 Integer Representations.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.0-integer-representations.html","showInTree":true,"treeOrder":65,"backlinks":[],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.1-integral-data-types.html":{"title":"2.2.1 Integral Data Types","icon":"","description":"C supports a variety of integral data types. Each type can specify a <a data-tooltip-position=\"top\" aria-label=\"2.1.2 Data Sizes\" data-href=\"2.1.2 Data Sizes\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.2-data-sizes.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">data size</a> with keyword char, short, long, as well as an indication of whether the represented numbers are all nonnegative (declared as unsigned), or possibly negative (default).The number of bytes allocated for the different sizes varies according to whether the program is compiled for 32 or 64 bits. Based on the byte allocations, the different sizes allow different ranges of values to be represented. The only machine-dependent range indicated is for size designator long. Most 64-bit programs use an 8-byte representation, giving a much wider range of values than the 4-byte representation used with 32-bit programs.<br>\n<img alt=\"Pasted image 20250725180054.png\" src=\"canekzamudio.com/assets/pasted-image-20250725180054.png\" target=\"_self\" style=\"width: 590px; max-width: 100%;\">\nRanges are not symmetricthe range of negative numbers extends one further than the range of positive numbers.<br>\n<img alt=\"Pasted image 20250725180109.png\" src=\"canekzamudio.com/assets/pasted-image-20250725180109.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.2-data-sizes.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.1-integral-data-types.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250725180054.png","assets/pasted-image-20250725180109.png"],"createdTime":1762229045859,"modifiedTime":1753488091594,"sourceSize":912,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.1 Integral Data Types.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.1-integral-data-types.html","showInTree":true,"treeOrder":66,"backlinks":[],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.2-unsigned-encodings.html":{"title":"2.2.2 Unsigned Encodings","icon":"","description":"Let us consider an integer <a data-tooltip-position=\"top\" aria-label=\"Data Types\" data-href=\"Data Types\" href=\"canekzamudio.com/indexes/coding/c/data-types.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">data type</a> of bits. We write a bit vector as either , to denote the entire vector, or as to denote the individual bits within the vector. Treating as a number written in binary notation, we obtain the unsigned interpretation of . In this encoding, each bit has value 0 or 1, with the latter case indicating that value should be included as part of the numeric value. We can express this interpretation as a function (for binary to unsigned, length ):<br>\n<img alt=\"Pasted image 20250725183303.png\" src=\"canekzamudio.com/assets/pasted-image-20250725183303.png\" target=\"_self\">\nIn this, we represent each bit position by a rightward-pointing blue bar of length . The numeric value associated with a bit vector then equals the sum of the lengths of the bars for which the corresponding bit values are 1.Definition of unsigned encoding\nFor vector In this equation, the notation means that the left-hand side is defined to be equal to the right-hand side. The function maps strings of zeros and ones of length to nonnegative integers. Let us consider the range of values that can be represented using bits. The least value is given by bit vector having integer value . Using the 4-bit case as an example, we have . Thus, the function can be defined as a mapping .The unsigned binary representation has the important property that every number between 0 and has a unique encoding as a -bit value. For example, there is only one representation of decimal value 11 as an unsigned 4-bit number namely, . We highlight this as a mathematical principle, which we first state and then explain.Uniqueness of unsigned encoding\nFunction is a bijection\nThe mathematical term bijection refers to a function that goes two ways: it maps a value to a value where = , but it can also operate in reverse, since for every , there is a unique value such that . This is given by the inverse function , where, for our example, . The function maps each bit vector of length to a unique number between and , and it has an inverse, which we call (for unsigned to binary), that maps each number in the range to to a unique pattern of bits.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"bijection","level":3,"id":"bijection_0"}],"links":["indexes/coding/c/data-types.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.2-unsigned-encodings.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250725183303.png"],"createdTime":1762229046107,"modifiedTime":1753494870647,"sourceSize":3019,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.2 Unsigned Encodings.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.2-unsigned-encodings.html","showInTree":true,"treeOrder":67,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html"],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.3-two's-complement-encodings.html":{"title":"2.2.3 Two's-Complement Encodings","icon":"","description":"The most common computer representation of signed numbers is known as two's-complement form. This is defined by interpreting the most significant bit of the word to have negative weight. We name this as a function (for \"binary to two's complement\" length )Definition of two's-complement encoding\nFor vector The most significant bit is also called the sign bit. Its \"weight\" is , the negation of its weight in an unsigned representation. When the sign bit is set to 1, the represented value is negative, and when set to 0, the value is nonnegative. <img alt=\"Pasted image 20250805133858.png\" src=\"canekzamudio.com/assets/pasted-image-20250805133858.png\" target=\"_self\">\nLet us consider the range of values that can be represented as a w-bit twoscomplement number. The least representable value is given by bit vector (set the bit with negative weight but clear all others), having integer value . The greatest value is given by bit vector (clear the bit with negative weight but set all others), having integer value . Using the 4-bit case as an example, we have and .Uniqueness of two's-complement encoding\nFunction is a bijection\nWe define function (for twos complement to binary) to be the inverse of . That is, for a number , such that , is the (unique) -bit pattern that encodes .The twos-complement range is asymmetric: ; that is, there is no positive counterpart to . As we shall see, this leads to some peculiar properties of twos-complement arithmetic and can be the source of subtle program bugs.<br>\n<img alt=\"Pasted image 20250805140636.png\" src=\"canekzamudio.com/assets/pasted-image-20250805140636.png\" target=\"_self\"><br>\n<img alt=\"Pasted image 20250805143818.png\" src=\"canekzamudio.com/assets/pasted-image-20250805143818.png\" target=\"_self\">There are two other standard representations for signed numbers: Ones complement. This is the same as twos complement, except that the most significant bit has weight rather than : Sign magnitude. The most significant bit is a sign bit that determines whether the remaining bits should be given negative or positive weight: ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Alternative representations of signed numbers","level":2,"id":"Alternative_representations_of_signed_numbers_0"}],"links":[],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.3-two's-complement-encodings.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250805133858.png","assets/pasted-image-20250805140636.png","assets/pasted-image-20250805143818.png"],"createdTime":1762229045599,"modifiedTime":1754426301250,"sourceSize":2952,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.3 Two's-Complement Encodings.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.3-two's-complement-encodings.html","showInTree":true,"treeOrder":68,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.0-arithmetic-and-logical-operations.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html"],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.4-t2u-&-u2t.html":{"title":"2.2.4 T2U & U2T","icon":"","description":"C allows casting between different numeric data types. For example, suppose variable x is declared as int and u as unsigned. The expression (unsigned) x converts the value of x to an unsigned value, and (int) u converts the value of u to a signed integer. In casting from unsigned to int, the underlying bit representation stays the same, the numeric values might change, but the bit patterns do not.Conversion from two's complement to unsigned\nFor such that : For example, we saw that , and also that .\n<img alt=\"Pasted image 20250805215808.png\" src=\"canekzamudio.com/assets/pasted-image-20250805215808.png\" target=\"_self\">\nFigure 2.17 illustrates the general behavior of function . As it shows, when mapping a signed number to its unsigned counterpart, negative numbers are converted to large positive numbers, while nonnegative numbers remain unchanged.\nGoing in the other direction, we can state the relationship between an unsigned number u and its signed counterpart U2Tw (u):Unsigned to two's-complement conversion\nFor such that : <br><img alt=\"Pasted image 20250805220347.png\" src=\"canekzamudio.com/assets/pasted-image-20250805220347.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"2.2.4 T2U &amp; U2T","level":1,"id":"2.2.4_T2U_&_U2T_0"}],"links":[],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.4-t2u-&-u2t.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250805215808.png","assets/pasted-image-20250805220347.png"],"createdTime":1762229045931,"modifiedTime":1754453033710,"sourceSize":1285,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.4 T2U & U2T.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.4-t2u-&-u2t.html","showInTree":true,"treeOrder":69,"backlinks":["cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.5-signed-versus-unsigned-in-c.html"],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.5-signed-versus-unsigned-in-c.html":{"title":"2.2.5 Signed versus Unsigned in C","icon":"","description":"Almost all machines use twos complement. Generally, most numbers are signed by default. For example, when declaring a constant such as 12345 or 0x1A2B, the value is considered signed. Adding character U or u as a suffix creates an unsigned constant; for example, 12345U or 0x1A2Bu.C allows conversion between unsigned and signed most systems apply the function <a data-tooltip-position=\"top\" aria-label=\"2.2.4 T2U &amp; U2T\" data-href=\"2.2.4 T2U &amp; U2T\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.4-t2u-&amp;-u2t.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">U2T</a> when converting from unsigned to signed, and <a data-tooltip-position=\"top\" aria-label=\"2.2.4 T2U &amp; U2T\" data-href=\"2.2.4 T2U &amp; U2T\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.4-t2u-&amp;-u2t.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">T2U</a> when converting from signed to unsigned, where is the number of bits for the data type.Some possibly nonintuitive behavior arises due to Cs handling of expressions containing combinations of signed and unsigned quantities. When an operation is performed where one operand is signed and the other is unsigned, C implicitly casts the signed argument to unsigned and performs the operations assuming the numbers are nonnegative.<br>\n<img alt=\"Pasted image 20250805221658.png\" src=\"canekzamudio.com/assets/pasted-image-20250805221658.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.4-t2u-&-u2t.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.4-t2u-&-u2t.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.5-signed-versus-unsigned-in-c.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250805221658.png"],"createdTime":1762229045092,"modifiedTime":1754455453994,"sourceSize":965,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.5 Signed versus Unsigned in C.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.5-signed-versus-unsigned-in-c.html","showInTree":true,"treeOrder":70,"backlinks":[],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.6-expanding-the-bit-representation-of-a-number.html":{"title":"2.2.6 Expanding the Bit representation of a Number","icon":"","description":"One common operation is to convert between integers having different word sizes while retaining the same numeric value. Of course, this may not be possible when the destination data type is too small to represent the desired value. Converting from a smaller to a larger data type, however, should always be possible.To convert an unsigned number to a larger data type, we can simply add leading zeros to the representation; this operation is known as zero extension, expressed by the following principle:Expansion of an unsigned number by zero extension\nDefine bit vectors of widh and of width , where . Then .\nFor converting a two's-complement number to a larger data type, the rule is to perform a sign extension, assign copies of the most significant bit to the representation, expressed by the following principle. We show the sign bit in bold to highlight its role in sign extension.Expansion of a two's-complement number by sign extension\nDefine bit vectors of widh and of width , where . Then .\n<img alt=\"Pasted image 20250806124238.png\" src=\"canekzamudio.com/assets/pasted-image-20250806124238.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.6-expanding-the-bit-representation-of-a-number.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250806124238.png"],"createdTime":1762229046392,"modifiedTime":1754505759240,"sourceSize":1387,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.6 Expanding the Bit representation of a Number.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.6-expanding-the-bit-representation-of-a-number.html","showInTree":true,"treeOrder":71,"backlinks":[],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.7-truncating-numbers.html":{"title":"2.2.7 Truncating Numbers","icon":"","description":"Suppose that, rather than extending a value with extra bits, we reduce the number of bits representing a number. This occurs in this codeint x = 53191;\nshort sx = (short) x; /* -12345 */\nint y = sx; /* -12345 */\nCasting x to be short will truncate a 32-bit int to a 16-bit short. As we saw before, this 16-bit pattern is the twos-complement representation of 12,345. When casting this back to int, sign extension will set the high-order 16 bits to ones, yielding the 32-bit twos-complement representation of 12,345.When truncating a -bit number to a -bit number, we drop the high-order bits, giving a bit vector . Truncating a number can alter its valuea form of overflow. For an unsigned number, we can readily characterize the numeric value that will result.Truncation of an unsigned number\nLet be the bit vector , and let be the result of truncating it to bits: . Let and . Then mod .\nThe intuition behind this principle is simply that all of the bits that were truncated have weights of the form , where , and therefore each of these weights reduces to zero under the modulus operation. A similar property holds for truncating a twos-complement number, except that it then converts the most significant bit into a sign bit:Truncation of a two's-complement number\nLet be the bit vector , and let be the result of truncating it to bits: . Let and . Then mod .\nIn this formulation, mod will be a number between and . Applying function to it will have the effect of converting the most significant bit from having weight to having weight . We can see this with the example of converting value from int to short. Since , we have mod . But when we convert this number to a 16-bit twos-complement number, we get .","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.7-truncating-numbers.html","pathToRoot":"../../..","attachments":[],"createdTime":1762229045326,"modifiedTime":1754509718477,"sourceSize":2452,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.7 Truncating Numbers.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.7-truncating-numbers.html","showInTree":true,"treeOrder":72,"backlinks":[],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.8-advice-on-signed-versus-unsigned.html":{"title":"2.2.8 Advice on Signed versus Unsigned","icon":"","description":"So implicit casting of signed to unsigned leads to some non-intuitive behavior. Nonintuitive features often lead to program bugs, and ones involving the nuances of implicit casting can be especially difficult to see. Since the casting takes place without any clear indication in the code, programmer often overlook its effects.We have seen multiple ways in which the subtle features of unsigned arithmetic, and especially the implicit conversion of signed to unsigned, can lead to errors or vulnerabilities. One way to avoid such bugs is to never use unsigned numbers.Unsigned values are very useful when we want to think of words as just collections of bits with no numeric interpretation. This occurs, for example, when packing a word with flags describing various Boolean conditions. Addresses are naturally unsigned, so systems programmers find unsigned types to be helpful. Unsigned values are also useful when implementing mathematical packages for modular arithmetic and for multiprecision arithmetic, in which numbers are represented by arrays of words.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.8-advice-on-signed-versus-unsigned.html","pathToRoot":"../../..","attachments":[],"createdTime":1762229045939,"modifiedTime":1754512892645,"sourceSize":1065,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.8 Advice on Signed versus Unsigned.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.8-advice-on-signed-versus-unsigned.html","showInTree":true,"treeOrder":73,"backlinks":[],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.1-unsigned-addition.html":{"title":"2.3.1 Unsigned Addition","icon":"","description":"Consider two nonnegative integers x and y, such that 0  x, y &lt; 2w. Each of these values can be represented by a w-bit unsigned number. If we compute their sum, however, we have a possible range 0  x + y  2w+1  2. Representing this sum could require w + 1 bits.Figure 2.21 shows a plot of the function x + y when x and y have 4-bit representations. The arguments (shown on the horizontal axes) range from 0 to 15, but the sum ranges from 0 to 30. The shape of the function is a sloping plane (the function is linear in both dimensions). If we were to maintain the sum as a (w + 1)-bit number and add it to another value, we may require w + 2 bits, and so on.\n<img alt=\"Pasted image 20250807171802.png\" src=\"canekzamudio.com/assets/pasted-image-20250807171802.png\" target=\"_self\">\nThis continued \"word size inflation\" means we cannot place any bound on the word size required to fully represent the results of arithmetic operations.Let us define the operation for arguments and , where , as the result of truncating the integer sum to be bits long and then viewing the result as an unsigned number.\nThis can be characterized as a form of modular arithmetic, computing the sum modulo by simply discarding any bits with weight greater than in the bit-level representation of . For example, consider a -bit number representation with and , having bit representations and , respectively. Their sum is 21, having a 5-bit representation . But if we discard the high-order bit, we get [0101], that is, decimal value 5. This matches the value 21 mod 16 = 5.So we can characterize operation as follows:Unsigned addition\nFor and such that : -^u_w x =\n\\begin{cases}\nx, &amp; x = 0 \\quad \\\n2^w  x, &amp; x &gt; 0 \\quad\n\\end{cases}","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.1-unsigned-addition.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250807171802.png"],"createdTime":1762229046899,"modifiedTime":1769564716236,"sourceSize":4113,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.1 Unsigned Addition.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.1-unsigned-addition.html","showInTree":true,"treeOrder":75,"backlinks":[],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.2-two's-complement-addition.html":{"title":"2.3.2 Two's-Complement Addition","icon":"","description":"With twos-complement addition, we must decide what to do when the result is either too large (positive) or too small (negative) to represent. Given integer values and in the range , their sum is in the range , potentially requiring bits to represent exactly.Let us define to be the result of truncating the integer sum to be bits long and then viewing the result as a twos-complement number.Two's-complement addition\nFor integer values and in the range : This principle is illustrated in Figure 2.24, where the sum is shown on the left, having a value in the range , and the result of truncating the sum to a -bit twos-complement number is shown on the right. (The labels Case 1 to Case 4 in this figure are for the case analysis of the formal derivation of the principle.) When the sum exceeds (case 4), we say that positive overflow has occurred. In this case, the effect of truncation is to subtract from the sum. When the sum is less than (case 1), we say that negative overflow has occurred. In this case, the effect of truncation is to add to the sum.\nThe -bit twos-complement sum of two numbers has the exact same bit-level\nrepresentation as the unsigned sum. In fact, most computers use the same machine instruction to perform either unsigned or signed addition.\n<img alt=\"Pasted image 20250807193243.png\" src=\"canekzamudio.com/assets/pasted-image-20250807193243.png\" target=\"_self\"><br>\n<img alt=\"Pasted image 20250807193302.png\" src=\"canekzamudio.com/assets/pasted-image-20250807193302.png\" target=\"_self\">\nFigure 2.26 illustrates twos-complement addition for word size . The operands range between . When , twos-complement addition has a negative overflow, causing the sum to be incremented by 16. When , the addition yields . When , the addition has a positive overflow, causing the sum to be decremented by . Each of these three ranges forms a sloping plane in the figure.<br>\n<img alt=\"Pasted image 20250807193731.png\" src=\"canekzamudio.com/assets/pasted-image-20250807193731.png\" target=\"_self\">Detecting overflow in two's-complement addition\nFor and in the range , let . Then the computation of has had positive overflow if and only if and but . The computation has had negative overflow if and only if and but .\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.2-two's-complement-addition.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250807193243.png","assets/pasted-image-20250807193302.png","assets/pasted-image-20250807193731.png"],"createdTime":1762229047202,"modifiedTime":1755539953793,"sourceSize":2748,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.2 Two's-Complement Addition.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.2-two's-complement-addition.html","showInTree":true,"treeOrder":76,"backlinks":[],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.3-two's-complement-negation.html":{"title":"2.3.3 Two's Complement Negation","icon":"","description":"We can see that every number in the range has an additive inverse under , which we denote as follows:Two's-complement negation\nFor in the range , its twos-complement negation is given by the formula That is, for -bit two's-complement addition, is its own additive inverse, while any other value has as its additive inverse.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.3-two's-complement-negation.html","pathToRoot":"../../..","attachments":[],"createdTime":1762229046584,"modifiedTime":1754620643437,"sourceSize":550,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.3 Two's Complement Negation.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.3-two's-complement-negation.html","showInTree":true,"treeOrder":77,"backlinks":[],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.4-unsigned-multiplication.html":{"title":"2.3.4 Unsigned Multiplication","icon":"","description":"Integers and in the range can be represented as -bit unsigned numbers, but their product can range between and . This could require as many as bits to represent. Instead, unsigned multiplication in C is defined to yield the -bit value given by the low-order bits of the -bit integer product. Let us denote this value as . Truncating an unsigned number to bits is equivalent to computing its value modulo , giving the following:Unsigned multiplication\nFor and such that : ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.4-unsigned-multiplication.html","pathToRoot":"../../..","attachments":[],"createdTime":1762229047566,"modifiedTime":1754621522254,"sourceSize":696,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.4 Unsigned Multiplication.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.4-unsigned-multiplication.html","showInTree":true,"treeOrder":78,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html"],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.5-two's-complement-multiplication.html":{"title":"2.3.5 Two's-complement multiplication","icon":"","description":"Integers and in the range can be represented as -bit twos-complement numbers, but their product can range between and . This could require as many as bits to represent in twos-complement form. Instead, signed multiplication in C generally is performed by truncating the -bit product to bits. We denote this value as . Truncating a twos-complement number to w bits is equivalent to first computing its value modulo and then converting from unsigned to twos complement, giving the following:Two's-complement multiplication\nFor and such that : The bit-level representation of the product operation is identical for both unsigned and twos-complement multiplication.\n<img alt=\"Pasted image 20250808164737.png\" src=\"canekzamudio.com/assets/pasted-image-20250808164737.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.5-two's-complement-multiplication.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250808164737.png"],"createdTime":1762229046795,"modifiedTime":1754693257982,"sourceSize":1029,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.5 Two's-complement multiplication.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.5-two's-complement-multiplication.html","showInTree":true,"treeOrder":79,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html"],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.6-multiplying-by-constants.html":{"title":"2.3.6 Multiplying by Constants","icon":"","description":"Integer multiply instruction on many machines is slower than other operations. Even on the Inter Core i7 Haswell we use as our reference machine, integer multiply requires 3 clock cycles. So, one important optimization used by compiler is to attempt to replace multiplications by constant factors with combinations of shift and addition operations. We will first consider the case of multiplying by a power of 2, and then we will generalize this to arbitrary constants.Multiplication by a power of 2\nLet be the unsigned integer represented by bit pattern . Then for any , the -bit unsigned representation of is given by , where zeros have been added to the right.\nSo, for example, 11 can be represented for as . Shifting this left by yields the 6-bit vector, which encodes the unsigned number .When shifting left by for a fixed word size, the high-order bits are discarded, yieldingbut this is also the case when performing multiplication on fixed-size words. We can therefore see that shifting a value left is equivalent to performing unsigned multiplication by a power of 2:Unsigned multiplication by a power of 2\nFor C variables and with unsigned values and , such that , the C expression yields the value .\nSince the bit-level operation of fixed-size twos-complement arithmetic is equivalent to that for unsigned arithmetic, we can make a similar statement about the relationship between left shifts and multiplication by a power of 2 for twos-complement arithmetic:Two's-complement multiplication by a power of 2\nFor C variables and with two's-complement value and unsigned value , such that , the C expression yields the value .\nNote that multiplying by a power of 2 can cause overflow with either unsigned or twos-complement arithmetic. Our result shows that even then we will get the same effect by shifting. Returning to our earlier example, we shifted the -bit pattern (numeric value ) left by two positions to get (numeric value ). Truncating this to bits gives (numeric value ).Given that integer multiplication is more costly than shifting and adding, many C compilers try to remove many cases where an integer is being multiplied by a constant with combinations of shifting, adding, and subtracting. For example, suppose a program contains the expression . Recognizing that , the compiler can rewrite the multiplication as , replacing one multiplication with three shifts and two additions. The two computations will yield the same result, regardless of whether is unsigned or twos complement, and even if the multiplication would cause an overflow. Even better, the compiler can also use the property to rewrite the multiplication as , requiring only two shifts and a subtractionGeneralizing from our example, consider the task of generating code for the expression , for some constant . The compiler can express the binary representation of $K as an alternating sequence of zeros and ones: By adding together the results for each run, we are able to compute x * K without any multiplications. Of course, the trade-off between using combinations of shifting, adding, and subtracting versus a single multiplication instruction depends on the relative speeds of these instructions, and these can be highly machine dependent. Most compilers only perform this optimization when a small number of shifts, adds, and subtractions suffice.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.6-multiplying-by-constants.html","pathToRoot":"../../..","attachments":[],"createdTime":1762229046602,"modifiedTime":1754702290049,"sourceSize":4404,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.6 Multiplying by Constants.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.6-multiplying-by-constants.html","showInTree":true,"treeOrder":80,"backlinks":[],"type":"markdown"},"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.7-dividing-by-powers-of-2.html":{"title":"2.3.7 Dividing by Powers of 2","icon":"","description":"Integer divisions in most machines is even slowe than multiplication, requiring 30 or more clock cycles,Dividing by a power of 2 can also be using <a data-tooltip-position=\"top\" aria-label=\"2.1.9 Shift Operations in C\" data-href=\"2.1.9 Shift Operations in C\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">shift operations</a>, but we use a right shift rather than a left shift. The two different right shifts<a data-tooltip-position=\"top\" aria-label=\"2.1.9 Shift Operations in C\" data-href=\"2.1.9 Shift Operations in C\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">logical and arithmetic</a>serve this purpose for unsigned and twos-complement numbers, respectively. Integer division always rounds toward zero. To define this precisely, let us introduce some notation\nFor any real number , define to be the unique integer such that .\nAs examples, , , and . Similarly, define to be the unique integer such that . As examples, , , and . For and , integer division should yield , while for and , it should yield . That is, it should round down a positive result but round up a negative one.\nThe case for using shifts with unsigned arithmetic is straightforward, in part because\nright shifting is guaranteed to be performed logically for unsigned values.Unsigned division by a power of 2\nFor C variables and with unsigned values and , such that , the C expression yields the value <br><img alt=\"Pasted image 20250808193539.png\" src=\"canekzamudio.com/assets/pasted-image-20250808193539.png\" target=\"_self\">\nFigure 2.28 shows the effects of performing logical right shifts on a 16-bit representation of 12,340 to perform division by 1, 2, 16, and 256. The zeros shifted in from the left are shown in italics. We also show the result we would obtain if we did these divisions with real arithmetic. These examples show that the result of shifting consistently rounds toward zero, as is the convention for integer division<br>\n<img alt=\"Pasted image 20250808193628.png\" src=\"canekzamudio.com/assets/pasted-image-20250808193628.png\" target=\"_self\">\nThe case for dividing by a power of 2 with twos-complement arithmetic is slightly more complex. First, the shifting should be performed using an arithmetic right shift, to ensure that negative values remain negative. Let us investigate what value such a right shift would produce.Two's-complement division by a power of 2, rounding down\nLet C variables and have twos-complement value and unsigned value , respectively, such that . The C expression , when the shift is performed arithmetically, yields the value For , variable has as the most significant bit, and so the effect of an arithmetic shift is the same as for a logical right shift. Thus, an arithmetic right shift by is the same as division by for a nonnegative number. As an example of a negative number, Figure 2.29 shows the effect of applying arithmetic right shift to a -bit representation of for different shift amounts. For the case when no rounding is required , the result will be . When rounding is required, shifting causes the result to be rounded downward. For example, the shifting right by four has the effect of rounding down to . We will need to adjust our strategy to handle division for negative values of .<br>\n<img alt=\"Pasted image 20250808194016.png\" src=\"canekzamudio.com/assets/pasted-image-20250808194016.png\" target=\"_self\">\nWe can correct for the improper rounding that occurs when a negative number is shifted right by biasing the value before shifting.Two's-complement division by a power of 2, rounding up\n...\n... Continue...","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.7-dividing-by-powers-of-2.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250808193539.png","assets/pasted-image-20250808193628.png","assets/pasted-image-20250808194016.png"],"createdTime":1762229047079,"modifiedTime":1754709424619,"sourceSize":3538,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.7 Dividing by Powers of 2.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.7-dividing-by-powers-of-2.html","showInTree":true,"treeOrder":81,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.1-a-historical-perspective/3.0.0-machine-level-representation-of-programs.html":{"title":"3.0.0 Machine Level Representation of Programs","icon":"","description":"Computers execute machine code, sequences of bytes encoding the low-level operations that manipulate data, manage, read and write data on storage devices, and communicate over <a data-href=\"Network\" href=\"canekzamudio.com/indexes/networking/network.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Network</a>s. A <a data-tooltip-position=\"top\" aria-label=\"Compiler - cc1\" data-href=\"Compiler - cc1\" href=\"canekzamudio.com/.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">compiler</a> generates machine code through a series of stages, based on the rules of the programming language, the instruction set of the target machine, and the conventions followed by the <a data-href=\"Operating System\" href=\"canekzamudio.com/cs_app/glossary/operating-system.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Operating System</a>.<br>The GCC C compiler generates its output in the form of <a data-href=\"assembly\" href=\"canekzamudio.com/assembly.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">assembly</a> code a textual representation of the machine code giving the individual instructions to the program. GCC the invokes both an <a data-href=\"Assembler - as\" href=\"canekzamudio.com/.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Assembler - as</a> and a <a data-href=\"Linker - ld\" href=\"canekzamudio.com/.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Linker - ld</a> to generate the executable machine code from the assembly code","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["indexes/networking/network.html",".html","cs_app/glossary/operating-system.html","assembly.html",".html",".html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.1-a-historical-perspective/3.0.0-machine-level-representation-of-programs.html","pathToRoot":"../../..","attachments":[],"createdTime":1762228981914,"modifiedTime":1755198157878,"sourceSize":727,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.1 A Historical Perspective/3.0.0 Machine Level Representation of Programs.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.1-a-historical-perspective/3.0.0-machine-level-representation-of-programs.html","showInTree":true,"treeOrder":84,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.0-program-encodings.html":{"title":"3.2.0 Program Encodings","icon":"","description":"Suppose we write a C program as two files p1.c and p2.c. We can then compile this code using:linux&gt; gcc -Og -o p p1.c p2.c gcc - indicates the GCC C compiler, the default <a data-tooltip-position=\"top\" aria-label=\"Compiler - cc1\" data-href=\"Compiler - cc1\" href=\"canekzamudio.com/.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">compiler</a> on Linux\n-Og instructs the compiler to apply a level of optimization that yields machine code that follows the overall structure of the original C code(Invoking higher levels of optimization can generate code that is so heavily transformed that the relationship between the generated machine code and the original source code is difficult to understand. We will therefore use -Og optimization as a learning tool)\n<br><img alt=\"Pasted image 20250814135551.png\" src=\"canekzamudio.com/assets/pasted-image-20250814135551.png\" target=\"_self\">\nThe way to turn the source code into executable code:\nThe C preprocessor expands the source code to include any files specified with #include commands and to expand any macros, specified with #define declarations. <br>The compiler generates <a data-href=\"assembly\" href=\"canekzamudio.com/assembly.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">assembly</a> code versions of the two source files having names p1.s and p2.s.\nThe assembler converts the assembly code into binary object-code files p1.o and p2.o. Object code is one form of machine codeit contains binary representations of all of the instructions, but the addresses of global values are not yet filled in. Finally, the linker merges these two object-code files along with code implementing library functions (e.g., printf) and generates the final executable code file p (as specified by the command-line directive -o p). Executable code is te exact form of code that is executed by the processor\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[".html","assembly.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.0-program-encodings.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250814135551.png"],"createdTime":1762228981153,"modifiedTime":1755201813177,"sourceSize":1567,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.0 Program Encodings.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.0-program-encodings.html","showInTree":true,"treeOrder":86,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.1-machine-level-code.html":{"title":"3.2.1 Machine-Level Code","icon":"","description":"CS employ different forms of abstraction, hiding details of an implementation through the use of a simpler abstract model. Two of these are specially important for machine-level programming:ISA - Instruction Set ArchitectureThe ISA defines the format and behaviour of a machine-level program.Defines:\nProcessor state\nFormat of the instructions\nThe effect each of these instructions will have on the state\nMost ISAs, like x86 one, describe the behavior of a program as if each instruction is executed in sequence, with one instruction completing before the next one begins.\nThe processor hardware is far more elaborate, executing many instructions concurrently, but it employs safeguards to ensure that the overall behavior matches the sequential operation dictated by the ISA. Two big groups of architectures define main <a data-href=\"assembly\" href=\"canekzamudio.com/assembly.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">assembly</a> languages :CISC assembly languages, such as Intel IA-32 and x64, have more complex instructions. They generally focus on completing tasks using as few lines of assembly instructions as possible.\nTo do so, some instructions can perform multiple operations, such as mul in Intel assembly,\nwhich performs data access, multiplication, and data store operations in one go.In the RISC assembly language, assembly instructions are simple and generally perform only one operation each. This may lead to more lines of code to complete a specific task, but it may also be more efficient, as this omits the execution of any unnecessary operations.<br>Second, the memory addresses used by a machine level program are <a data-tooltip-position=\"top\" aria-label=\"virtual memory\" data-href=\"virtual memory\" href=\"canekzamudio.com/cs_app/glossary/virtual-memory.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">virtual addresses</a>, providing a memory model that appears to be a very large byte array. The actual implementation of the memory system involves a combination of multiple hardware memories and operating system software.The machine code for x86 differs greatly from the original C code. Parts of the processor state are visible that normally are hidden from the C programmer:\n<br>The <a data-tooltip-position=\"top\" aria-label=\"1.4.1 Hardware Organization of a System\" data-href=\"1.4.1 Hardware Organization of a System\" href=\"canekzamudio.com/cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">program counter</a> (called %rip in x86) indicates the address in memory of the next instrucion to be executed\n<br>The integer <a data-tooltip-position=\"top\" aria-label=\"1.4.1 Hardware Organization of a System\" data-href=\"1.4.1 Hardware Organization of a System\" href=\"canekzamudio.com/cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register file</a> contains 16 named locations storing 64-bit values. These registers can hold addresses (corresponding to C <a data-href=\"Pointers\" href=\"canekzamudio.com/indexes/coding/c/pointers.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Pointers</a>) or integer data. Some registers are used to keep track of critical parts of the program state, while others are used to hold temporary data, such as the arguments and local <a data-href=\"Variables\" href=\"canekzamudio.com/indexes/coding/c/variables.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Variables</a> of a procedure, as well as the value to be returned by a function.\nThe condition code registers hold status information about the most recently executed arithmetic or logical instruction. These are used to implement conditional changes in the control or data flow, such as is required to implement if and while statements.\nA set of vector registers can each hold one or more integer or floating-point values\nMachine code views the memory as simply a larga byte-addressable array. Aggregate data types in C such as arrays and structures are represented in machine code as contiguous collections of bytes. Even for scalar data types, assembly code makes no distinctions between signed or unsigned integers, between different types of pointers, or even between pointers and integers<br>The program memory contains the executable machine code for the program, some information required by the <a data-href=\"Operating System\" href=\"canekzamudio.com/cs_app/glossary/operating-system.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Operating System</a>, a run-time stack for managing procedure calls and returns, and blocks of memory allocated by the user( e.g. function in malloc library).\nThe program memory is addressed using virtual addresses. At any given\ntime , only limited subranges of virtual addresses are considered valid. For example, x86-64 virtual addresses are represented by 64-bit words. In current implementations of these machines, the upper 16 bits must be set to zero, and so an address can potentially specify a byte over a range of 2 48 , or 64 terabytes. More typical programs will only have access to a few megabytes, or perhaps several gigabytes. The operating system manages this virtual address space, translating virtual addresses into the physical addresses of values in the actual processor memoryA single machine instruction performs only a very elementary operation. For example, it might add two numbers stored in registers, transfer data between memory and a register, or conditionally branch to a new instruction address.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Complex Instruction Set Computer (CISC)","level":8,"id":"Complex_Instruction_Set_Computer_(CISC)_0"},{"heading":"Reduced Instruction Set Computer (RISC)","level":8,"id":"Reduced_Instruction_Set_Computer_(RISC)_0"}],"links":["assembly.html","cs_app/glossary/virtual-memory.html","cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html","cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html","indexes/coding/c/pointers.html","indexes/coding/c/variables.html","cs_app/glossary/operating-system.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.1-machine-level-code.html","pathToRoot":"../../..","attachments":["cs_app/glossary/isa-instruction-set-architecture.html"],"createdTime":1762228981645,"modifiedTime":1755203902402,"sourceSize":3162,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.1 Machine-Level Code.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.1-machine-level-code.html","showInTree":true,"treeOrder":87,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.2-code-examples.html":{"title":"3.2.2 Code Examples","icon":"","description":"C code file mstore.c:long mult2(long, long); void multstore(long x, long y, long *dest) { long t = mult2(x, y); *dest = t\n}\nTo see the <a data-href=\"assembly\" href=\"canekzamudio.com/assembly.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">assembly</a> code generated by the C compiler, we can use the -S optionlinux&gt; gcc -Og -S mstore.c\nThe assembly code file contains various declarations, including the following set of lines:multstore: pushq %rbx movq %rdx, %rbx call %mult2 movq %rax, (%rbx) popq %rbx ret\nEach indented line in the code corresponds to a single machine instruction. For example, the pushq instruction indicates that the contents of register %rbx should be pushed onto the program stack.If we use the -c command-line option, GCC will both compile and assemble the codelinux&gt; gcc -Og -c mstore.c\nThis will generate an object-code file mstore.o that is in binary format and hence cannot be viewed directly. Embedded within the 1,368 bytes of the file mstore.o is a 14-byte sequence with the hexadecimal representation53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3\nThis is the object code corresponding to the assembly instructions listed previously. A key lesson to learn from this is that the program executed by the machine is simply a sequence of bytes encoding a series of instructions\nTo inspect the contents of machine-code files, we need a disassembler. These programs generate a format similar to assembly code from the machine code. With Linux systems, the program objdump (for object dump) can serve this role given the -d command-line flag:linux&gt; objdump -d mstore.c\n<br><img alt=\"Pasted image 20250815131351.png\" src=\"canekzamudio.com/assets/pasted-image-20250815131351.png\" target=\"_self\"><br>\nOn the left we see the 14 <a data-tooltip-position=\"top\" aria-label=\"2.1.1 Hexadecimal Notation\" data-href=\"2.1.1 Hexadecimal Notation\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">hexadecimal</a> byte values, listed in the byte sequence shown earlier, partitioned into groups of 1 to 5 bytes each. Each of these groups is a single instruction, with the <a data-href=\"assembly\" href=\"canekzamudio.com/assembly.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">assembly</a>-language equivalent shown on the right. Several features about machine code and its disassembled representation are worth noting:\nx86-64 instructions can range in length from 1 to 15 bytes\nThe instruction format is designed in such a way that from a given starting position, there is a unique decoding of the bytes into machine instructions. For example, only the instruction pushq %rbx can start with byte value 53.\nThe disassembler determines the assembly code based purely on the byte sequences in the machine-code file.\nThe disassembler uses a slightly different naming convention for the instructions than does the assembly code generated by gcc. In our example, it has omitted the suffix q from many of the instructions. These suffixes are size designators and can be omitted in most cases.\n<br>Generating the actual executable code requires running a <a data-tooltip-position=\"top\" aria-label=\"Linker - ld\" data-href=\"Linker - ld\" href=\"canekzamudio.com/.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">linker</a> on the set of object-code files, one of which must contain a function main. making a separated main.c file then we could generate an executable program prog as follows:linux&gt; gcc -Og -o prog main.c mstore.c\nThe file prog has grown to 8,655 bytes, since it contains not just the machine code for the procedures we provided but also code used to start and terminate the program as well as to interact with the operating system.\nThe disassembler will extract various code sequences, including the following:<br>\n<img alt=\"Pasted image 20250815133752.png\" src=\"canekzamudio.com/assets/pasted-image-20250815133752.png\" target=\"_self\">\nThis code is almost identical to that generated by the disassembly of mstore.c. One important difference is that the addresses listed along the left are different the linker has shifted the location of this code to a different range of addresses. A second difference is that the linker has filled in the address that the callq instruction should use in calling the function mult2 (line 4 of the disassembly).\nOne task for the linker is to match function calls with the locations of the executable code for those functions. A final difference is that we see two additional lines of code (lines 89). These instructions will have no effect on the program, since they occur after the return instruction (line 7). They have been inserted to grow the code for the function to 16 bytes, enabling a better placement of the next block of code in terms of memory system performance.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["assembly.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html","assembly.html",".html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.2-code-examples.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250815131351.png","assets/pasted-image-20250815133752.png"],"createdTime":1762228981569,"modifiedTime":1755286793844,"sourceSize":4240,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.2 Code Examples.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.2-code-examples.html","showInTree":true,"treeOrder":88,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.3-notes-on-formatting.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228981422,"modifiedTime":1755454163332,"sourceSize":1129,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.3 Notes on Formatting.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.3-notes-on-formatting.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.3-data-formats/3.3.0-data-formats.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228976878,"modifiedTime":1755459766783,"sourceSize":1596,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.3 Data Formats/3.3.0 Data Formats.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.3-data-formats/3.3.0-data-formats.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.0-accessing-information.html":{"title":"3.4.0 Accessing Information","icon":"","description":"registerAn x86 <a data-href=\"CPU\" href=\"canekzamudio.com/cs_app/glossary/cpu.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">CPU</a> contains a set of 16 general-purpose registers storing 64-bit values. These registers are used to store integer data as well as <a data-href=\"Pointers\" href=\"canekzamudio.com/indexes/coding/c/pointers.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Pointers</a>. Their names all begin with %r, but otherwise follow multiple different naming conventions, owing to the historical evolution of the instruction set.<br>\n<img alt=\"Pasted image 20250817140128.png\" src=\"canekzamudio.com/assets/pasted-image-20250817140128.png\" target=\"_self\" style=\"width: 500px; max-width: 100%;\">\nFigure 3.2 Integer registers. The low-order portions of all 16 registers can be accessed as byte, word (16-bit), double word (32-bit), and quad word (64-bit) quantities.As the nested boxes above indicate, instructions can operate on data of different sizes stored in the low-order bytes of the 16 registers. Byte-level operations can access the least significant byte, 16-bit operations can access the least significant 2 bytes, 32-bit operations can access the least significant 4 bytes, and 64-bit operations can access entire registers.There are also a number of instructions for copying and generating 1, 2, 4, and 8-byte values. When these instructions have registers as destinations, two conventions arise for what happens to the remaining bytes in the register for instructions that generate less than 8 bytes: Those that generate 1 or 2-byte quantities leave the remaining bytes unchanged. Those that generate 4-byte quantities set the upper 4 bytes of the register to zero.x86 adopts a uniform set of conventions for register usage that must be respected by all procedures. By convention, registers %rbx, %rbp, and %r12 - %r15 are classified as callee-saved registers. When procedure P calls procedure Q, Q must preserve the values of these registers, ensuring that they have the same values when Q returns to P as they did when Q was called.\nProcedure Q can preserve a register value by either not changing it at all or by pushing<br>\nthe original value on the stack, altering it, and then popping the old value from the stack before returning. The pushing of register values has the effect of creating the portion of the stack frame labeled <a data-tooltip-position=\"top\" aria-label=\"Pasted image 20250904115435.png\" data-href=\"Pasted image 20250904115435.png\" href=\"canekzamudio.com/assets/pasted-image-20250904115435.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Saved registers</a> in Figure 3.25. With this convention, the code for P can safely store a value in a callee-saved register (after saving the previous value on the stack, of course), call Q, and then use the value in the register without risk of it having been corrupted. <br>All other registers, except for the <a data-tooltip-position=\"top\" aria-label=\"3.7.1 The Run-Time Stack\" data-href=\"3.7.1 The Run-Time Stack\" href=\"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">stack</a> pointer %rsp, are classified as caller-saved registers. This means that they can be modified by any function. The name caller saved can be understood in the context of a procedure P having some local data in such a register and calling procedure Q. Since Q is free to alter this register, it is incumbent upon P (the caller) to first save the data before it makes the call. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Callee-saved registers","level":7,"id":"Callee-saved_registers_0"},{"heading":"Caller-saved registers","level":8,"id":"Caller-saved_registers_0"}],"links":["cs_app/glossary/cpu.html","indexes/coding/c/pointers.html","assets/pasted-image-20250904115435.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.0-accessing-information.html","pathToRoot":"../../..","attachments":["cs_app/glossary/register.html","assets/pasted-image-20250817140128.png"],"createdTime":1762228977404,"modifiedTime":1755460276786,"sourceSize":14,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.0 Accessing Information.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.0-accessing-information.html","showInTree":true,"treeOrder":93,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html":{"title":"3.4.1 Operand Specifiers","icon":"","description":"Operands - asMost instructions have one or more operands specifying the source values to use in performing an operation and the destination location into which to place the result.Source values can be given as constants or read from registers or memory. Results can be stored in either registers or memory. Thus, the different operand possibilities can be classified into three types\nimmediate, is for constant values. In ATT format assembly code, these are written with a \"$\" followed by an integer using standard C notation -i.e., $-577 or $0x1F. Different instructions allow different ranges of immediate values; the assembler will automatically select the most compact way of encoding a value.\n<a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a>, denotes the contents of a register, one of the 16-, 8-, 4-, 2-, or 1-byte low-order portions of the registers for operands having 64, 32, 16, or 8 bits, respectively. n Figure 3.3, we use the notation to denote an arbitrary register and indicate its value with the reference , viewing the set of registers as an array indexed by register identifiers.\nmemory reference, in this we access some memory location according to a computed address, often called the effective address. Since we view the memory as a large array of bytes, we use the notation to denote a reference to the -byte value stored in memory starting at address Addr. To simplify things, we will generally drop the subscript .<br>\n<img alt=\"Pasted image 20250817144946.png\" src=\"canekzamudio.com/assets/pasted-image-20250817144946.png\" target=\"_self\" style=\"width: 550px; max-width: 100%;\">\nThere are many different addressing modes allowing different forms of memory references. The most general form is shown at the bottom of the table with syntax . Such a reference has four components: an immediate offset , a base register , an index register , and a scale factor , where must be 1, 2, 4, or 8. Both the base and index must be 64-bit registers. The effective address is computed as . This general form is often seen when referencing elements of arrays. The other forms are simply special cases of this general form where some of the components are omitted.<br>\n<img alt=\"Pasted image 20250817164321.png\" src=\"canekzamudio.com/assets/pasted-image-20250817164321.png\" target=\"_self\">\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/glossary/register.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html","pathToRoot":"../../..","attachments":["indexes/coding/assembly-x86/operands-as.md","assets/pasted-image-20250817144946.png","assets/pasted-image-20250817164321.png"],"createdTime":1762228977173,"modifiedTime":1755713595081,"sourceSize":19,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.1 Operand Specifiers.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html","showInTree":true,"treeOrder":94,"backlinks":["cs_app/glossary/program-stack.html"],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.2-data-movement-instructions.html":{"title":"3.4.2 Data Movement Instructions","icon":"","description":"MOVThere are many different data movement instructions, differing in their source and destination types, what conversions they perform, and other side effects they may have.We group the many different instructions into instruction classes, where the instructions in a class perform the same operation but with different operand sizes.The mov class instructions copy data from a source location to a destination location, without any transformation. The class consists of four instructions:\nmovb\nmovw\nmovl\nmovq\nThese four have similar effects; they differ primarily in that they operate on data of different sizes: 1, 2, 4, and 8 bytes, respectively.\n<img alt=\"Pasted image 20250818123607.png\" src=\"canekzamudio.com/assets/pasted-image-20250818123607.png\" target=\"_self\" style=\"width: 450px; max-width: 100%;\"><br>\nThe source operand designates a value that is immediate, stored in a <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a>, or stored in memory\nThe destination operand designates a location that is either a register or a memory address. Copying a value from one memory location to another requires two instructions:\nThe first to load the source value into a register\nThe second to write this register value to the destination\nFor most cases the MOV instructions will only update the specific register bytes or memory locations indicated by the destination operand. The only exception is that when movl has a register as the destination, it will also set the high-order 4 bytes of the register to 0.<br>\n<img alt=\"Pasted image 20250818124727.png\" src=\"canekzamudio.com/assets/pasted-image-20250818124727.png\" target=\"_self\"><br>\nA final instruction movabsq is for dealing with 64-bit immediate data. The regular movq instruction can only have immediate source operands that can be represented as 32-bit <a data-tooltip-position=\"top\" aria-label=\"2.2.3 Two's-Complement Encodings\" data-href=\"2.2.3 Two's-Complement Encodings\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.3-two's-complement-encodings.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">two's complement</a> numbers. This value is then sign extended to produce the 64-bit value for the destination. The movabsq instruction can have an arbitrary 64-bit immediate value as its source operand and can only have a register as a destination<br>This class is used when copying a smaller source value (in a register or memory address) to a larger destination(<a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a>).<br>\n<img alt=\"Pasted image 20250818133441.png\" src=\"canekzamudio.com/assets/pasted-image-20250818133441.png\" target=\"_self\">\nInstructions in the MOVZ class fill out the remaining bytes of the destination with zeros, while those in the MOVS class fill them out by sign extension, replicating copies of the most significant bit of the source operand.Each instruction name has size designators as its final two characters, the first specifying the source size, and the second specifying the destination size.Note the absence of an explicit instruction to zero-extend a 4-byte source value to an 8-byte destination, this doesn't exist. Instead, this type of data movement can be implemented using a movl instruction having a register as the destination.<br><img alt=\"Pasted image 20250818134520.png\" src=\"canekzamudio.com/assets/pasted-image-20250818134520.png\" target=\"_self\"><br>\nFigure above also documents the ctlq instruction. This instruction has no operands, it always uses <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a> %eax as its source and %rax as the destination for the sign-extended result. It has the exact same effect as the instruction movslq %eax, %rax, but it has a more compact encoding.\nx86 imposes the restriction that a move instruction cannot have both operands refer to memory locations\nUnderstanding how data movement changes a destination register\nThere are two different conventions regarding wheter and how data movement instructions modify the upper bytes of a destination register. This distinction is illustrated by the following code sequence:<br>\n<img alt=\"Pasted image 20250818135026.png\" src=\"canekzamudio.com/assets/pasted-image-20250818135026.png\" target=\"_self\">\nInstruction on line 1 initializes register %rax to the pattern 0x0011223344556677. The remaining instructions have immediate value -1(0xFF...F) as their source values.\nThe movb instruction on line 2 sets the low-order byte of %rax to FF, while the movw instruction on line 3 sets the low-order 2 bytes to FFFF, with the remaining bytes unchanged. The movl instruction on line 4 sets the low-order 4 bytes to FFFFFFFF, but it also sets the high-order 4 bytes to 00000000. Finally, the movq instruction on line 5 sets the complete register to FFFFFFFFFFFFFFFF.\nComparing byte movement instructions\nThe following example illustrates how different data movement instructions either do or do not change the high-order bytes of the destination. Observe that the three byte-movement instructions movb, movsbq, and movzbq differ from each other in subtle ways.<br>\n<img alt=\"Pasted image 20250818141612.png\" src=\"canekzamudio.com/assets/pasted-image-20250818141612.png\" target=\"_self\">\nThe first two lines of the code initialize registers %rax and %dl to 0011223344556677 and AA, respectively. The remaining instructions all copy the low-order byte of %rdx to the low-order byte of %rax. The movb instruction (line 3) does not change the other bytes. The movsbq instruction (line 4) sets the other 7 bytes to either all ones or all zeros depending on the high-order bit of the source byte. Since hexadecimal A represents binary value 1010, sign extension causes the higher-order bytes to each be set to FF. The movzbq instruction (line 5) always sets the other 7 bytes to zero.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"MOV","level":7,"id":"MOV_0"},{"heading":"MOVZ","level":7,"id":"MOVZ_0"},{"heading":"MOVS","level":7,"id":"MOVS_0"}],"links":["cs_app/glossary/register.html","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.3-two's-complement-encodings.html","cs_app/glossary/register.html","cs_app/glossary/register.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.2-data-movement-instructions.html","pathToRoot":"../../..","attachments":["indexes/coding/assembly-x86/mov.md","assets/pasted-image-20250818123607.png","assets/pasted-image-20250818124727.png","assets/pasted-image-20250818133441.png","assets/pasted-image-20250818134520.png","assets/pasted-image-20250818135026.png","assets/pasted-image-20250818141612.png"],"createdTime":1762228976874,"modifiedTime":1755804001804,"sourceSize":8,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.2 Data Movement Instructions.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.2-data-movement-instructions.html","showInTree":true,"treeOrder":95,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.3-data-movement-example.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228977324,"modifiedTime":1755550933697,"sourceSize":1510,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.3 Data Movement Example.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.3-data-movement-example.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.4-pushing-and-popping-stack-data.html":{"title":"3.4.4 Pushing and Popping Stack Data","icon":"","description":"push &amp; popThese two data movement operations are used to push data onto and pop data from the <a data-href=\"program stack\" href=\"canekzamudio.com/cs_app/glossary/program-stack.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">program stack</a>.<br>\n<img alt=\"Pasted image 20250819150715.png\" src=\"canekzamudio.com/assets/pasted-image-20250819150715.png\" target=\"_self\">\nprogram stackA stack is a data structure where values can be added or deleted, but only according to a \"last-in, first-out\" discipline.<br>We add data to a stack via a <a data-tooltip-position=\"top\" aria-label=\"push &amp; pop\" data-href=\"push &amp; pop\" href=\"canekzamudio.com/indexes/coding/assembly-x86/push-&amp;-pop\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">push</a> operation and remove it via a <a data-tooltip-position=\"top\" aria-label=\"push &amp; pop\" data-href=\"push &amp; pop\" href=\"canekzamudio.com/indexes/coding/assembly-x86/push-&amp;-pop\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">pop</a> operation, with the property that the value popped will always be the value that was most recently pushed and is still on the stack.A stack can be implemented as an array, where we always insert and remove elements from one end of the array. This end is called the top of the stack. With x86, the program stack is stored in some region of memory.<br>\n<img alt=\"Pasted image 20250819153309.png\" src=\"canekzamudio.com/assets/pasted-image-20250819153309.png\" target=\"_self\" style=\"width: 550px; max-width: 100%;\">\nThe stack grows downward such that the top element of the stack has the lowest address of all stack elements. The stack pointer %rsp holds the address of the top stack element.<br>The pushq instruction provides the ability to push data onto the stack, while the popq instruction pops it. Each of these instructions takes a single <a data-tooltip-position=\"top\" aria-label=\"3.4.1 Operand Specifiers\" data-href=\"3.4.1 Operand Specifiers\" href=\"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">operand</a>, the data source for pushing and the data destination por popping.Pushing a quad word value onto the stack involves first decrementing the stack pointer by 8 and then writing the value at the new top-of-stack address. Therefore, the behavior of the instruction pushq %rbp is equivalent to this of the pair of instructions:subq $8, %rsp //Decrement stack pointer\nmovq %rbp, (%rsp) //Store %rbp on stack\nexcept that the pushq instruction is encoded in the machine code as a single byte, whereas the pair of instructions shown above requires a total of 8 bytes. The first two columns in Figure 3.9 illustrate the effect of executing the instruction pushq %rax when %rsp is 0x108 and %rax is 0x123. First %rsp is decremented by 8, giving 0x100, and then 0x123 is stored at memory address 0x100. Popping a quad word involves reading from the top-of-stack location and then incrementing the stack pointer by 8. Therefore, the instruction popq %rax is equivalent to the following pair of instructions:movq (%rsp), %rax //Read %rax from stack\naddq $8, %rsp //Increment stack pointer\nThe third column of Figure 3.9 illustrates the effect of executing the instruction popq %edx immediately after executing the pushq. Value 0x123 is read from memory and written to register %rdx. Register %rsp is incremented back to 0x108. As shown in the figure, the value 0x123 remains at memory location 0x104 until it is overwritten (e.g., by another push operation). However, the stack top is always considered to be the address indicated by %rsp. <br>Since the stack is contained in the same memory as the program code and other forms of program data, programs can access arbitrary positions within the stack using the standard memory addressing methods. For example, assuming the topmost element of the stack is a quad word, the instruction movq 8(%rsp),%rdx will copy the second quad word from the stack to <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a> %rdx.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/glossary/program-stack.html","indexes/coding/assembly-x86/push-&-pop.md","indexes/coding/assembly-x86/push-&-pop.md","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html","cs_app/glossary/register.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.4-pushing-and-popping-stack-data.html","pathToRoot":"../../..","attachments":["indexes/coding/assembly-x86/push-&-pop.md","assets/pasted-image-20250819150715.png","cs_app/glossary/program-stack.html","assets/pasted-image-20250819153309.png"],"createdTime":1762228977733,"modifiedTime":1755637455368,"sourceSize":15,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.4 Pushing and Popping Stack Data.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.4-pushing-and-popping-stack-data.html","showInTree":true,"treeOrder":97,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html"],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.0-arithmetic-and-logical-operations.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228980366,"modifiedTime":1755715196876,"sourceSize":1089,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.0 Arithmetic and Logical Operations.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.0-arithmetic-and-logical-operations.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.1-load-effective-address.html":{"title":"3.5.1 Load Effective Address","icon":"","description":"leaqThe load effective address instruction leaq is actually a variant of the <a data-tooltip-position=\"top\" aria-label=\"MOV > MOV\" data-href=\"MOV#MOV\" href=\"canekzamudio.com/indexes/coding/assembly-x86/mov#MOV\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">movq</a> instruction. It has the form of an instruction that reads from memory to a register but it does not reference memory at all.Its first operand appears to be a memory reference, but instead of reading from the designated location, the instruction copies the effective address to the destination.<br>This instruction can be used to generate <a data-href=\"Pointers\" href=\"canekzamudio.com/indexes/coding/c/pointers.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Pointers</a> for later memory references. Arithmetic operations with leaq In addition, it can be used to compactly describe common arithmetic operations. For example, if register %rdx contains value , then the instruction leaq 7(%rdx,%rdx,4), %rax will set register %rax to .<br>\nCompilers often find clever uses of leaq that have nothing to do with effective address computations. The destination operand must be a <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a>.\nAs an illustration of the use of leaq in compiled code, consider the following C program:long scale(long x, long y, long z) { long t = x + 4 * y + 12 * z; return t;\n}\nWhen compiled, the arithmetic operations of the function are implemented by a sequence of three leaq functions://x in %rdi, y in %rsi, z in %rdx scale: leaq (%rdi, %rsi, 4), %rax // x + 4*y leaq (%rdx, %rdx, 2), %rdx // z + 2*z = 3*z leaq (%rax, %rdx, 4), %rax // (x+4*y) + 4*(3*z) = x + 4*y + 12*z\nThe ability of the leaq instruction to perform addition and limited forms of multiplication proves useful when compiling simple arithmetic expressions such as this example.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["indexes/coding/assembly-x86/mov.md#MOV","indexes/coding/c/pointers.html","cs_app/glossary/register.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.1-load-effective-address.html","pathToRoot":"../../..","attachments":["indexes/coding/assembly-x86/leaq.md"],"createdTime":1762228980095,"modifiedTime":1755642667144,"sourceSize":10,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.1 Load Effective Address.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.1-load-effective-address.html","showInTree":true,"treeOrder":100,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.2-unary-and-binary-operations.html":{"title":"3.5.2 Unary and Binary Operations","icon":"","description":"Unary Operations - as<img alt=\"Pasted image 20250819172841.png\" src=\"canekzamudio.com/assets/pasted-image-20250819172841.png\" target=\"_self\"><br>\nThese are unary operations, with the single <a data-tooltip-position=\"top\" aria-label=\"Operands - as\" data-href=\"Operands - as\" href=\"canekzamudio.com/indexes/coding/assembly-x86/operands-as\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">operand</a> serving as both source and destination. This operand can be either a <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a> or a memory location.<br>For example, the instruction incq (%rsp) causes the 8-byte element element on the top of the <a data-tooltip-position=\"top\" aria-label=\"program stack\" data-href=\"program stack\" href=\"canekzamudio.com/cs_app/glossary/program-stack.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">stack</a> to be incremented. This syntax is reminiscent of the C increment (++) and decrement (--) operators.Binary Operations - as<br><img alt=\"Pasted image 20250819173309.png\" src=\"canekzamudio.com/assets/pasted-image-20250819173309.png\" target=\"_self\"><br>\nIn binary operations the second <a data-tooltip-position=\"top\" aria-label=\"Operands - as\" data-href=\"Operands - as\" href=\"canekzamudio.com/indexes/coding/assembly-x86/operands-as\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">operand</a> is used as both a source and a destination. Note that the source operand is given first and the destination second. This looks peculiar for non-commutative operations. For example, the instruction subq %rax,%rdx decrements register %rdx by the value in %rax. (It helps to read the instruction as Subtract %rax from %rdx.) <br>The first operand can be either an immediate value, a <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a>, or a memory location. The second can be either a register or a memory location. As with the <a data-tooltip-position=\"top\" aria-label=\"MOV\" data-href=\"MOV\" href=\"canekzamudio.com/indexes/coding/assembly-x86/mov\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">MOV</a> instructions, the two operands cannot both be memory locations. Note that when the second operand is a memory location, the processor must read the value from memory, perform the operation, and then write the result back to memory.\nThis syntax is reminiscent of the C assignment operators, such as x -= y\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["indexes/coding/assembly-x86/operands-as.md","cs_app/glossary/register.html","cs_app/glossary/program-stack.html","indexes/coding/assembly-x86/operands-as.md","cs_app/glossary/register.html","indexes/coding/assembly-x86/mov.md"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.2-unary-and-binary-operations.html","pathToRoot":"../../..","attachments":["indexes/coding/assembly-x86/unary-operations-as.md","assets/pasted-image-20250819172841.png","indexes/coding/assembly-x86/binary-operations-as.md","assets/pasted-image-20250819173309.png"],"createdTime":1762228980382,"modifiedTime":1755713590761,"sourceSize":61,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.2 Unary and Binary Operations.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.2-unary-and-binary-operations.html","showInTree":true,"treeOrder":101,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.3-shift-operations.html":{"title":"3.5.3 Shift Operations","icon":"","description":"Shift Operations - as<img alt=\"Pasted image 20250820121350.png\" src=\"canekzamudio.com/assets/pasted-image-20250820121350.png\" target=\"_self\"><br>\nIn <a data-tooltip-position=\"top\" aria-label=\"2.1.9 Shift Operations in C\" data-href=\"2.1.9 Shift Operations in C\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">shift operations</a>, the shift amount is given first and the value to shift is given second, the different shift instructions can specify the shift amount either as an immediate value or with the single-byte <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a> %cl. (These instructions are unusual in only allowing this specific register as the operand.) In principle, having a 1-byte shift amount would make it possible to encode shift amounts ranging up to . With x86-64, a shift instruction operating on data values that are bits long determines the shift amount from the low-order bits of register %cl, where . The higher-order bits are ignored. So, for example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift by 63. There are two names for the left shift instruction: sal and shl. Both have the same effect, filling from the right with zeros. The right shift instructions differ in that sar performs an arithmetic shift (fill with copies of the sign bit), whereas shr performs a logical shift (fill with zeros). The destination operand of a shift operation can be either a register or a memory location.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html","cs_app/glossary/register.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.3-shift-operations.html","pathToRoot":"../../..","attachments":["indexes/coding/assembly-x86/shift-operations-as.md","assets/pasted-image-20250820121350.png"],"createdTime":1762228979830,"modifiedTime":1755713558243,"sourceSize":27,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.3 Shift Operations.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.3-shift-operations.html","showInTree":true,"treeOrder":102,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228980378,"modifiedTime":1755726648604,"sourceSize":4095,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.5 Special Arithmetic Operations.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228978062,"modifiedTime":1755801080929,"sourceSize":1608,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.1 Condition Codes.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.2-accessing-the-condition-codes.html":{"title":"3.6.2 Accessing the Condition Codes","icon":"","description":"Rather than reading the condition codes directly, there are three common ways of using the condition codes:\nWe can set a single byte to 0 or 1 depending on some combination of the condition codes.\nWe can conditionally jump to some other part of the program.\nWe can conditionally transfer data.\nSETThese instructions set a single byte to 0 or 1 depending on some combination of the <a data-tooltip-position=\"top\" aria-label=\"3.6.1 Condition Codes\" data-href=\"3.6.1 Condition Codes\" href=\"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">condition codes</a>, they differ from one another based on which combinations of condition codes they consider, as indicated by the different suffixes for the instruction names.\nIt is important to recognize that the suffixes for these instructions denote different<br>\nconditions and not different <a data-tooltip-position=\"top\" aria-label=\"Operands - as\" data-href=\"Operands - as\" href=\"canekzamudio.com/indexes/coding/assembly-x86/operands-as.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">operand</a> sizes. For example, instructions setl and setb denote set less and set below, not set long word or set byte.<br>A SET instruction has either one of the low-order single-byte <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a> elements or a single-byte memory location as its destination, setting this byte to either 0 or 1, we must also clear the high-order bits.<br>\n<img alt=\"Pasted image 20250821131150.png\" src=\"canekzamudio.com/assets/pasted-image-20250821131150.png\" target=\"_self\" style=\"width: 570px; max-width: 100%;\">\nA typical instruction sequence to compute the C expression a &lt; b, where a and b are both of type long, proceeds as follows:<br>\n<img alt=\"Pasted image 20250821131322.png\" src=\"canekzamudio.com/assets/pasted-image-20250821131322.png\" target=\"_self\"><br>\nNote the comparison order of the <a data-tooltip-position=\"top\" aria-label=\"CMP &amp; TEST\" data-href=\"CMP &amp; TEST\" href=\"canekzamudio.com/indexes/coding/assembly-x86/cmp-&amp;-test.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">cmpq</a> instruction . Although the arguments are listed in the order %rsi (b), then %rdi (a), the comparison is really between a and b. Recall also, that the <a data-tooltip-position=\"top\" aria-label=\"MOV > MOVZ\" data-href=\"MOV#MOVZ\" href=\"canekzamudio.com/indexes/coding/assembly-x86/mov#MOVZ\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">movzbl</a> instruction (line 4) clears the upper 4 bytes of the entire register, %rax, as well. For some of the underlying machine instructions, there are multiple possible names, which we list as synonyms. For example, both setg (for set greater) and setnle (for set not less or equal) refer to the same machine instruction.\nCompilers and disassemblers make arbitrary choices of which names to use.\nAlthough all arithmetic and logical operations set the condition codes, the descriptions of the different set instructions apply to the case where a comparison instruction has been executed, setting the condition codes according to the computation t = a-b.<br>\nMore specifically, let a, b, and t be the integers represented in <a data-tooltip-position=\"top\" aria-label=\"2.2.3 Two's-Complement Encodings\" data-href=\"2.2.3 Two's-Complement Encodings\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.3-two's-complement-encodings.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">two's complement</a>\nform by variables a, b, and t, respectively, and so , where depends on the sizes associated with a and b.Consider the sete instruction, When a = b, we will have t = 0, and hence the zero flag indicates equality","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html","indexes/coding/assembly-x86/operands-as.html","cs_app/glossary/register.html","indexes/coding/assembly-x86/cmp-&-test.html","indexes/coding/assembly-x86/mov.md#MOVZ","cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.3-two's-complement-encodings.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.2-accessing-the-condition-codes.html","pathToRoot":"../../..","attachments":["indexes/coding/assembly-x86/set.md","assets/pasted-image-20250821131150.png","assets/pasted-image-20250821131322.png"],"createdTime":1762228977768,"modifiedTime":1755803089807,"sourceSize":349,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.2 Accessing the Condition Codes.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.2-accessing-the-condition-codes.html","showInTree":true,"treeOrder":106,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.3-jump-instructions.html":{"title":"3.6.3 Jump Instructions","icon":"","description":"JUMPA jump instruction can cause the execution to switch to a completely new position in the program. These jump destinations are generally indicated in assembly code by a labelConsider the following assembly-code sequence:\n<img alt=\"Pasted image 20250821143128.png\" src=\"canekzamudio.com/assets/pasted-image-20250821143128.png\" target=\"_self\">\nThe instruction jmp .L1 will cause the program to skip over the movq instruction and instead resume execution with the popq instruction. In generating the object-code file, the assembler determines the addresses of all labeled instructions and encodes the jump targets (the addresses of the destination instructions) as part of the jump instructions.<br>\n<img alt=\"Pasted image 20250821143052.png\" src=\"canekzamudio.com/assets/pasted-image-20250821143052.png\" target=\"_self\" style=\"width: 600px; max-width: 100%;\"><br>\nThe jmp instruction jumps unconditionally. It can be either a direct jump, where the jump target is encoded as part of the instruction, or an indirect jump, where the jump target is read from a <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a> or a memory location. Direct jumps are written in assembly code by giving a label as the jump target, for example, the label .L1 in the code shown. <br>Indirect jumps are written using * followed by an <a data-tooltip-position=\"top\" aria-label=\"Operands - as\" data-href=\"Operands - as\" href=\"canekzamudio.com/indexes/coding/assembly-x86/operands-as.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">operand specifier</a>. As examples, the instruction jmp *%rax uses the value in register %rax as the jump target, and the instruction jmp *(%rax) reads the jump target from memory, using the value in %rax as the read address. <br>The remaining jump instructions in the table are conditionalthey either jump or continue executing at the next instruction in the code sequence, depending on some combination of the <a data-tooltip-position=\"top\" aria-label=\"3.6.1 Condition Codes\" data-href=\"3.6.1 Condition Codes\" href=\"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">condition codes</a>. The names of these instructions and the conditions under which they jump match those of the <a data-tooltip-position=\"top\" aria-label=\"Indexes/Coding/Assembly x86/SET\" data-href=\"Indexes/Coding/Assembly x86/SET\" href=\"canekzamudio.com/indexes/coding/assembly-x86/set.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">SET</a> instructions. As with the SET instructions, some of the underlying machine instructions have multiple names. Conditional jumps can only be direct.3.6.4 Jump instruction Encodings<br>In <a data-href=\"assembly\" href=\"canekzamudio.com/assembly.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">assembly</a> code, <a data-href=\"JUMP\" href=\"canekzamudio.com/indexes/coding/assembly-x86/jump\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">JUMP</a> targets are written using symbolic labels. The assembler, and later the linker, generate the proper encodings of the jump targets. There are several different encodings for jumps, but some of the most commonly used ones are PC relative. That is, they encode the difference between the address of the target instruction and the address of the instruction immediately following the jump. These offsets can be encoded using 1, 2, or 4 bytes. A second encoding method is to give an absolute address, using 4 bytes to directly specify the target. The assembler and linker select the appropriate encodings of the jump destinations. As an example of PC-relative addressing, the following assembly code for a function was generated by compiling a file branch.c. It contains two jumps: the jmp instruction on line 2 jumps forward to a higher address, while the jg instruction on line 7 jumps back to a lower one. movq %rdi, %rax jmp .L2\n.L3: sarq %rax\n.L2: testq %rax, %rax jg .L3 rep; ret\nThe disassembled version of the .o format generated by the assembler is as follows:0: 48 89 f8 mov %rdi,%rax 3: eb 03 jmp 8 &lt;loop+0x8&gt;\n5: 48 d1 f8 sar %rax\n8: 48 85 c0 test %rax, %rax\nb: 7f f8 jg 5 &lt;loop+0x5&gt;\nd: f3 c3 repz retq\n<br>In this the jump targets are indicated as 0x8 and 0x5(the disassembler lists all number in <a data-tooltip-position=\"top\" aria-label=\"2.1.1 Hexadecimal Notation\" data-href=\"2.1.1 Hexadecimal Notation\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">hexadecimal</a>). Looking at the byte encodings of the instructions, we see that the target of the first jump instruction is encoded (in the second byte) as 0x03. Adding this to 0x5, the address of the following instruction, we get jump target address 0x8, the address of the instruction on line 4.Similarly, the target of the second jump is encoded as 0xf8(decimal -8), adding this to 0xd(decimal 13), the address of the instruction on line 6, we get 0x5, the address of the instruction on line 3The value of the program counter when performing PC-relative addressing is the address of the instruction following the jump, not that of the jump itself.This shows the disassembled version of the program after linking:4004d0: 48 89 f8 mov %rdi,%rax\n4004d3: eb 03 jmp 4004d8 &lt;loop+0x8&gt;\n4004d5: 48 d1 f8 sar %rax\n4004d8: 48 85 c0 test %rax,%rax\n4004db: 7f f8 jg 4004d5 &lt;loop+0x5&gt;\n4004dd: f3 c3 repz retq\nBy using a PC-relative encoding of the jump targets, the instructions can be compactly encoded(requiring just 2 bytes). and the object code can be shifted to different positions in memory without alteration.\nThe jump instructions provide a means to implement conditional execution (if), as well as several different loop constructs.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Encoding","level":7,"id":"Encoding_0"}],"links":["cs_app/glossary/register.html","indexes/coding/assembly-x86/operands-as.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html","indexes/coding/assembly-x86/set.html","assembly.html","indexes/coding/assembly-x86/jump.md","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.3-jump-instructions.html","pathToRoot":"../../..","attachments":["indexes/coding/assembly-x86/jump.md","assets/pasted-image-20250821143128.png","assets/pasted-image-20250821143052.png","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.4-jump-instruction-encodings.html"],"createdTime":1762228978803,"modifiedTime":1755807889381,"sourceSize":9,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.3 Jump Instructions.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.3-jump-instructions.html","showInTree":true,"treeOrder":107,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.4-jump-instruction-encodings.html":{"title":"3.6.4 Jump instruction Encodings","icon":"","description":"In <a data-href=\"assembly\" href=\"canekzamudio.com/assembly.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">assembly</a> code, <a data-href=\"JUMP\" href=\"canekzamudio.com/indexes/coding/assembly-x86/jump.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">JUMP</a> targets are written using symbolic labels. The assembler, and later the linker, generate the proper encodings of the jump targets. There are several different encodings for jumps, but some of the most commonly used ones are PC relative. That is, they encode the difference between the address of the target instruction and the address of the instruction immediately following the jump. These offsets can be encoded using 1, 2, or 4 bytes. A second encoding method is to give an absolute address, using 4 bytes to directly specify the target. The assembler and linker select the appropriate encodings of the jump destinations. As an example of PC-relative addressing, the following assembly code for a function was generated by compiling a file branch.c. It contains two jumps: the jmp instruction on line 2 jumps forward to a higher address, while the jg instruction on line 7 jumps back to a lower one. movq %rdi, %rax jmp .L2\n.L3: sarq %rax\n.L2: testq %rax, %rax jg .L3 rep; ret\nThe disassembled version of the .o format generated by the assembler is as follows:0: 48 89 f8 mov %rdi,%rax 3: eb 03 jmp 8 &lt;loop+0x8&gt;\n5: 48 d1 f8 sar %rax\n8: 48 85 c0 test %rax, %rax\nb: 7f f8 jg 5 &lt;loop+0x5&gt;\nd: f3 c3 repz retq\n<br>In this the jump targets are indicated as 0x8 and 0x5(the disassembler lists all number in <a data-tooltip-position=\"top\" aria-label=\"2.1.1 Hexadecimal Notation\" data-href=\"2.1.1 Hexadecimal Notation\" href=\"canekzamudio.com/cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">hexadecimal</a>). Looking at the byte encodings of the instructions, we see that the target of the first jump instruction is encoded (in the second byte) as 0x03. Adding this to 0x5, the address of the following instruction, we get jump target address 0x8, the address of the instruction on line 4.Similarly, the target of the second jump is encoded as 0xf8(decimal -8), adding this to 0xd(decimal 13), the address of the instruction on line 6, we get 0x5, the address of the instruction on line 3The value of the program counter when performing PC-relative addressing is the address of the instruction following the jump, not that of the jump itself.This shows the disassembled version of the program after linking:4004d0: 48 89 f8 mov %rdi,%rax\n4004d3: eb 03 jmp 4004d8 &lt;loop+0x8&gt;\n4004d5: 48 d1 f8 sar %rax\n4004d8: 48 85 c0 test %rax,%rax\n4004db: 7f f8 jg 4004d5 &lt;loop+0x5&gt;\n4004dd: f3 c3 repz retq\nBy using a PC-relative encoding of the jump targets, the instructions can be compactly encoded(requiring just 2 bytes). and the object code can be shifted to different positions in memory without alteration.\nThe jump instructions provide a means to implement conditional execution (if), as well as several different loop constructs.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["assembly.html","indexes/coding/assembly-x86/jump.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.4-jump-instruction-encodings.html","pathToRoot":"../../..","attachments":[],"createdTime":1762228978461,"modifiedTime":1755891828600,"sourceSize":2918,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.4 Jump instruction Encodings.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.4-jump-instruction-encodings.html","showInTree":true,"treeOrder":108,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.5-conditional-branches-with-conditional-control.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228979261,"modifiedTime":1756147649133,"sourceSize":2524,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.5 Conditional Branches with Conditional Control.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.5-conditional-branches-with-conditional-control.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.6-conditional-branches-with-conditional-moves.html":{"title":"3.6.6 Conditional Branches with Conditional Moves","icon":"","description":"As with <a data-tooltip-position=\"top\" aria-label=\"Indexes/Coding/Assembly x86/SET\" data-href=\"Indexes/Coding/Assembly x86/SET\" href=\"canekzamudio.com/indexes/coding/assembly-x86/set.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">SET</a> and <a data-href=\"JUMP\" href=\"canekzamudio.com/indexes/coding/assembly-x86/jump.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">JUMP</a> instructions, the outcome of these instructions depends on the values of the <a data-tooltip-position=\"top\" aria-label=\"3.6.1 Condition Codes\" data-href=\"3.6.1 Condition Codes\" href=\"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">condition codes</a>. The source value is read from either memory or the source <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a>, but it is copied to the destination only if the specified condition holds.Single byte conditional moves are not supportedThe conventional way to implement conditional operations is through a conditional transfer of control, this mechanism is simple and general, but it can be very inefficient on modern processors.An alternate strategy is through a conditional transfer of data. This approach computes both outcomes of a conditional operation and then selects one based on whether or not the condition holds.\nThis strategy makes sense only in restricted cases, but it can then be implemented by a simple conditional move instruction that is better matched to the performance characteristics of modern processors.(A) Shows code that can be compiled using a conditional move. The function computes the absolute value of its arguments and .<br>\n<img alt=\"Pasted image 20250825133158.png\" src=\"canekzamudio.com/assets/pasted-image-20250825133158.png\" target=\"_self\" style=\"width: 600px; max-width: 100%;\">\nFor this function, gcc generates the assembly code shown in (C), alike to cmovdiff (b). in (b) version, we can see that it computes both and , naming these rval and eval, respectively. It then tests whether is greater than or equal to , and if so, copies eval to rval before returning rval. <br>The assembly code on (C) follows the same logic. The key is that the single cmovge instruction (line 7) of the assembly code implements the conditional assignment (line 8) of cmovdiff. It will transfer the data from the source <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a> to the destination, only if the cmpq instruction of line 6 indicates that one value is greater than or equal to the other. Processors achieve high performance through pipelining, where an instruction is processed via a sequence of stages, each performing one small portion of the required operations. This approach achieves high performance by overlapping the steps of the successive instructions, such as fetching one instruction while performing the arithmetic operations for a previous instruction.\nTo do this requires being able to determine the sequence of instructions to be\nexecuted well ahead of time in order to keep the pipeline full of instructions to be executed. When the machine encounters a conditional jump (referred to as a branch), it cannot determine which way the branch will go until it has evaluated the branch condition.\nProcessors employ sophisticated branch prediction logic to try to guess whether or not\neach jump instruction will be followed. As long as it can guess reliably (modern microprocessor achieve success rates of 90%), the instruction pipeline will be kept full of instructions. Mispredicting a jump, on the other hand, requires that the processor discard much of the work it has already done on future instructions and then begin filling the pipeline with instructions starting at the correct location.\nSuch a misprediction can incur a serious penalty, say, 1530 clock cycles of wasted\neffort, causing a serious degradation of program performance.Determining the penalty time for a misprediction\nAssume the probability of misprediction is , the time to execute the code without misprediction is , and the misprediction penalty is . Then the average time to execute the code as a function of is . We are given and , the average time when , and we want to determine . Substituting into the equation, we get , and therefore . So, for and , we get . On the other hand, the code compiled using conditional moves requires around 8 clock cycles regardless of the data being tested. - The flow of control does not depend on data, and this makes it easier for the processor to keep its pipeline full. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["indexes/coding/assembly-x86/set.html","indexes/coding/assembly-x86/jump.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html","cs_app/glossary/register.html","cs_app/glossary/register.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.6-conditional-branches-with-conditional-moves.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250825133158.png"],"createdTime":1762228978424,"modifiedTime":1756316908079,"sourceSize":4189,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.6 Conditional Branches with Conditional Moves.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.6-conditional-branches-with-conditional-moves.html","showInTree":true,"treeOrder":110,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.7-loops.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228978015,"modifiedTime":1756323390434,"sourceSize":6109,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.7 Loops.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.7-loops.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.8-switch-statements.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228978631,"modifiedTime":1756962296127,"sourceSize":4451,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.8 Switch Statements.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.8-switch-statements.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7-procedures.html":{"title":"3.7 Procedures","icon":"","description":"Also called functions or methods, procedures provide a way to package code that implements some functionality with a designated set of arguments and an optional return value. Procedures come in many guises in different programming languagesfunctions, methods, subroutines, handlers, and so on but they all share a general set of features.There are many different attributes that must be handled when providing machine-level support for procedures. For discussion purposes, suppose procedure P calls procedure Q, and Q then executes and returns back to P. These actions involve one or more of the following mechanisms:\nPassing control. The program counter must be set to the starting address of the code for Q upon entry and then set to the instruction in P following the call to Q upon return.\nPassing data. P must be able to provide one or more parameters to Q, and Q must be able to return a value back to P.\nAllocating and deallocating memory. Q may need to allocate space for local variables when it begins and then free that storage before it returns.\nThe x86-64 implementation of procedures involves a combination of special instructions and a set of conventions on how to use the machine resources, such as the <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a>s and the program memory. Great effort has been made to minimize the overhead involved in invoking a procedure.\nAs a consequence, it follows what can be seen as a minimalist strategy, implementing only as much of the above set of mechanisms as is required for each particular procedure. In our presentation, we build up the different mechanisms step by step, first describing control, then data passing, and, finally, memory management.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/glossary/register.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7-procedures.html","pathToRoot":"../../..","attachments":[],"createdTime":1762228975642,"modifiedTime":1757007305832,"sourceSize":1727,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7 Procedures.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7-procedures.html","showInTree":true,"treeOrder":114,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.3-data-transfer.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.4-local-storage-on-the-stack.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.5-local-storage-in-registers.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.6-recursive-procedures.html"],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228975834,"modifiedTime":1760918048206,"sourceSize":3351,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.1 The Run-Time Stack.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.2-control-transfer.html":{"title":"3.7.2 Control Transfer","icon":"","description":"Passing control from function P to function Q involves simply setting the program counter (PC) to the starting address of the code for Q. This informations is recorded in x86 machines by invoking procedure Q with the instruction call Q.\ncallThis instruction pushes an address onto the stack and sets the PC to the beginning of Q. The pushed address is referred to as the return address and is computed as the address of the instruction immediately following the call instruction.\nThe counterpart instruction ret pops an address off the stack and sets the PC to .\n<img alt=\"Pasted image 20250904134956.png\" src=\"canekzamudio.com/assets/pasted-image-20250904134956.png\" target=\"_self\" style=\"width: 300px; max-width: 100%;\"><br>\nThe call instruction has a target indicating the address of the instruction where the called procedure starts. Like <a data-href=\"JUMP\" href=\"canekzamudio.com/indexes/coding/assembly-x86/jump.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">JUMP</a>s, a call can be either direct or indirect. The target of a direct call is given as a label, while the target of an indirect call is given by \"*\" followed by an <a data-tooltip-position=\"top\" aria-label=\"3.4.1 Operand Specifiers\" data-href=\"3.4.1 Operand Specifiers\" href=\"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">operand specifier</a>.<br>\n<img alt=\"Pasted image 20250904135618.png\" src=\"canekzamudio.com/assets/pasted-image-20250904135618.png\" target=\"_self\"><br>\n<img alt=\"Pasted image 20250904135903.png\" src=\"canekzamudio.com/assets/pasted-image-20250904135903.png\" target=\"_self\" style=\"width: 500px; max-width: 100%;\"><br>\nIn this code we can see that the call instruction with address 0x400563 in main calls function multstore. This status is shown in Figure 3.26(a), with the indicated values for the <a data-tooltip-position=\"top\" aria-label=\"program stack\" data-href=\"program stack\" href=\"canekzamudio.com/cs_app/glossary/program-stack.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">stack</a> pointer %rsp and the program counter %rip. The effect of the call is to push the return address 0x400568 onto the stack and to jump to the first instruction in function multstore, at address 0x0400540 (3.26(b)). The execution of function multstore continues until it hits the ret instruction at address 0x40054d. This instruction pops the value 0x400568 from the stack and jumps to this address, resuming the execution of main just after the call instruction (3.26(c)).<br>\n<img alt=\"Pasted image 20250904141340.png\" src=\"canekzamudio.com/assets/pasted-image-20250904141340.png\" target=\"_self\" style=\"width: 550px; max-width: 100%;\">\nEach instruction is identified by labels L1L2 (in leaf), T1T4 (in top), and M1M2 in main.\nPart (b) of the figure shows a detailed trace of the code execution, in which main calls top(100), causing top to call leaf(95). Function leaf returns 97 to top, which then return 194 to main.\nInstruction L1 of leaf sets %rax to 97, the value to be returned. Instruction L2 then\nreturns. It pops 0x400054e from the stack. In setting the PC to this popped value, control\ntransfers back to instruction T3 of top.\nThe program has successfully completed the call to leaf and returned to top.\nInstruction T3 sets %rax to 194, the value to be returned from top. Instruction T4 then returns. It pops 0x4000560 from the stack, thereby setting the PC to instruction M2 of main. The program has successfully completed the call to top and returned to main. We see that the stack pointer has also been restored to 0x7fffffffe820, the value it had before the call to top. We can see that this simple mechanism of pushing the return address onto the stack makes it possible for the function to later return to the proper point in the program.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["indexes/coding/assembly-x86/jump.html","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html","cs_app/glossary/program-stack.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.2-control-transfer.html","pathToRoot":"../../..","attachments":["indexes/coding/assembly-x86/call.md","assets/pasted-image-20250904134956.png","assets/pasted-image-20250904135618.png","assets/pasted-image-20250904135903.png","assets/pasted-image-20250904141340.png"],"createdTime":1762228908930,"modifiedTime":1757016007822,"sourceSize":259,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.2 Control Transfer.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.2-control-transfer.html","showInTree":true,"treeOrder":116,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.3-data-transfer.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228975377,"modifiedTime":1757049961003,"sourceSize":2964,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.3 Data Transfer.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.3-data-transfer.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.4-local-storage-on-the-stack.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228975057,"modifiedTime":1757182283611,"sourceSize":3536,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.4 Local Storage on the Stack.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.4-local-storage-on-the-stack.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.5-local-storage-in-registers.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228975317,"modifiedTime":1757193208068,"sourceSize":2853,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.5 Local Storage in Registers.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.5-local-storage-in-registers.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.6-recursive-procedures.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228975121,"modifiedTime":1757193557798,"sourceSize":1773,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.6 Recursive Procedures.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.6-recursive-procedures.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228976562,"modifiedTime":1760848923419,"sourceSize":1482,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.1 Array Basic Principles.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.2-pointer-arithmetic.html":{"title":"3.8.2 Pointer Arithmetic","icon":"","description":"C allows arithmetic on <a data-href=\"Pointers\" href=\"canekzamudio.com/indexes/coding/c/pointers.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Pointers</a>, where the computed value is scaled according to the size of the data type referenced by the pointer. That is, if is a pointer to data of type , and the value of is , then the expression has value , where is the size of data type .The unary operators '&amp; ' and '*' allow the generation and dereferencing of pointers. That is, for an expression denoting some object, is a pointer giving the address of the object. For an expression denoting an address, gives the value at that address. The expressions and $&amp;Expr$ are therefore equivalent.\nThe array subscripting operation can be applied to both arrays and pointers. The array\nreference is identical to the expression $(A+i)th array element and then accesses this memory location. Suppose the starting address of integer array and integer index are stored in registers %rdx and %rcx, respectively. The following are some expressions involving . Results are stored in either register %eax (for data) or register %rax (for pointers).<br>\n<img alt=\"Pasted image 20250908115829.png\" src=\"canekzamudio.com/assets/pasted-image-20250908115829.png\" target=\"_self\" style=\"width: 540px; max-width: 100%;\">\nOperations that return array values have type int, and hence involve 4-byte operations and registers. Those that return pointers have type int*, and hence involve 8-byte operations and registers\nThe final example shows that one can compute the difference of two pointers within the same data structure with the result being data type having type long and value equal to the difference of the two addresses divided by the size of the data type.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["indexes/coding/c/pointers.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.2-pointer-arithmetic.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250908115829.png"],"createdTime":1762228976109,"modifiedTime":1757354635157,"sourceSize":1674,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.2 Pointer Arithmetic.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.2-pointer-arithmetic.html","showInTree":true,"treeOrder":123,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.3-nested-arrays.html":{"title":"3.8.3 Nested Arrays","icon":"","description":"The declartaionint A[5][3];\nis equivalent to the declarationtypedef int row3_t[3];\nrow3_t A[5];\nData type row3_t is defined to be an array of three integers. Array contains five such elements, each requiring 12 bytes to store the three integers. The total array size is then Array can also be viewed as a two-dimensional array with five rows and three columns, referenced as through . The array elements are ordered in memory in row-major order, meaning all elements of row 0, which can be written , followed by all elements of row 1 (), and so on.\n<img alt=\"Pasted image 20250908121209.png\" src=\"canekzamudio.com/assets/pasted-image-20250908121209.png\" target=\"_self\" style=\"width: 350px; max-width: 100%;\"><br>\nViewing as an array of five elements, each of which is an array of three ints, we first have , followed by , and so on. To access elements of multidimensional arrays, the compiler generates code to compute the offset of the desired element and then uses one of the <a data-href=\"MOV\" href=\"canekzamudio.com/indexes/coding/assembly-x86/mov.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">MOV</a> instructions with the start of the array as the base address and the (possibly scaled) offset as an index. In general, for an array declared as array element is at memory address where is the size of data type in bytes. Consider the 5  3 integer array defined earlier. Suppose , , and are in registers %rdi, %rsi, and %rdx, respectively. Then array element A[i][j] can be copied to register %eax by the following code:<br>\n<img alt=\"Pasted image 20250908121735.png\" src=\"canekzamudio.com/assets/pasted-image-20250908121735.png\" target=\"_self\" style=\"width: 470px; max-width: 100%;\">\nThis code computes the element's address as using the scaling and addition capabilities of x86 address arithmetic.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["indexes/coding/assembly-x86/mov.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.3-nested-arrays.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250908121209.png","assets/pasted-image-20250908121735.png"],"createdTime":1762228976513,"modifiedTime":1760848779635,"sourceSize":1689,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.3 Nested Arrays.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.3-nested-arrays.html","showInTree":true,"treeOrder":124,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html"],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.4-fixed-size-arrays.html":{"title":"3.8.4 Fixed-Size Arrays","icon":"","description":"Suppose we declare data type fix_matrix to be 16 x 16 arrays of integers as follows:#define N 16 typedef int fix_matrix[N][N];\nThe code in Figure 3.37(a) computes element , of the product of arrays and that is, the inner product of row from and column from . This product is given by the formula <img alt=\"Pasted image 20250908124256.png\" src=\"canekzamudio.com/assets/pasted-image-20250908124256.png\" target=\"_self\" style=\"width: 550px; max-width: 100%;\"><br>\nGcc generates code that we then recoded into C, shown as function fix_prod_ele_opt in Figure(b). This code optimizes by removing the integer index and converts all array references to <a data-href=\"Pointers\" href=\"canekzamudio.com/indexes/coding/c/pointers.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Pointers</a> dereferences. This involves:\nGenerating a pointer, which we have named Aptr, that points to successive elements in row of Generating a pointer, which we have named Bptr, that points to successive elements in column of Generating a pointer, which we have named Bend, that equals the value Bptr will have when it is time to terminate the loop. The initial value for Aptr is the address of the first element of row of , given by the expression . The initial value for Bptr is the address of the first element of column of , given by the expression . The value for Bend is the index of what would be the ()st element in column of , given by the C expression .<br>This is the actual assembly code generated by gcc for function fix_ prod_ele. We see that four <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a>s are used as follows: %eax holds result, %rdi holds Aptr, %rcx holds Bptr, and %rsi holds Bend.# int fix_prod_ele_opt(fix_matrix A, fix_matrix B, long i, long k)\nA in %rdi, B in %rsi, i in %rdx, k in %rcx 1 fix_prod_ele:\n2 salq $6, %rdx # Compute 64 * i\n3 addq %rdx, %rdi # Compute Aptr = X_A + 64i = &amp;A[i][0]\n4 leaq (%rsi,%rcx,4), %rcx # Compute Bptr = x_b + 4k = &amp;B[0][k]\n5 leaq 1024(%rcx), %rsi # Compute Bend = x_B + 4k + 1024 = &amp;B[N][k]\n6 movl $0, %eax # Set result = 0\n7 .L7: # loop:\n8 movl (%rdi), %edx # Read *Aptr\n9 imull (%rcx), %edx # Multiply by *Bptr\n10 addl %edx, %eax # Add to result\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["indexes/coding/c/pointers.html","cs_app/glossary/register.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.4-fixed-size-arrays.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20250908124256.png"],"createdTime":1762228975938,"modifiedTime":1760848908534,"sourceSize":2275,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.4 Fixed-Size Arrays.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.4-fixed-size-arrays.html","showInTree":true,"treeOrder":125,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html"],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.5-variable-size-arrays.html":{"title":"3.8.5 Variable-Size Arrays","icon":"","description":"See in the book...","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.5-variable-size-arrays.html","pathToRoot":"../../..","attachments":[],"createdTime":1762228976162,"modifiedTime":1757528887699,"sourceSize":18,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.5 Variable-Size Arrays.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.5-variable-size-arrays.html","showInTree":true,"treeOrder":126,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html"],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.1-structures.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228981017,"modifiedTime":1760212328815,"sourceSize":2071,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.9 Heterogeneous Data Structures/3.9.1 Structures.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.1-structures.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.2-unions.html":{"title":"3.9.2 Unions","icon":"","description":"Unions provide a way to circumvent the type system of C, allowing a single object to be referenced according to multiple types. the syntax of a union declaration is identical to that for structures, but its semantics are very different. Rather than having the different fields reference different blocks of memory, they all reference the same block.\nConsider the next declarations:struct S3 { char c; int i[2]; double v;\n}; union U3 { char c; int i[2]; double v;\n};\nWhen compiled on an x86-64 Linux machine, the offsets of the fields, as well as the total size of data types S3 and U3, are as shown in the following table:For pointer of type union U3 *, references p-&gt;c, p-&gt;i[0], and p-&gt;v would all reference the beginning of the data structure. Observe also that the overall size of a union equals the maximum size of any of its fields.\nUnions can be useful in several contexts. One application is when we know in advance that the use of two different fields in a data structure will be mutually exclusive. Then, declaring these two fields as part of a union rather than a structure will reduce the total space allocated. For example, suppose we want to implement a binary tree data structure where each leaf node has two double data values and each internal node has pointers to two children but no data. If we declare this as:struct node_s { struct node_s *left; struct node_s *right; souble data[2];\n};\nthen every node requires 32 bytes, with half the bytes wasted for each type of node. On the other hand, if we declare a node as:union node_u { struct { union node_u *left; union node_u *right; } internal; double data[2];\n};\nthen every node will require just 16 bytes. If is a pointer to a node of type union node_u *, we would reference to the data of a leaf node as n-&gt;data[0] and n-&gt;data[1], and the children of an internal node as n-&gt;internal.left and n-&gt;internal.right.More on <a data-tooltip-position=\"top\" aria-label=\"CS_APP.pdf > page=299&amp;selection=0,0,0,18&amp;color=important\" data-href=\"CS_APP.pdf#page=299&amp;selection=0,0,0,18&amp;color=important\" href=\"canekzamudio.com/cs_app/cs_app.html#page=299&amp;selection=0,0,0,18&amp;color=important\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">CS_APP, p.299</a>...","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/cs_app.html#page=299&selection=0,0,0,18&color=important"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.2-unions.html","pathToRoot":"../../..","attachments":[],"createdTime":1762228980838,"modifiedTime":1760224602047,"sourceSize":2176,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.9 Heterogeneous Data Structures/3.9.2 Unions.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.2-unions.html","showInTree":true,"treeOrder":129,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.3-data-alignment.html":{"title":"","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"","pathToRoot":".","attachments":[],"createdTime":1762228980911,"modifiedTime":1760228366891,"sourceSize":4106,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.9 Heterogeneous Data Structures/3.9.3 Data Alignment.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.3-data-alignment.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.1-understanding-pointers.html":{"title":"3.10.1 Understanding Pointers","icon":"","description":"<a data-href=\"Pointers\" href=\"canekzamudio.com/indexes/coding/c/pointers.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Pointers</a> serve as a uniform way to generate references to elements within different data structures.This type indicates what kind of object the pointer points to, consider the following code:int *ip;\nchar **cpp;\nvariable ip is a pointer to an object of type int, while cpp is a pointer to an object that itself is a pointer to an object of type char. In general, if the object has type T , then the pointer has type *T. The special void * type represents a generic pointer.\nFor example, the malloc function returns a generic pointer, which is converted to a typed pointer via either an explicit cast or by the implicit casting of the assignment operation. Pointer types are not part of machine code; they are an abstraction provided by C to help programmers avoid addressing errors.This value is an address of some object of the designated type. The special NULL (0) value indicates that the pointer does not point anywhere.<br>This operator can be applied to any C expression that is categorized as an lvalue, meaning an expression that can appear on the left side of an assignment. Examples include variables and the elements of structures, unions, and arrays. We have seen that the machine code realization of the &amp; operator often uses the <a data-href=\"leaq\" href=\"canekzamudio.com/indexes/coding/assembly-x86/leaq.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">leaq</a> instruction to compute the expression value, since this instruction is designed to compute the address of a memory reference.The result is a value having the type associated with the pointer. Dereferencing is implemented by a memory reference, either storing to or retrieving from the specified address.The name of an array can be referenced (but not updated) as if it were a pointer variable. Array referencing (a[3]) has the exact same effect as pointer arithmetic and dereferencing ( *(a+3)). Both array referencing and pointer arithmetic require scaling the offsets by the object size. When we write an expression p+i for pointer p with value p, the resulting address is computed as , where is the size of the data type associated with p.One effect of casting is to change any scaling of pointer arithmetic. So, for example, if p is a pointer of type char* having value p, then the expression (int *) p+7 computes p + 28, while (int *) (p+7) computes p + 7. (Recall that casting has higher precedence than addition.)This provides a powerful capability for storing and passing references to code, which can be invoked in some other part of the program. For example, if we have a function defined by the proto-typeint fun(int x, int *p);\nthen we declare and assign a pointer fp to this function by the following code sequence:int (*fp)(int, int *);\nfp = fun;\nWe can then invoke the function using this pointer:int y = 1;\nint result = fp(3, &amp;y);\nThe value of a function pointer is the address of the first instruction in the machine-code representation of the function.Function pointers\nFor a declaration such as int (*f)(int*); it helps to read it starting from the inside (starting with f) and working outward. Thus, we see that f is a pointer, as indicated by (*f). It is a pointer to a function that has a single int * as an argument, as indicated by (*f)(int*). Finally, we see that it is a pointer to a function that takes an int * as an argument and returns int. The parentheses around *f are required, because otherwise the declaration int *f(int*); would be read as (int *) f(int*); That is, it would be interpreted as a function prototype, declaring a function f that has an int * as its argument and returns an int *.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Every pointer has an associated type","level":2,"id":"Every_pointer_has_an_associated_type_0"},{"heading":"Every pointer has a value","level":2,"id":"Every_pointer_has_a_value_0"},{"heading":"Pointers are created with the <code>&amp;</code> operator","level":2,"id":"Pointers_are_created_with_the_`&`_operator_0"},{"heading":"Pointers are dereferenced with the <code>*</code> operator","level":2,"id":"Pointers_are_dereferenced_with_the_`*`_operator_0"},{"heading":"<a data-tooltip-position=\"top\" aria-label=\"3.8.1 Array Basic Principles\" data-href=\"3.8.1 Array Basic Principles\" href=\"3.8.1 Array Basic Principles\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">Arrays</a> and pointers are closely related","level":2,"id":"[[3.8.1_Array_Basic_Principles|Arrays]]_and_pointers_are_closely_related_0"},{"heading":"Casting from one type of pointer to another changes its type but not its value","level":2,"id":"Casting_from_one_type_of_pointer_to_another_changes_its_type_but_not_its_value_0"},{"heading":"Pointers can also point to functions","level":2,"id":"Pointers_can_also_point_to_functions_0"}],"links":["indexes/coding/c/pointers.html","indexes/coding/assembly-x86/leaq.html","cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.1-understanding-pointers.html","pathToRoot":"../../..","attachments":[],"createdTime":1762228979088,"modifiedTime":1760593302879,"sourceSize":4060,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.1 Understanding Pointers.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.1-understanding-pointers.html","showInTree":true,"treeOrder":132,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.4-thwarting-buffer-overflow-attacks.html"],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html":{"title":"3.10.3 Out-of-Bounds Memory References and Buffer Overflow","icon":"","description":"C does not perform any bounds checking for array references, and local variables are stored on the <a data-tooltip-position=\"top\" aria-label=\"3.7.1 The Run-Time Stack\" data-href=\"3.7.1 The Run-Time Stack\" href=\"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">stack</a> along with state information such as saved <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a> values and return addresses. This combination can lead to serious program errors, where the state stored on the stack gets corrupted by a write to an out-of-bounds <a data-tooltip-position=\"top\" aria-label=\"3.8.1 Array Basic Principles\" data-href=\"3.8.1 Array Basic Principles\" href=\"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">array</a> element. When the program then tries to reload the register or execute a ret instruction with this corrupted state, things can go seriously wrong.Typically, some character array is allocated on the stack to hold a string, but the size of the string exceeds the space allocated for the array. This is demonstrated by the following program:/* Implementation of library function gets() */\nchar *gets(char *s)\n{ int c; char *dest = s; while ((c = getchar()) != \\n &amp;&amp; c != EOF) *dest++ = c; if (c == EOF &amp;&amp; dest == s) /* No characters read */ return NULL; *dest++ = \\0; /* Terminate string */ return s;\n} /* Read input line and write it back */\nvoid echo()\n{ char buf[8]; /* Way too small! */ gets(buf); puts(buf);\n}\nThe code demonstrates a serious problem with the function gets. It reads a line from the standard input, stopping when either a terminating newline character or some error condition is encountered. It copies this string to the location designated by argument s and terminates the string with a null character. We show the use of gets in the function echo, which simply reads a line from standard input and echos it back to standard output.<br>\n<img alt=\"Pasted image 20251018225151.png\" src=\"canekzamudio.com/assets/pasted-image-20251018225151.png\" target=\"_self\" style=\"width: 550px; max-width: 100%;\">\nThe problem with gets is that it has no way to determine whether sufficient space has been allocated to hold the entire string. In our echo example, we have purposely made the buffer very small, just eight characters long. Any string longer than seven characters will cause an out-of-bounds write.\nBy examining the assembly code generated by GCC for echo, we can infer how the stack is\norganized:// void echo() echo: subq $24, %rsp // Allocate 24 bytes on stack movq %rsp, %rdi // Compute buf as %rsp call gets // Call gets movq %rsp, %rdi // Compute buf as %rsp call puts // Call puts addq $24, %rsp // Deallocate stack space ret // Return\n<br>The program allocates 24 bytes on the stack by <a data-tooltip-position=\"top\" aria-label=\"3.4.4 Pushing and Popping Stack Data\" data-href=\"3.4.4 Pushing and Popping Stack Data\" href=\"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.4-pushing-and-popping-stack-data.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">subtracting</a> 24 from the stack pointer. Character buf is positioned at the top of the stack, as can be seen by the fact that %rsp is copied to %rdi to be used as the argument to the calls to both gets and puts. The 16 bytes between buf and the stored return pointer are not used. As long as the user types at most seven characters, the string returned by gets (including the terminating null) will fit within the space allocated for buf.\nA longer string, however, will cause gets to overwrite some of the information stored on the\nstack. As the string gets longer, the following information will get corrupted:If the stored value of the return address is corrupted then the ret instruction (line 8) will cause the program to jump to a totally unexpected location.\nA better version of echo involves using the function fgets, which includes as an argument a count on the maximum number of bytes to read.\n<br>Buffer Overflow working\nTypically, the program is fed with a string that contains the byte encoding of some executable code, called the exploit code, plus some extra bytes that overwrite the return address with a pointer to the exploit code. The effect of executing the ret instruction is then to jump to the exploit code.\nIn one form of attack, the exploit code then uses a system call to start up a <a data-href=\"Shell\" href=\"canekzamudio.com/cs_app/glossary/shell.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Shell</a> program, providing the attacker with a range of <a data-href=\"Operating System\" href=\"canekzamudio.com/cs_app/glossary/operating-system.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Operating System</a> functions\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Buffer Overflow","level":2,"id":"Buffer_Overflow_0"}],"links":["cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html","cs_app/glossary/register.html","cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.4-pushing-and-popping-stack-data.html","cs_app/glossary/shell.html","cs_app/glossary/operating-system.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20251018225151.png"],"createdTime":1762228979751,"modifiedTime":1760994768478,"sourceSize":4266,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.3 Out-of-Bounds Memory References and Buffer Overflow.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html","showInTree":true,"treeOrder":133,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.4-thwarting-buffer-overflow-attacks.html":{"title":"3.10.4 Thwarting Buffer Overflow Attacks","icon":"","description":"In order to insert exploit code into a system, the attacker needs to inject both the code as well as a pointer to this code as part of the attack string. Generating this <a data-tooltip-position=\"top\" aria-label=\"3.10.1 Understanding Pointers\" data-href=\"3.10.1 Understanding Pointers\" href=\"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.1-understanding-pointers.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">pointer</a> requires knowing the <a data-tooltip-position=\"top\" aria-label=\"3.7.1 The Run-Time Stack\" data-href=\"3.7.1 The Run-Time Stack\" href=\"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">stack</a> address where the string will be located. Historically, the stack addresses for a program were highly predictable. So if an attacker could determine the stack addresses used by a common <a data-tooltip-position=\"top\" aria-label=\"Web page, Website, Web server > Web Server\" data-href=\"Web page, Website, Web server#Web Server\" href=\"canekzamudio.com/indexes/web/web-page,-website,-web-server.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">web server</a>, it could devise an attack that would work on many machines.Stack randomization is to make the position of the stack vary from one run of a program to another. Thus, even if many machines are running identical code, they would all be using different stack addresses. This is implemented by allocating a random amount of space between and bytes on the stack at the start of a program, the addresses range of nearly .A persistent attacker can overcome randomization by brute force, repeatedly attempting attacks with different addresses. A common trick is to include a long sequence of nop(no operation) instructions before the actual exploit code. This only increments the program counter to the next instruction. As long as the attacker can guess an address somewhere within this sequence, the program will run through the sequence and then hit the exploit code.A corruption typically occurs when the program overruns the bounds of a local buffer. In C, there is no reliable way to prevent writing beyond the bounds of an array. instead, the program can attempt to detect when such a write has occurred before it can have any harmful effects.<br>GCC incorporates a mechanism known as stack protector into the generated code to detect buffer overruns. The idea is to store a special canary value in the stack frame between any local buffer and the rest of the stack state. This canary value (or guard value) is generated randomly each time the program runs, and so there is no easy way for an attacker to determine what it is. Before restoring the <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a> state and returning from the function, the program checks if the canary has been altered by some operation of this function or one that it has called. If so, the program aborts with an error.<br>\n<img alt=\"Pasted image 20251020154933.png\" src=\"canekzamudio.com/assets/pasted-image-20251020154933.png\" target=\"_self\" style=\"width: 530px; max-width: 100%;\">\nThe instruction argument %fs:40 is an indication that the canary value is read from memory using segmented addressing, by storing the canary in a special segment, it can be marked as \"read only\", so that an attacker cannot overwrite the stored canary value. Before restoring the register state and returning, the function compares the value stored at the stack location with the canary value (via a xorq instruction). If the two are identical, the xorq instruction will yield zero, and the function will complete in the normal fashion. A nonzero value indicates that the canary on the stack has been modified, and so the code will call an error routine. A final step is to eliminate the ability of an attacker to insert executable code into a system. One method is to limit which memory regions hold executable code. In typical programs, only the portion of memory holding the code generated by the compiler need be executable. The other portions can be restricted to allow just reading and writing. The hardware supports different forms of memory protection, indicating the forms of access allowed by both user programs and the operating system kernel, like an NX (for \"no-execute\") bit into the memory, by this the stack can be marked as being readable and writable, but not executable, and the checking of whether a page is executable is performed in hardware, with no penalty in efficiency.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Stack Randomization","level":2,"id":"Stack_Randomization_0"},{"heading":"nop sled","level":2,"id":"nop_sled_0"},{"heading":"Stack Corruption Detection","level":2,"id":"Stack_Corruption_Detection_0"},{"heading":"Limiting Executable Code Regions","level":2,"id":"Limiting_Executable_Code_Regions_0"}],"links":["cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.1-understanding-pointers.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html","indexes/web/web-page,-website,-web-server.html","cs_app/glossary/register.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.4-thwarting-buffer-overflow-attacks.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20251020154933.png"],"createdTime":1762228979250,"modifiedTime":1761016289859,"sourceSize":3847,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.4 Thwarting Buffer Overflow Attacks.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.4-thwarting-buffer-overflow-attacks.html","showInTree":true,"treeOrder":134,"backlinks":[],"type":"markdown"},"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.5-supporting-variable-size-stack-frames.html":{"title":"3.10.5 Supporting Variable-Size Stack Frames","icon":"","description":"Some functions require a variable amount of local storage. i.e., when the function calls alloca a standard library function that can allocate an arbitrary number of bytes of storage on the stack. It can also occur when the code declares a local array of variable size...","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.5-supporting-variable-size-stack-frames.html","pathToRoot":"../../..","attachments":[],"createdTime":1762228979571,"modifiedTime":1769034465014,"sourceSize":274,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.5 Supporting Variable-Size Stack Frames.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.5-supporting-variable-size-stack-frames.html","showInTree":true,"treeOrder":135,"backlinks":[],"type":"markdown"},"cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.1-programmer-visible-state.html":{"title":"4.1.1 Programmer-Visible State","icon":"","description":"Each instruction in a Y86-64 program can read and modify some part of the processor state. This is referred to as the programmer-visible state, where the \"programmer\" in this case is either someone writing programs in <a data-href=\"assembly\" href=\"canekzamudio.com/assembly.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">assembly</a> code or a compiler generating machine-level code.<br>Similar to x86-64. There are 15 program <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a>s, each of these stores a 64-bit word. Register %rsp is used as <a data-tooltip-position=\"top\" aria-label=\"3.7.1 The Run-Time Stack\" data-href=\"3.7.1 The Run-Time Stack\" href=\"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">stack</a> pointer by the <a data-tooltip-position=\"top\" aria-label=\"push &amp; pop\" data-href=\"push &amp; pop\" href=\"canekzamudio.com/indexes/coding/assembly-x86/push-&amp;-pop.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">push, pop</a>, <a data-href=\"call\" href=\"canekzamudio.com/indexes/coding/assembly-x86/call.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">call</a>, and return instructions. There are three single-bit condition codes, ZF, SF and OF, storing information about the effect of the most recent arithmetic or logical instruction. The program counter (PC) holds the address of the instruction currently being executed.<br>\n<img alt=\"Pasted image 20260122171049.png\" src=\"canekzamudio.com/assets/pasted-image-20260122171049.png\" target=\"_self\" style=\"width: 490px; max-width: 100%;\"><br>\nThe memory is conceptually a large array of bytes, holding both program and data. Y86-64 programs reference memory locations using <a data-tooltip-position=\"top\" aria-label=\"virtual memory\" data-href=\"virtual memory\" href=\"canekzamudio.com/cs_app/glossary/virtual-memory.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">virtual addresses</a>, a combination of hardware and <a data-href=\"Operating System\" href=\"canekzamudio.com/cs_app/glossary/operating-system.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Operating System</a> software translates these into the actual or physical, addresses indicating where the values are actually stored in memory.The status code Stat, indicates the overall state of program execution. It will indicate either normal operation or that some sort of exception has occurred, such as when an instruction attempts to read from an invalid memory address.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["assembly.html","cs_app/glossary/register.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html","indexes/coding/assembly-x86/push-&-pop.html","indexes/coding/assembly-x86/call.html","cs_app/glossary/virtual-memory.html","cs_app/glossary/operating-system.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.1-programmer-visible-state.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20260122171049.png"],"createdTime":1769122740669,"modifiedTime":1769123923434,"sourceSize":1383,"sourcePath":"CS_APP/IV. Processor Arch/4.1 Y86-64 ISA/4.1.1 Programmer-Visible State.md","exportPath":"cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.1-programmer-visible-state.html","showInTree":true,"treeOrder":138,"backlinks":[],"type":"markdown"},"cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.2-y86-64-instructions.html":{"title":"4.1.2 Y86-64 Instructions","icon":"","description":"<img alt=\"Pasted image 20260122172120.png\" src=\"canekzamudio.com/assets/pasted-image-20260122172120.png\" target=\"_self\" style=\"width: 560px; max-width: 100%;\">\n<br>The x86-64 <a data-href=\"MOV\" href=\"canekzamudio.com/indexes/coding/assembly-x86/mov.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">MOV</a>Q instruction is split into four different instructions: irmovq, rrmovq, mrmovq and rmmovq, explicitly indicating the form of the source and destination. The source is either immediate (i), register (r), or memory (m), it is designated by the first character in the instruction name. The destination is either register(r) or memory(m).\n<br>There are four integer operation instructions, as OPq. These are addq, subq, and xorq. They operate only on register data, whereas x86-64 also allows operations on memory data. These instructions set the three <a data-tooltip-position=\"top\" aria-label=\"3.6.1 Condition Codes\" data-href=\"3.6.1 Condition Codes\" href=\"canekzamudio.com/cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">condition codes</a> ZF, SF, and OF (zero, sign, and overflow).\n<br>The seven <a data-href=\"JUMP\" href=\"canekzamudio.com/indexes/coding/assembly-x86/jump.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">JUMP</a> instructions, as jXX are jmp, jle, jl, je, jne, jge, and jg. Branches are taken according to the type of branch and the settings of the condition codes.\nThere are six conditional move instructions as cmovXX: cmovle, cmovl, cmove, cmovne, cmovge, and cmovg. These have the same format as the register-register move instruction rrmovq, but destination register is updated only if the condition codes satisfy the required constraints.\nThe halt instruction stops instruction execution. x86-64 has a comparable instruction called hlt but common application programs are not permitted to use this instruction since it causes the entire system to suspend operation. In Y86-64, executing the halt instruction causes the processor to stop, with the status code set to HLT.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["indexes/coding/assembly-x86/mov.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html","indexes/coding/assembly-x86/jump.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.2-y86-64-instructions.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20260122172120.png"],"createdTime":1769123936187,"modifiedTime":1769130761191,"sourceSize":1544,"sourcePath":"CS_APP/IV. Processor Arch/4.1 Y86-64 ISA/4.1.2 Y86-64 Instructions.md","exportPath":"cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.2-y86-64-instructions.html","showInTree":true,"treeOrder":139,"backlinks":[],"type":"markdown"},"cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.3-instruction-encoding.html":{"title":"4.1.3 Instruction Encoding","icon":"","description":"Each instruction requires between 1 and 10 bytes, depending on which fields are required. All have an initial byte identifying the instruction type. This byte is split into two 4-bit parts, the high-order, or code part, and the low-order, or function part.\n<img alt=\"Pasted image 20260122194808.png\" src=\"canekzamudio.com/assets/pasted-image-20260122194808.png\" target=\"_self\" style=\"width: 550px; max-width: 100%;\"><br>\nEach of the 15 program <a data-href=\"register\" href=\"canekzamudio.com/cs_app/glossary/register.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">register</a>s has an associated register identifier (ID) ranging from 0 to same as in x86-64, the program registers are stored within the <a data-href=\"CPU\" href=\"canekzamudio.com/cs_app/glossary/cpu.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">CPU</a> in a register file, a small random access memory where the register IDs serve as addresses. ID is used when we need to indicate that no register should be accessed.<br>\n<img alt=\"Pasted image 20260122211607.png\" src=\"canekzamudio.com/assets/pasted-image-20260122211607.png\" target=\"_self\" style=\"width: 560px; max-width: 100%;\">\nSome instructions are just 1 byte long, but those that require operands have longer encodings. First, there can be an additional register specifier byte, dpecifying either one or two registers. These register fields are called rA and rB, they can specify the registers used for data sources and destinations, as well as the base register used in an address computation.<br>\n<img alt=\"Pasted image 20260122212355.png\" src=\"canekzamudio.com/assets/pasted-image-20260122212355.png\" target=\"_self\">\nSome instructions require an additional 8-byte constant word. This word can serve as an immediate data. As with x86-64, all integers have a little-endian encoding.Instruction byte encoding Let us generate the byte encoding of the instruction rmmovq %rsp, 0x123456789abcd (%rdx) in hexadecimal. We can see that rmmovq has initial byte 40, source register %rsp should be encoded in the rA field, and base register %rdx should be encoded in the rB field, so we get a register specifier byte of 42. Finally, the displacement is encoded in the 8-byte constant word . Combining these, we get an instruction encoding of:\n4042cdab896745230100 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/glossary/register.html","cs_app/glossary/cpu.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.3-instruction-encoding.html","pathToRoot":"../../..","attachments":["assets/pasted-image-20260122194808.png","assets/pasted-image-20260122211607.png","assets/pasted-image-20260122212355.png"],"createdTime":1769130874921,"modifiedTime":1769140058308,"sourceSize":1836,"sourcePath":"CS_APP/IV. Processor Arch/4.1 Y86-64 ISA/4.1.3 Instruction Encoding.md","exportPath":"cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.3-instruction-encoding.html","showInTree":true,"treeOrder":140,"backlinks":[],"type":"markdown"},"cs_app/iv.-processor-arch/intro.html":{"title":"Intro","icon":"","description":"A <a data-tooltip-position=\"top\" aria-label=\"CPU\" data-href=\"CPU\" href=\"canekzamudio.com/cs_app/glossary/cpu.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">processor</a> must execute a sequence of instructions, where each instruction performs some priomitive operation. An instruction is encoded in binary form as a sequence of 1 or more bytes. The instructions supported by a particular processor and their byte-level encodings are known as its instruction set architecture (ISA).Different \"families\" of processors, such as x86-64, have different ISAs, there are many different models of processors within a single family. Each manufacturer producesprocessors of ever-growing performance and complex, but the different models remain compatible at the ISA level. Thus the ISA provides a conceptual layer of abstraction between compiler writers, who need only know what instructions are permitted and how they are encoded, and processors designers, who must build machines that execute those instructions.Note\nThe actual way a modern processor operates can be quite different from the model of computation implied by the ISA. The ISA model would seem to imply sequential instruction execution, wherre each instruction is fetched and executed to completion before the next one begins. By executing different parts of multiple instructions simultaneously, the processor can achieve higher performance than if it executed just one instruction at a time. Special mechanisms are used to make sure the processor computes the same results as it would with sequential execution.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["cs_app/glossary/cpu.html"],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/iv.-processor-arch/intro.html","pathToRoot":"../..","attachments":[],"createdTime":1769035526897,"modifiedTime":1769036296774,"sourceSize":1453,"sourcePath":"CS_APP/IV. Processor Arch/Intro.md","exportPath":"cs_app/iv.-processor-arch/intro.html","showInTree":true,"treeOrder":141,"backlinks":[],"type":"markdown"},"cs_app/cs_app.html":{"title":"CS_APP","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Canek","coverImageURL":"","fullURL":"canekzamudio.com/cs_app/cs_app.html","pathToRoot":"..","attachments":["cs_app/cs_app.html"],"createdTime":1762228984700,"modifiedTime":1755197586248,"sourceSize":4829329,"sourcePath":"CS_APP/CS_APP.pdf","exportPath":"cs_app/cs_app.html","showInTree":true,"treeOrder":142,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.2-unions.html"],"type":"attachment"},"indexes/cryptography/cbc-cyber-block-chaining.html":{"title":"CBC - Cyber-Block Chaining","icon":"","description":"This is what ensures that no two blocks (even if they contain identical plaintext) will encrypt to the same ciphertext. It does this by mixing the ciphertext from the previous round into the plaintext of the next round using the XOR operator. In mathematical notation:\nLet = the plaintext, and = the plaintext of block .\nLet = the corresponding ciphertext, and = the ciphertext of block .\nLet = the number of blocks ( and have the same number of blocks by definition).\nLet = the initialization vector - a random string - frequently (incorrectly) set to all zeroes.\nLet = a single-block encryption operation (any block encryption algorithm, such as AES or DES, it doesn't matter which), with some unique and unknown (to the attacker) secret key (that we don't notate here).\nLet = the corresponding decryption operation.\nWe can define the encrypted ciphertexct -- in terms of the encryption algorithm, the plaintext, and the initialization vector:<img alt=\"Pasted image 20260128110417.png\" src=\"canekzamudio.com/assets/pasted-image-20260128110417.png\" target=\"_self\">Decryption is the opposite:<br><img alt=\"Pasted image 20260128110814.png\" src=\"canekzamudio.com/assets/pasted-image-20260128110814.png\" target=\"_self\"><br>\nOnce all blocks are decrypted, the <a data-href=\"Padding\" href=\"canekzamudio.com/indexes/cryptography/padding.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Padding</a> on the last block is validated.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["indexes/cryptography/padding.html"],"author":"Canek","coverImageURL":"canekzamudio.com","fullURL":"canekzamudio.com/indexes/cryptography/cbc-cyber-block-chaining.html","pathToRoot":"../..","attachments":["assets/pasted-image-20260128110417.png","assets/pasted-image-20260128110814.png"],"createdTime":1769618966679,"modifiedTime":1769620651574,"sourceSize":1512,"sourcePath":"Indexes/Cryptography/CBC - Cyber-Block Chaining.md","exportPath":"indexes/cryptography/cbc-cyber-block-chaining.html","showInTree":true,"treeOrder":145,"backlinks":[],"type":"markdown"}},"fileInfo":{"cs_app/glossary/adapter.html":{"createdTime":1762229051907,"modifiedTime":1751838737126,"sourceSize":175,"sourcePath":"CS_APP/Glossary/Adapter.md","exportPath":"cs_app/glossary/adapter.html","showInTree":true,"treeOrder":2,"backlinks":["cs_app/glossary/i-o-devices.html","cs_app/i.-computer-systems/1.8-systems-comunicate-with-other-systems-using-networks/1.8.0-systems-communicate-with-other-systems-using-networks.html"],"type":"markdown","data":null},"cs_app/glossary/alu.html":{"createdTime":1762229049262,"modifiedTime":1751838737094,"sourceSize":58,"sourcePath":"CS_APP/Glossary/ALU.md","exportPath":"cs_app/glossary/alu.html","showInTree":true,"treeOrder":3,"backlinks":["cs_app/glossary/cpu.html","cs_app/glossary/hyperthreading.html"],"type":"markdown","data":null},"cs_app/glossary/buses.html":{"createdTime":1762229052064,"modifiedTime":1751838737054,"sourceSize":450,"sourcePath":"CS_APP/Glossary/Buses.md","exportPath":"cs_app/glossary/buses.html","showInTree":true,"treeOrder":4,"backlinks":["cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html"],"type":"markdown","data":null},"cs_app/glossary/cache-memories.html":{"createdTime":1762229048949,"modifiedTime":1752364596404,"sourceSize":1375,"sourcePath":"CS_APP/Glossary/cache memories.md","exportPath":"cs_app/glossary/cache-memories.html","showInTree":true,"treeOrder":5,"backlinks":["cs_app/glossary/multi-core-processor.html","cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html"],"type":"markdown","data":null},"cs_app/glossary/concurrency.html":{"createdTime":1762229049673,"modifiedTime":1752615676565,"sourceSize":112,"sourcePath":"CS_APP/Glossary/concurrency.md","exportPath":"cs_app/glossary/concurrency.html","showInTree":true,"treeOrder":6,"backlinks":["cs_app/glossary/parallelism.html","cs_app/i.-computer-systems/1.9-important-themes/1.9.0-important-themes.html","cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html"],"type":"markdown","data":null},"cs_app/glossary/controller.html":{"createdTime":1762229051922,"modifiedTime":1751838737054,"sourceSize":220,"sourcePath":"CS_APP/Glossary/Controller.md","exportPath":"cs_app/glossary/controller.html","showInTree":true,"treeOrder":7,"backlinks":["cs_app/glossary/i-o-devices.html"],"type":"markdown","data":null},"cs_app/glossary/cpu.html":{"createdTime":1762229050732,"modifiedTime":1752361588877,"sourceSize":2158,"sourcePath":"CS_APP/Glossary/CPU.md","exportPath":"cs_app/glossary/cpu.html","showInTree":true,"treeOrder":8,"backlinks":["cs_app/glossary/cache-memories.html","cs_app/glossary/multi-core-processor.html","cs_app/glossary/processes.html","cs_app/glossary/register.html","cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html","cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.5-representing-code.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html","cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.3-data-alignment.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.3-instruction-encoding.html","cs_app/iv.-processor-arch/intro.html"],"type":"markdown","data":null},"cs_app/glossary/file.html":{"createdTime":1762228985144,"modifiedTime":1752604184596,"sourceSize":303,"sourcePath":"CS_APP/Glossary/file.md","exportPath":"cs_app/glossary/file.html","showInTree":true,"treeOrder":9,"backlinks":["cs_app/glossary/operating-system.html","cs_app/glossary/processes.html"],"type":"markdown","data":null},"cs_app/glossary/hyperthreading.html":{"createdTime":1762229051411,"modifiedTime":1752624269358,"sourceSize":963,"sourcePath":"CS_APP/Glossary/hyperthreading.md","exportPath":"cs_app/glossary/hyperthreading.html","showInTree":true,"treeOrder":10,"backlinks":["cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html"],"type":"markdown","data":null},"cs_app/glossary/i-o-devices.html":{"createdTime":1762229050321,"modifiedTime":1751838737106,"sourceSize":435,"sourcePath":"CS_APP/Glossary/I-O Devices.md","exportPath":"cs_app/glossary/i-o-devices.html","showInTree":true,"treeOrder":11,"backlinks":["cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html","cs_app/i.-computer-systems/1.8-systems-comunicate-with-other-systems-using-networks/1.8.0-systems-communicate-with-other-systems-using-networks.html"],"type":"markdown","data":null},"cs_app/glossary/isa-instruction-set-architecture.html":{"createdTime":1762229050574,"modifiedTime":1757563062724,"sourceSize":1355,"sourcePath":"CS_APP/Glossary/ISA - Instruction Set Architecture.md","exportPath":"cs_app/glossary/isa-instruction-set-architecture.html","showInTree":true,"treeOrder":12,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.1-machine-level-code.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html"],"type":"markdown","data":null},"cs_app/glossary/kernel.html":{"createdTime":1762229049797,"modifiedTime":1752373142933,"sourceSize":494,"sourcePath":"CS_APP/Glossary/kernel.md","exportPath":"cs_app/glossary/kernel.html","showInTree":true,"treeOrder":13,"backlinks":["cs_app/glossary/processes.html","cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html"],"type":"markdown","data":null},"cs_app/glossary/main-memory.html":{"createdTime":1762229050864,"modifiedTime":1751838737046,"sourceSize":731,"sourcePath":"CS_APP/Glossary/Main Memory.md","exportPath":"cs_app/glossary/main-memory.html","showInTree":true,"treeOrder":14,"backlinks":["cs_app/glossary/cpu.html","cs_app/glossary/cache-memories.html","cs_app/glossary/multi-core-processor.html","cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html","cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html","cs_app/i.-computer-systems/1.8-systems-comunicate-with-other-systems-using-networks/1.8.0-systems-communicate-with-other-systems-using-networks.html","cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.3-data-alignment.html"],"type":"markdown","data":null},"cs_app/glossary/multi-core-processor.html":{"createdTime":1762229050766,"modifiedTime":1758163434417,"sourceSize":566,"sourcePath":"CS_APP/Glossary/multi-core processor.md","exportPath":"cs_app/glossary/multi-core-processor.html","showInTree":true,"treeOrder":15,"backlinks":[],"type":"markdown","data":null},"cs_app/glossary/operating-system.html":{"createdTime":1762229051331,"modifiedTime":1753315216661,"sourceSize":998,"sourcePath":"CS_APP/Glossary/Operating System.md","exportPath":"cs_app/glossary/operating-system.html","showInTree":true,"treeOrder":16,"backlinks":["cs_app/glossary/kernel.html","cs_app/glossary/virtual-memory.html","cs_app/i.-computer-systems/1.7-os-manages-the-hardware/1.7.0-the-os-manages-the-hardware.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.0-information-storage.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.5-representing-code.html","cs_app/iii.-machine-lever-representation-of-programs/3.1-a-historical-perspective/3.0.0-machine-level-representation-of-programs.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html","cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.1-machine-level-code.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.1-programmer-visible-state.html"],"type":"markdown","data":null},"cs_app/glossary/parallelism.html":{"createdTime":1762229050172,"modifiedTime":1752622724150,"sourceSize":100,"sourcePath":"CS_APP/Glossary/Parallelism.md","exportPath":"cs_app/glossary/parallelism.html","showInTree":true,"treeOrder":17,"backlinks":["cs_app/i.-computer-systems/1.9-important-themes/1.9.0-important-themes.html","cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html"],"type":"markdown","data":null},"cs_app/glossary/processes.html":{"createdTime":1762228984073,"modifiedTime":1758164317809,"sourceSize":2828,"sourcePath":"CS_APP/Glossary/processes.md","exportPath":"cs_app/glossary/processes.html","showInTree":true,"treeOrder":18,"backlinks":[],"type":"markdown","data":null},"cs_app/glossary/program-stack.html":{"createdTime":1762229052442,"modifiedTime":1755815298270,"sourceSize":3023,"sourcePath":"CS_APP/Glossary/program stack.md","exportPath":"cs_app/glossary/program-stack.html","showInTree":true,"treeOrder":19,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.6-recursive-procedures.html"],"type":"markdown","data":null},"cs_app/glossary/register.html":{"createdTime":1762229050215,"modifiedTime":1757189827265,"sourceSize":1411,"sourcePath":"CS_APP/Glossary/register.md","exportPath":"cs_app/glossary/register.html","showInTree":true,"treeOrder":20,"backlinks":["cs_app/glossary/tib,-teb-&-peb.html","cs_app/glossary/program-stack.html","cs_app/glossary/threads.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.4-thwarting-buffer-overflow-attacks.html","cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.0-accessing-information.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.6-conditional-branches-with-conditional-moves.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.7-loops.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7-procedures.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.3-data-transfer.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.4-local-storage-on-the-stack.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.5-local-storage-in-registers.html","cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.4-fixed-size-arrays.html","cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.1-structures.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.1-programmer-visible-state.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.3-instruction-encoding.html"],"type":"markdown","data":null},"cs_app/glossary/register-file.html":{"createdTime":1762229049788,"modifiedTime":1751838736470,"sourceSize":143,"sourcePath":"CS_APP/Glossary/register file.md","exportPath":"cs_app/glossary/register-file.html","showInTree":true,"treeOrder":21,"backlinks":["cs_app/glossary/cpu.html","cs_app/glossary/cache-memories.html","cs_app/glossary/hyperthreading.html","cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html"],"type":"markdown","data":null},"cs_app/glossary/shell.html":{"createdTime":1762229051314,"modifiedTime":1752366890546,"sourceSize":325,"sourcePath":"CS_APP/Glossary/Shell.md","exportPath":"cs_app/glossary/shell.html","showInTree":true,"treeOrder":22,"backlinks":["cs_app/glossary/processes.html","cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.0-processors-read-and-interpret-instructions-stored-in-memory.html","cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html"],"type":"markdown","data":null},"cs_app/glossary/threads.html":{"createdTime":1762229049147,"modifiedTime":1758168321019,"sourceSize":1309,"sourcePath":"CS_APP/Glossary/threads.md","exportPath":"cs_app/glossary/threads.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/glossary/tib,-teb-&-peb.html":{"createdTime":1762229052544,"modifiedTime":1758255453732,"sourceSize":1016,"sourcePath":"CS_APP/Glossary/TIB, TEB & PEB.md","exportPath":"cs_app/glossary/tib,-teb-&-peb.html","showInTree":true,"treeOrder":24,"backlinks":[],"type":"markdown","data":null},"cs_app/glossary/transistor.html":{"createdTime":1762229049551,"modifiedTime":1760135980409,"sourceSize":180,"sourcePath":"CS_APP/Glossary/Transistor.md","exportPath":"cs_app/glossary/transistor.html","showInTree":true,"treeOrder":25,"backlinks":[],"type":"markdown","data":null},"cs_app/glossary/unicode.html":{"createdTime":1762229051875,"modifiedTime":1753042109232,"sourceSize":658,"sourcePath":"CS_APP/Glossary/Unicode.md","exportPath":"cs_app/glossary/unicode.html","showInTree":true,"treeOrder":26,"backlinks":[],"type":"markdown","data":null},"cs_app/glossary/virtual-memory.html":{"createdTime":1762229051315,"modifiedTime":1758166802612,"sourceSize":2905,"sourcePath":"CS_APP/Glossary/virtual memory.md","exportPath":"cs_app/glossary/virtual-memory.html","showInTree":true,"treeOrder":27,"backlinks":["cs_app/glossary/operating-system.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.0-information-storage.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.2-data-sizes.html","cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.1-machine-level-code.html","cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.1-programmer-visible-state.html"],"type":"markdown","data":null},"cs_app/i.-computer-systems/1.1-information-is-bits-+-context/1.1-information-is-bits-+-context.html":{"createdTime":1762228983942,"modifiedTime":1751838736418,"sourceSize":1130,"sourcePath":"CS_APP/I. Computer Systems/1.1 Information is Bits + Context/1.1 Information is Bits + Context.md","exportPath":"cs_app/i.-computer-systems/1.1-information-is-bits-+-context/1.1-information-is-bits-+-context.html","showInTree":true,"treeOrder":30,"backlinks":["cs_app/i.-computer-systems/1.2-programs-are-translated-by-other-programs-in-different-forms/1.2-programs-are-translated-by-other-programs-into-different-forms.html"],"type":"markdown","data":null},"cs_app/i.-computer-systems/1.2-programs-are-translated-by-other-programs-in-different-forms/1.2-programs-are-translated-by-other-programs-into-different-forms.html":{"createdTime":1762228984177,"modifiedTime":1751838736426,"sourceSize":2719,"sourcePath":"CS_APP/I. Computer Systems/1.2 Programs are Translated by other Programs in Different Forms/1.2 Programs Are Translated by Other Programs into Different Forms.md","exportPath":"cs_app/i.-computer-systems/1.2-programs-are-translated-by-other-programs-in-different-forms/1.2-programs-are-translated-by-other-programs-into-different-forms.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/i.-computer-systems/1.3-pays-to-understand-how-compilation-systems-work/1.3-it-pays-to-understand-how-compilation-systems-work.html":{"createdTime":1762228981914,"modifiedTime":1751838736438,"sourceSize":1894,"sourcePath":"CS_APP/I. Computer Systems/1.3 Pays to Understand How Compilation Systems Work/1.3 It pays to Understand How Compilation Systems Work.md","exportPath":"cs_app/i.-computer-systems/1.3-pays-to-understand-how-compilation-systems-work/1.3-it-pays-to-understand-how-compilation-systems-work.html","showInTree":true,"treeOrder":34,"backlinks":[],"type":"markdown","data":null},"cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.0-processors-read-and-interpret-instructions-stored-in-memory.html":{"createdTime":1762228982210,"modifiedTime":1751838736446,"sourceSize":570,"sourcePath":"CS_APP/I. Computer Systems/1.4 Processors Read and Interpret Instrucions Stored in Memory/1.4.0 Processors Read and Interpret Instructions Stored in Memory.md","exportPath":"cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.0-processors-read-and-interpret-instructions-stored-in-memory.html","showInTree":true,"treeOrder":36,"backlinks":[],"type":"markdown","data":null},"cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html":{"createdTime":1762228982367,"modifiedTime":1752362380381,"sourceSize":280,"sourcePath":"CS_APP/I. Computer Systems/1.4 Processors Read and Interpret Instrucions Stored in Memory/1.4.1 Hardware Organization of a System.md","exportPath":"cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html":{"createdTime":1762228982430,"modifiedTime":1752363668993,"sourceSize":1070,"sourcePath":"CS_APP/I. Computer Systems/1.5 Caches Matter/1.5.0 Caches Matter.md","exportPath":"cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/i.-computer-systems/1.6-storage-devices-form-a-hierarchy/1.6.1-storage-devices-form-a-hierarchy.html":{"createdTime":1762228982647,"modifiedTime":1752366379753,"sourceSize":621,"sourcePath":"CS_APP/I. Computer Systems/1.6 Storage Devices Form a Hierarchy/1.6.1 Storage Devices Form a Hierarchy.md","exportPath":"cs_app/i.-computer-systems/1.6-storage-devices-form-a-hierarchy/1.6.1-storage-devices-form-a-hierarchy.html","showInTree":true,"treeOrder":41,"backlinks":[],"type":"markdown","data":null},"cs_app/i.-computer-systems/1.7-os-manages-the-hardware/1.7.0-the-os-manages-the-hardware.html":{"createdTime":1762228983505,"modifiedTime":1752366765123,"sourceSize":285,"sourcePath":"CS_APP/I. Computer Systems/1.7 OS Manages the Hardware/1.7.0 The OS Manages the Hardware.md","exportPath":"cs_app/i.-computer-systems/1.7-os-manages-the-hardware/1.7.0-the-os-manages-the-hardware.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/i.-computer-systems/1.8-systems-comunicate-with-other-systems-using-networks/1.8.0-systems-communicate-with-other-systems-using-networks.html":{"createdTime":1762228982786,"modifiedTime":1752605076565,"sourceSize":773,"sourcePath":"CS_APP/I. Computer Systems/1.8 Systems Comunicate with Other Systems Using Networks/1.8.0 Systems Communicate with Other Systems Using Networks.md","exportPath":"cs_app/i.-computer-systems/1.8-systems-comunicate-with-other-systems-using-networks/1.8.0-systems-communicate-with-other-systems-using-networks.html","showInTree":true,"treeOrder":45,"backlinks":[],"type":"markdown","data":null},"cs_app/i.-computer-systems/1.9-important-themes/1.9.0-important-themes.html":{"createdTime":1762228983363,"modifiedTime":1752622722978,"sourceSize":768,"sourcePath":"CS_APP/I. Computer Systems/1.9 Important Themes/1.9.0 Important Themes.md","exportPath":"cs_app/i.-computer-systems/1.9-important-themes/1.9.0-important-themes.html","showInTree":true,"treeOrder":47,"backlinks":[],"type":"markdown","data":null},"cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html":{"createdTime":1762228983347,"modifiedTime":1752626680991,"sourceSize":3284,"sourcePath":"CS_APP/I. Computer Systems/1.9 Important Themes/1.9.2 Concurrency and Parallelism.md","exportPath":"cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html","showInTree":true,"treeOrder":48,"backlinks":[],"type":"markdown","data":null},"cs_app/i.-computer-systems/1.9-important-themes/1.9.3-the-importance-of-abstractions-in-computer-systems.html":{"createdTime":1762228982971,"modifiedTime":1755202058510,"sourceSize":923,"sourcePath":"CS_APP/I. Computer Systems/1.9 Important Themes/1.9.3 The Importance of Abstractions in Computer Systems.md","exportPath":"cs_app/i.-computer-systems/1.9-important-themes/1.9.3-the-importance-of-abstractions-in-computer-systems.html","showInTree":true,"treeOrder":49,"backlinks":[],"type":"markdown","data":null},"cs_app/i.-computer-systems/1.9-important-themes/amdahl's-law.html":{"createdTime":1762228983146,"modifiedTime":1752614384658,"sourceSize":2158,"sourcePath":"CS_APP/I. Computer Systems/1.9 Important Themes/Amdahl's Law.md","exportPath":"cs_app/i.-computer-systems/1.9-important-themes/amdahl's-law.html","showInTree":true,"treeOrder":50,"backlinks":["cs_app/i.-computer-systems/1.9-important-themes/1.9.0-important-themes.html"],"type":"markdown","data":null},"cs_app/i.-computer-systems/1.0-computer-systems.html":{"createdTime":1762228984101,"modifiedTime":1752627182902,"sourceSize":1646,"sourcePath":"CS_APP/I. Computer Systems/1.0 Computer Systems.md","exportPath":"cs_app/i.-computer-systems/1.0-computer-systems.html","showInTree":true,"treeOrder":51,"backlinks":[],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.0-information-storage.html":{"createdTime":1762229047436,"modifiedTime":1752641831778,"sourceSize":1571,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.0 Information Storage.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.0-information-storage.html","showInTree":true,"treeOrder":54,"backlinks":[],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html":{"createdTime":1762229047808,"modifiedTime":1752702331821,"sourceSize":2466,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.1 Hexadecimal Notation.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html","showInTree":true,"treeOrder":55,"backlinks":["cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.3-addressing-and-byte-ordering.html","cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.2-code-examples.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.4-jump-instruction-encodings.html","cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html"],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.2-data-sizes.html":{"createdTime":1762229049064,"modifiedTime":1752715432362,"sourceSize":1781,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.2 Data Sizes.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.2-data-sizes.html","showInTree":true,"treeOrder":56,"backlinks":["cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.1-integral-data-types.html"],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.3-addressing-and-byte-ordering.html":{"createdTime":1762229048004,"modifiedTime":1754869249755,"sourceSize":6912,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.3 Addressing and Byte Ordering.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.3-addressing-and-byte-ordering.html","showInTree":true,"treeOrder":57,"backlinks":["cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.4-representing-strings.html"],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.4-representing-strings.html":{"createdTime":1762229047601,"modifiedTime":1753037306456,"sourceSize":581,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.4 Representing Strings.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.4-representing-strings.html","showInTree":true,"treeOrder":58,"backlinks":[],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.5-representing-code.html":{"createdTime":1762229048309,"modifiedTime":1753042517336,"sourceSize":934,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.5 Representing Code.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.5-representing-code.html","showInTree":true,"treeOrder":59,"backlinks":[],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.6-intro-to-boolean-algebra.html":{"createdTime":1762229048670,"modifiedTime":1753210640634,"sourceSize":1478,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.6 Intro To Boolean Algebra.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.6-intro-to-boolean-algebra.html","showInTree":true,"treeOrder":60,"backlinks":["cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html"],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html":{"createdTime":1762229048100,"modifiedTime":1753386063393,"sourceSize":1305,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.7 Bitwise operators.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html","showInTree":true,"treeOrder":61,"backlinks":["cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.8-logical-operations-in-c.html"],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.8-logical-operations-in-c.html":{"createdTime":1762229048550,"modifiedTime":1769558307961,"sourceSize":678,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.8 Logical Operations in C.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.8-logical-operations-in-c.html","showInTree":true,"treeOrder":62,"backlinks":[],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html":{"createdTime":1762229048370,"modifiedTime":1753390507152,"sourceSize":1172,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.9 Shift Operations in C.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html","showInTree":true,"treeOrder":63,"backlinks":["cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.7-dividing-by-powers-of-2.html"],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.0-integer-representations.html":{"createdTime":1762229045349,"modifiedTime":1753487196042,"sourceSize":345,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.0 Integer Representations.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.0-integer-representations.html","showInTree":true,"treeOrder":65,"backlinks":[],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.1-integral-data-types.html":{"createdTime":1762229045859,"modifiedTime":1753488091594,"sourceSize":912,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.1 Integral Data Types.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.1-integral-data-types.html","showInTree":true,"treeOrder":66,"backlinks":[],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.2-unsigned-encodings.html":{"createdTime":1762229046107,"modifiedTime":1753494870647,"sourceSize":3019,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.2 Unsigned Encodings.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.2-unsigned-encodings.html","showInTree":true,"treeOrder":67,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html"],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.3-two's-complement-encodings.html":{"createdTime":1762229045599,"modifiedTime":1754426301250,"sourceSize":2952,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.3 Two's-Complement Encodings.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.3-two's-complement-encodings.html","showInTree":true,"treeOrder":68,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.0-arithmetic-and-logical-operations.html","cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html","cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html"],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.4-t2u-&-u2t.html":{"createdTime":1762229045931,"modifiedTime":1754453033710,"sourceSize":1285,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.4 T2U & U2T.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.4-t2u-&-u2t.html","showInTree":true,"treeOrder":69,"backlinks":["cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.5-signed-versus-unsigned-in-c.html"],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.5-signed-versus-unsigned-in-c.html":{"createdTime":1762229045092,"modifiedTime":1754455453994,"sourceSize":965,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.5 Signed versus Unsigned in C.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.5-signed-versus-unsigned-in-c.html","showInTree":true,"treeOrder":70,"backlinks":[],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.6-expanding-the-bit-representation-of-a-number.html":{"createdTime":1762229046392,"modifiedTime":1754505759240,"sourceSize":1387,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.6 Expanding the Bit representation of a Number.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.6-expanding-the-bit-representation-of-a-number.html","showInTree":true,"treeOrder":71,"backlinks":[],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.7-truncating-numbers.html":{"createdTime":1762229045326,"modifiedTime":1754509718477,"sourceSize":2452,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.7 Truncating Numbers.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.7-truncating-numbers.html","showInTree":true,"treeOrder":72,"backlinks":[],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.8-advice-on-signed-versus-unsigned.html":{"createdTime":1762229045939,"modifiedTime":1754512892645,"sourceSize":1065,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.8 Advice on Signed versus Unsigned.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.8-advice-on-signed-versus-unsigned.html","showInTree":true,"treeOrder":73,"backlinks":[],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.1-unsigned-addition.html":{"createdTime":1762229046899,"modifiedTime":1769564716236,"sourceSize":4113,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.1 Unsigned Addition.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.1-unsigned-addition.html","showInTree":true,"treeOrder":75,"backlinks":[],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.2-two's-complement-addition.html":{"createdTime":1762229047202,"modifiedTime":1755539953793,"sourceSize":2748,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.2 Two's-Complement Addition.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.2-two's-complement-addition.html","showInTree":true,"treeOrder":76,"backlinks":[],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.3-two's-complement-negation.html":{"createdTime":1762229046584,"modifiedTime":1754620643437,"sourceSize":550,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.3 Two's Complement Negation.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.3-two's-complement-negation.html","showInTree":true,"treeOrder":77,"backlinks":[],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.4-unsigned-multiplication.html":{"createdTime":1762229047566,"modifiedTime":1754621522254,"sourceSize":696,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.4 Unsigned Multiplication.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.4-unsigned-multiplication.html","showInTree":true,"treeOrder":78,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html"],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.5-two's-complement-multiplication.html":{"createdTime":1762229046795,"modifiedTime":1754693257982,"sourceSize":1029,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.5 Two's-complement multiplication.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.5-two's-complement-multiplication.html","showInTree":true,"treeOrder":79,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html"],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.6-multiplying-by-constants.html":{"createdTime":1762229046602,"modifiedTime":1754702290049,"sourceSize":4404,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.6 Multiplying by Constants.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.6-multiplying-by-constants.html","showInTree":true,"treeOrder":80,"backlinks":[],"type":"markdown","data":null},"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.7-dividing-by-powers-of-2.html":{"createdTime":1762229047079,"modifiedTime":1754709424619,"sourceSize":3538,"sourcePath":"CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.7 Dividing by Powers of 2.md","exportPath":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.7-dividing-by-powers-of-2.html","showInTree":true,"treeOrder":81,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.1-a-historical-perspective/3.0.0-machine-level-representation-of-programs.html":{"createdTime":1762228981914,"modifiedTime":1755198157878,"sourceSize":727,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.1 A Historical Perspective/3.0.0 Machine Level Representation of Programs.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.1-a-historical-perspective/3.0.0-machine-level-representation-of-programs.html","showInTree":true,"treeOrder":84,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.0-program-encodings.html":{"createdTime":1762228981153,"modifiedTime":1755201813177,"sourceSize":1567,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.0 Program Encodings.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.0-program-encodings.html","showInTree":true,"treeOrder":86,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.1-machine-level-code.html":{"createdTime":1762228981645,"modifiedTime":1755203902402,"sourceSize":3162,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.1 Machine-Level Code.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.1-machine-level-code.html","showInTree":true,"treeOrder":87,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.2-code-examples.html":{"createdTime":1762228981569,"modifiedTime":1755286793844,"sourceSize":4240,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.2 Code Examples.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.2-code-examples.html","showInTree":true,"treeOrder":88,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.3-notes-on-formatting.html":{"createdTime":1762228981422,"modifiedTime":1755454163332,"sourceSize":1129,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.3 Notes on Formatting.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.3-notes-on-formatting.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.3-data-formats/3.3.0-data-formats.html":{"createdTime":1762228976878,"modifiedTime":1755459766783,"sourceSize":1596,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.3 Data Formats/3.3.0 Data Formats.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.3-data-formats/3.3.0-data-formats.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.0-accessing-information.html":{"createdTime":1762228977404,"modifiedTime":1755460276786,"sourceSize":14,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.0 Accessing Information.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.0-accessing-information.html","showInTree":true,"treeOrder":93,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html":{"createdTime":1762228977173,"modifiedTime":1755713595081,"sourceSize":19,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.1 Operand Specifiers.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html","showInTree":true,"treeOrder":94,"backlinks":["cs_app/glossary/program-stack.html"],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.2-data-movement-instructions.html":{"createdTime":1762228976874,"modifiedTime":1755804001804,"sourceSize":8,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.2 Data Movement Instructions.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.2-data-movement-instructions.html","showInTree":true,"treeOrder":95,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.3-data-movement-example.html":{"createdTime":1762228977324,"modifiedTime":1755550933697,"sourceSize":1510,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.3 Data Movement Example.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.3-data-movement-example.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.4-pushing-and-popping-stack-data.html":{"createdTime":1762228977733,"modifiedTime":1755637455368,"sourceSize":15,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.4 Pushing and Popping Stack Data.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.4-pushing-and-popping-stack-data.html","showInTree":true,"treeOrder":97,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html"],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.0-arithmetic-and-logical-operations.html":{"createdTime":1762228980366,"modifiedTime":1755715196876,"sourceSize":1089,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.0 Arithmetic and Logical Operations.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.0-arithmetic-and-logical-operations.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.1-load-effective-address.html":{"createdTime":1762228980095,"modifiedTime":1755642667144,"sourceSize":10,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.1 Load Effective Address.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.1-load-effective-address.html","showInTree":true,"treeOrder":100,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.2-unary-and-binary-operations.html":{"createdTime":1762228980382,"modifiedTime":1755713590761,"sourceSize":61,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.2 Unary and Binary Operations.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.2-unary-and-binary-operations.html","showInTree":true,"treeOrder":101,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.3-shift-operations.html":{"createdTime":1762228979830,"modifiedTime":1755713558243,"sourceSize":27,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.3 Shift Operations.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.3-shift-operations.html","showInTree":true,"treeOrder":102,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html":{"createdTime":1762228980378,"modifiedTime":1755726648604,"sourceSize":4095,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.5 Special Arithmetic Operations.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html":{"createdTime":1762228978062,"modifiedTime":1755801080929,"sourceSize":1608,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.1 Condition Codes.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.2-accessing-the-condition-codes.html":{"createdTime":1762228977768,"modifiedTime":1755803089807,"sourceSize":349,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.2 Accessing the Condition Codes.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.2-accessing-the-condition-codes.html","showInTree":true,"treeOrder":106,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.3-jump-instructions.html":{"createdTime":1762228978803,"modifiedTime":1755807889381,"sourceSize":9,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.3 Jump Instructions.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.3-jump-instructions.html","showInTree":true,"treeOrder":107,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.4-jump-instruction-encodings.html":{"createdTime":1762228978461,"modifiedTime":1755891828600,"sourceSize":2918,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.4 Jump instruction Encodings.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.4-jump-instruction-encodings.html","showInTree":true,"treeOrder":108,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.5-conditional-branches-with-conditional-control.html":{"createdTime":1762228979261,"modifiedTime":1756147649133,"sourceSize":2524,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.5 Conditional Branches with Conditional Control.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.5-conditional-branches-with-conditional-control.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.6-conditional-branches-with-conditional-moves.html":{"createdTime":1762228978424,"modifiedTime":1756316908079,"sourceSize":4189,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.6 Conditional Branches with Conditional Moves.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.6-conditional-branches-with-conditional-moves.html","showInTree":true,"treeOrder":110,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.7-loops.html":{"createdTime":1762228978015,"modifiedTime":1756323390434,"sourceSize":6109,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.7 Loops.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.7-loops.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.8-switch-statements.html":{"createdTime":1762228978631,"modifiedTime":1756962296127,"sourceSize":4451,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.8 Switch Statements.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.8-switch-statements.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7-procedures.html":{"createdTime":1762228975642,"modifiedTime":1757007305832,"sourceSize":1727,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7 Procedures.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7-procedures.html","showInTree":true,"treeOrder":114,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.3-data-transfer.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.4-local-storage-on-the-stack.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.5-local-storage-in-registers.html","cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.6-recursive-procedures.html"],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html":{"createdTime":1762228975834,"modifiedTime":1760918048206,"sourceSize":3351,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.1 The Run-Time Stack.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.2-control-transfer.html":{"createdTime":1762228908930,"modifiedTime":1757016007822,"sourceSize":259,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.2 Control Transfer.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.2-control-transfer.html","showInTree":true,"treeOrder":116,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.3-data-transfer.html":{"createdTime":1762228975377,"modifiedTime":1757049961003,"sourceSize":2964,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.3 Data Transfer.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.3-data-transfer.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.4-local-storage-on-the-stack.html":{"createdTime":1762228975057,"modifiedTime":1757182283611,"sourceSize":3536,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.4 Local Storage on the Stack.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.4-local-storage-on-the-stack.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.5-local-storage-in-registers.html":{"createdTime":1762228975317,"modifiedTime":1757193208068,"sourceSize":2853,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.5 Local Storage in Registers.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.5-local-storage-in-registers.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.6-recursive-procedures.html":{"createdTime":1762228975121,"modifiedTime":1757193557798,"sourceSize":1773,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.6 Recursive Procedures.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.6-recursive-procedures.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html":{"createdTime":1762228976562,"modifiedTime":1760848923419,"sourceSize":1482,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.1 Array Basic Principles.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.2-pointer-arithmetic.html":{"createdTime":1762228976109,"modifiedTime":1757354635157,"sourceSize":1674,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.2 Pointer Arithmetic.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.2-pointer-arithmetic.html","showInTree":true,"treeOrder":123,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.3-nested-arrays.html":{"createdTime":1762228976513,"modifiedTime":1760848779635,"sourceSize":1689,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.3 Nested Arrays.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.3-nested-arrays.html","showInTree":true,"treeOrder":124,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html"],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.4-fixed-size-arrays.html":{"createdTime":1762228975938,"modifiedTime":1760848908534,"sourceSize":2275,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.4 Fixed-Size Arrays.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.4-fixed-size-arrays.html","showInTree":true,"treeOrder":125,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html"],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.5-variable-size-arrays.html":{"createdTime":1762228976162,"modifiedTime":1757528887699,"sourceSize":18,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.5 Variable-Size Arrays.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.5-variable-size-arrays.html","showInTree":true,"treeOrder":126,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html"],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.1-structures.html":{"createdTime":1762228981017,"modifiedTime":1760212328815,"sourceSize":2071,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.9 Heterogeneous Data Structures/3.9.1 Structures.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.1-structures.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.2-unions.html":{"createdTime":1762228980838,"modifiedTime":1760224602047,"sourceSize":2176,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.9 Heterogeneous Data Structures/3.9.2 Unions.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.2-unions.html","showInTree":true,"treeOrder":129,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.3-data-alignment.html":{"createdTime":1762228980911,"modifiedTime":1760228366891,"sourceSize":4106,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.9 Heterogeneous Data Structures/3.9.3 Data Alignment.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.3-data-alignment.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.1-understanding-pointers.html":{"createdTime":1762228979088,"modifiedTime":1760593302879,"sourceSize":4060,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.1 Understanding Pointers.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.1-understanding-pointers.html","showInTree":true,"treeOrder":132,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.4-thwarting-buffer-overflow-attacks.html"],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html":{"createdTime":1762228979751,"modifiedTime":1760994768478,"sourceSize":4266,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.3 Out-of-Bounds Memory References and Buffer Overflow.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html","showInTree":true,"treeOrder":133,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.4-thwarting-buffer-overflow-attacks.html":{"createdTime":1762228979250,"modifiedTime":1761016289859,"sourceSize":3847,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.4 Thwarting Buffer Overflow Attacks.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.4-thwarting-buffer-overflow-attacks.html","showInTree":true,"treeOrder":134,"backlinks":[],"type":"markdown","data":null},"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.5-supporting-variable-size-stack-frames.html":{"createdTime":1762228979571,"modifiedTime":1769034465014,"sourceSize":274,"sourcePath":"CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.5 Supporting Variable-Size Stack Frames.md","exportPath":"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.5-supporting-variable-size-stack-frames.html","showInTree":true,"treeOrder":135,"backlinks":[],"type":"markdown","data":null},"cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.1-programmer-visible-state.html":{"createdTime":1769122740669,"modifiedTime":1769123923434,"sourceSize":1383,"sourcePath":"CS_APP/IV. Processor Arch/4.1 Y86-64 ISA/4.1.1 Programmer-Visible State.md","exportPath":"cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.1-programmer-visible-state.html","showInTree":true,"treeOrder":138,"backlinks":[],"type":"markdown","data":null},"cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.2-y86-64-instructions.html":{"createdTime":1769123936187,"modifiedTime":1769130761191,"sourceSize":1544,"sourcePath":"CS_APP/IV. Processor Arch/4.1 Y86-64 ISA/4.1.2 Y86-64 Instructions.md","exportPath":"cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.2-y86-64-instructions.html","showInTree":true,"treeOrder":139,"backlinks":[],"type":"markdown","data":null},"cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.3-instruction-encoding.html":{"createdTime":1769130874921,"modifiedTime":1769140058308,"sourceSize":1836,"sourcePath":"CS_APP/IV. Processor Arch/4.1 Y86-64 ISA/4.1.3 Instruction Encoding.md","exportPath":"cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.3-instruction-encoding.html","showInTree":true,"treeOrder":140,"backlinks":[],"type":"markdown","data":null},"cs_app/iv.-processor-arch/intro.html":{"createdTime":1769035526897,"modifiedTime":1769036296774,"sourceSize":1453,"sourcePath":"CS_APP/IV. Processor Arch/Intro.md","exportPath":"cs_app/iv.-processor-arch/intro.html","showInTree":true,"treeOrder":141,"backlinks":[],"type":"markdown","data":null},"cs_app/cs_app.pdf":{"createdTime":1762228984700,"modifiedTime":1755197586248,"sourceSize":4829329,"sourcePath":"CS_APP/CS_APP.pdf","exportPath":"cs_app/cs_app.pdf","showInTree":true,"treeOrder":0,"backlinks":[],"type":"other","data":null},"cs_app/cs_app.html":{"createdTime":1762228984700,"modifiedTime":1755197586248,"sourceSize":4829329,"sourcePath":"CS_APP/CS_APP.pdf","exportPath":"cs_app/cs_app.html","showInTree":true,"treeOrder":142,"backlinks":["cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.2-unions.html"],"type":"attachment","data":null},"site-lib/scripts/graph-wasm.wasm":{"createdTime":1769633441343,"modifiedTime":1769633438743.77,"sourceSize":23655,"sourcePath":"","exportPath":"site-lib/scripts/graph-wasm.wasm","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"site-lib/fonts/70cc7ff27245e82ad414.ttf":{"createdTime":1769640643553,"modifiedTime":1769640643553,"sourceSize":192740,"sourcePath":"","exportPath":"site-lib/fonts/70cc7ff27245e82ad414.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/454577c22304619db035.ttf":{"createdTime":1769640643554,"modifiedTime":1769640643554,"sourceSize":161376,"sourcePath":"","exportPath":"site-lib/fonts/454577c22304619db035.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/52ac8f3034507f1d9e53.ttf":{"createdTime":1769640643554,"modifiedTime":1769640643554,"sourceSize":191568,"sourcePath":"","exportPath":"site-lib/fonts/52ac8f3034507f1d9e53.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/05b618077343fbbd92b7.ttf":{"createdTime":1769640643552,"modifiedTime":1769640643552,"sourceSize":155288,"sourcePath":"","exportPath":"site-lib/fonts/05b618077343fbbd92b7.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2":{"createdTime":1769640643550,"modifiedTime":1769640643550,"sourceSize":7876,"sourcePath":"","exportPath":"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/c504db5c06caaf7cdfba.woff2":{"createdTime":1769640643566,"modifiedTime":1769640643566,"sourceSize":352240,"sourcePath":"","exportPath":"site-lib/fonts/c504db5c06caaf7cdfba.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/01dcbad1bac635f9c9cd.woff2":{"createdTime":1769640643566,"modifiedTime":1769640643566,"sourceSize":387976,"sourcePath":"","exportPath":"site-lib/fonts/01dcbad1bac635f9c9cd.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/media/6155340132a851f6089e.svg":{"createdTime":1769640643550,"modifiedTime":1769640643550,"sourceSize":315,"sourcePath":"","exportPath":"site-lib/media/6155340132a851f6089e.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/2308ab1944a6bfa5c5b8.svg":{"createdTime":1769640643551,"modifiedTime":1769640643551,"sourceSize":278,"sourcePath":"","exportPath":"site-lib/media/2308ab1944a6bfa5c5b8.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/fonts/mathjax_zero.woff":{"createdTime":1769640573525,"modifiedTime":1769640573525,"sourceSize":1368,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_zero.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_main-regular.woff":{"createdTime":1769640573525,"modifiedTime":1769640573525,"sourceSize":34160,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_main-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_main-bold.woff":{"createdTime":1769640573530,"modifiedTime":1769640573530,"sourceSize":34464,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_main-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_math-italic.woff":{"createdTime":1769640573531,"modifiedTime":1769640573531,"sourceSize":19360,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_math-italic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_main-italic.woff":{"createdTime":1769640573531,"modifiedTime":1769640573531,"sourceSize":20832,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_main-italic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_math-bolditalic.woff":{"createdTime":1769640573531,"modifiedTime":1769640573531,"sourceSize":19776,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_math-bolditalic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size1-regular.woff":{"createdTime":1769640573531,"modifiedTime":1769640573531,"sourceSize":5792,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size1-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size2-regular.woff":{"createdTime":1769640573531,"modifiedTime":1769640573531,"sourceSize":5464,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size2-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size3-regular.woff":{"createdTime":1769640573532,"modifiedTime":1769640573532,"sourceSize":3244,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size3-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size4-regular.woff":{"createdTime":1769640573532,"modifiedTime":1769640573532,"sourceSize":5148,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size4-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_ams-regular.woff":{"createdTime":1769640573532,"modifiedTime":1769640573532,"sourceSize":40808,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_ams-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_calligraphic-regular.woff":{"createdTime":1769640573532,"modifiedTime":1769640573532,"sourceSize":9600,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_calligraphic-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_calligraphic-bold.woff":{"createdTime":1769640573532,"modifiedTime":1769640573532,"sourceSize":9908,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_calligraphic-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_fraktur-regular.woff":{"createdTime":1769640573532,"modifiedTime":1769640573532,"sourceSize":21480,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_fraktur-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_fraktur-bold.woff":{"createdTime":1769640573532,"modifiedTime":1769640573532,"sourceSize":22340,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_fraktur-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_sansserif-regular.woff":{"createdTime":1769640573533,"modifiedTime":1769640573533,"sourceSize":12660,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_sansserif-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_sansserif-bold.woff":{"createdTime":1769640573533,"modifiedTime":1769640573533,"sourceSize":15944,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_sansserif-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_sansserif-italic.woff":{"createdTime":1769640573533,"modifiedTime":1769640573533,"sourceSize":14628,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_sansserif-italic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_script-regular.woff":{"createdTime":1769640573533,"modifiedTime":1769640573533,"sourceSize":11852,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_script-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_typewriter-regular.woff":{"createdTime":1769640573533,"modifiedTime":1769640573533,"sourceSize":17604,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_typewriter-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_vector-regular.woff":{"createdTime":1769640573533,"modifiedTime":1769640573533,"sourceSize":1136,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_vector-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_vector-bold.woff":{"createdTime":1769640573534,"modifiedTime":1769640573534,"sourceSize":1116,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_vector-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/html/file-tree-content.html":{"createdTime":1769640644851,"modifiedTime":1769640644851,"sourceSize":90341,"sourcePath":"","exportPath":"site-lib/html/file-tree-content.html","showInTree":false,"treeOrder":0,"backlinks":[],"type":"html","data":null},"site-lib/scripts/webpage.js":{"createdTime":1769633442106,"modifiedTime":1769633442106,"sourceSize":110729,"sourcePath":"","exportPath":"site-lib/scripts/webpage.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/graph-wasm.js":{"createdTime":1769633442106,"modifiedTime":1769633442106,"sourceSize":12885,"sourcePath":"","exportPath":"site-lib/scripts/graph-wasm.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/graph-render-worker.js":{"createdTime":1769633442106,"modifiedTime":1769633442106,"sourceSize":5681,"sourcePath":"","exportPath":"site-lib/scripts/graph-render-worker.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/media/favicon.png":{"createdTime":1769640643414,"modifiedTime":1769640643414,"sourceSize":1105,"sourcePath":"","exportPath":"site-lib/media/favicon.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/styles/snippets.css":{"createdTime":1769640643662,"modifiedTime":1769640643662,"sourceSize":27002,"sourcePath":"","exportPath":"site-lib/styles/snippets.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/obsidian.css":{"createdTime":1769640643616,"modifiedTime":1769640643616,"sourceSize":213605,"sourcePath":"","exportPath":"site-lib/styles/obsidian.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/theme.css":{"createdTime":1769633442373,"modifiedTime":1769633442373,"sourceSize":286560,"sourcePath":"","exportPath":"site-lib/styles/theme.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/global-variable-styles.css":{"createdTime":1769640643510,"modifiedTime":1769640643510,"sourceSize":472,"sourcePath":"","exportPath":"site-lib/styles/global-variable-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/supported-plugins.css":{"createdTime":1769640643632,"modifiedTime":1769640643632,"sourceSize":2974,"sourcePath":"","exportPath":"site-lib/styles/supported-plugins.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/main-styles.css":{"createdTime":1769633442140,"modifiedTime":1769633442140,"sourceSize":19521,"sourcePath":"","exportPath":"site-lib/styles/main-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"assets/pasted-image-20250807171802.png":{"createdTime":1762229683474,"modifiedTime":1754608682494,"sourceSize":196180,"sourcePath":"assets/Pasted image 20250807171802.png","exportPath":"assets/pasted-image-20250807171802.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250724134626.png":{"createdTime":1762229257624,"modifiedTime":1753386386176,"sourceSize":34185,"sourcePath":"assets/Pasted image 20250724134626.png","exportPath":"assets/pasted-image-20250724134626.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20260122194808.png":{"createdTime":1769132888882,"modifiedTime":1769132888884,"sourceSize":46255,"sourcePath":"assets/Pasted image 20260122194808.png","exportPath":"assets/pasted-image-20260122194808.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20260122211607.png":{"createdTime":1769138167472,"modifiedTime":1769138167476,"sourceSize":48257,"sourcePath":"assets/Pasted image 20260122211607.png","exportPath":"assets/pasted-image-20260122211607.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20260122212355.png":{"createdTime":1769138635511,"modifiedTime":1769138635513,"sourceSize":3810,"sourcePath":"assets/Pasted image 20260122212355.png","exportPath":"assets/pasted-image-20260122212355.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20260122172120.png":{"createdTime":1769124080657,"modifiedTime":1769124080659,"sourceSize":71633,"sourcePath":"assets/Pasted image 20260122172120.png","exportPath":"assets/pasted-image-20260122172120.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20260122171049.png":{"createdTime":1769123449778,"modifiedTime":1769123449782,"sourceSize":50997,"sourcePath":"assets/Pasted image 20260122171049.png","exportPath":"assets/pasted-image-20260122171049.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20251020154933.png":{"createdTime":1762229833648,"modifiedTime":1760996973141,"sourceSize":120996,"sourcePath":"assets/Pasted image 20251020154933.png","exportPath":"assets/pasted-image-20251020154933.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20251018225151.png":{"createdTime":1762229542804,"modifiedTime":1760849511330,"sourceSize":94284,"sourcePath":"assets/Pasted image 20251018225151.png","exportPath":"assets/pasted-image-20251018225151.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250908124256.png":{"createdTime":1762229472567,"modifiedTime":1757356976959,"sourceSize":320596,"sourcePath":"assets/Pasted image 20250908124256.png","exportPath":"assets/pasted-image-20250908124256.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250908121209.png":{"createdTime":1762229609000,"modifiedTime":1757355129130,"sourceSize":118176,"sourcePath":"assets/Pasted image 20250908121209.png","exportPath":"assets/pasted-image-20250908121209.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250908121735.png":{"createdTime":1762229757458,"modifiedTime":1757355455402,"sourceSize":47730,"sourcePath":"assets/Pasted image 20250908121735.png","exportPath":"assets/pasted-image-20250908121735.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250715115553.png":{"createdTime":1762229539603,"modifiedTime":1752602153688,"sourceSize":121421,"sourcePath":"assets/Pasted image 20250715115553.png","exportPath":"assets/pasted-image-20250715115553.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250917213940.png":{"createdTime":1762229757052,"modifiedTime":1758166780598,"sourceSize":124299,"sourcePath":"assets/Pasted image 20250917213940.png","exportPath":"assets/pasted-image-20250917213940.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250908115829.png":{"createdTime":1762229755213,"modifiedTime":1757354309146,"sourceSize":81617,"sourcePath":"assets/Pasted image 20250908115829.png","exportPath":"assets/pasted-image-20250908115829.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250817140128.png":{"createdTime":1762229614501,"modifiedTime":1755460888682,"sourceSize":256743,"sourcePath":"assets/Pasted image 20250817140128.png","exportPath":"assets/pasted-image-20250817140128.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"indexes/coding/assembly-x86/call.md":{"createdTime":1762228759091,"modifiedTime":1757017380795,"sourceSize":2755,"sourcePath":"Indexes/Coding/Assembly x86/call.md","exportPath":"indexes/coding/assembly-x86/call.md","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"assets/pasted-image-20250904134956.png":{"createdTime":1762229327618,"modifiedTime":1757015396169,"sourceSize":36063,"sourcePath":"assets/Pasted image 20250904134956.png","exportPath":"assets/pasted-image-20250904134956.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250904135618.png":{"createdTime":1762229328772,"modifiedTime":1757015778300,"sourceSize":119127,"sourcePath":"assets/Pasted image 20250904135618.png","exportPath":"assets/pasted-image-20250904135618.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250904135903.png":{"createdTime":1762229397749,"modifiedTime":1757015943472,"sourceSize":89502,"sourcePath":"assets/Pasted image 20250904135903.png","exportPath":"assets/pasted-image-20250904135903.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250904141340.png":{"createdTime":1762229260373,"modifiedTime":1757016820063,"sourceSize":383451,"sourcePath":"assets/Pasted image 20250904141340.png","exportPath":"assets/pasted-image-20250904141340.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250825133158.png":{"createdTime":1762229754302,"modifiedTime":1756150318981,"sourceSize":426628,"sourcePath":"assets/Pasted image 20250825133158.png","exportPath":"assets/pasted-image-20250825133158.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250819153309.png":{"createdTime":1762229834039,"modifiedTime":1755639189303,"sourceSize":236226,"sourcePath":"assets/Pasted image 20250819153309.png","exportPath":"assets/pasted-image-20250819153309.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"indexes/coding/assembly-x86/jump.md":{"createdTime":1762228760547,"modifiedTime":1755887719651,"sourceSize":1891,"sourcePath":"Indexes/Coding/Assembly x86/JUMP.md","exportPath":"indexes/coding/assembly-x86/jump.md","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"assets/pasted-image-20250821143128.png":{"createdTime":1762229754798,"modifiedTime":1755808288778,"sourceSize":59614,"sourcePath":"assets/Pasted image 20250821143128.png","exportPath":"assets/pasted-image-20250821143128.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250821143052.png":{"createdTime":1762229471224,"modifiedTime":1755808252641,"sourceSize":338338,"sourcePath":"assets/Pasted image 20250821143052.png","exportPath":"assets/pasted-image-20250821143052.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"indexes/coding/assembly-x86/mov.md":{"createdTime":1762228830671,"modifiedTime":1755642806206,"sourceSize":5037,"sourcePath":"Indexes/Coding/Assembly x86/MOV.md","exportPath":"indexes/coding/assembly-x86/mov.md","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"assets/pasted-image-20250818123607.png":{"createdTime":1762229539575,"modifiedTime":1755542167474,"sourceSize":106546,"sourcePath":"assets/Pasted image 20250818123607.png","exportPath":"assets/pasted-image-20250818123607.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250818124727.png":{"createdTime":1762229470492,"modifiedTime":1755542847363,"sourceSize":54438,"sourcePath":"assets/Pasted image 20250818124727.png","exportPath":"assets/pasted-image-20250818124727.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250818133441.png":{"createdTime":1762229690250,"modifiedTime":1755545681611,"sourceSize":148824,"sourcePath":"assets/Pasted image 20250818133441.png","exportPath":"assets/pasted-image-20250818133441.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250818134520.png":{"createdTime":1762229191884,"modifiedTime":1755546320732,"sourceSize":207028,"sourcePath":"assets/Pasted image 20250818134520.png","exportPath":"assets/pasted-image-20250818134520.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250818135026.png":{"createdTime":1762229330269,"modifiedTime":1755546626540,"sourceSize":89342,"sourcePath":"assets/Pasted image 20250818135026.png","exportPath":"assets/pasted-image-20250818135026.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250818141612.png":{"createdTime":1762229468386,"modifiedTime":1755548173000,"sourceSize":90149,"sourcePath":"assets/Pasted image 20250818141612.png","exportPath":"assets/pasted-image-20250818141612.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"indexes/coding/assembly-x86/set.md":{"createdTime":1762228759132,"modifiedTime":1755804647064,"sourceSize":2269,"sourcePath":"Indexes/Coding/Assembly x86/SET.md","exportPath":"indexes/coding/assembly-x86/set.md","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"assets/pasted-image-20250821131150.png":{"createdTime":1762229829261,"modifiedTime":1755803510462,"sourceSize":259027,"sourcePath":"assets/Pasted image 20250821131150.png","exportPath":"assets/pasted-image-20250821131150.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250821131322.png":{"createdTime":1762229613955,"modifiedTime":1755803602482,"sourceSize":85505,"sourcePath":"assets/Pasted image 20250821131322.png","exportPath":"assets/pasted-image-20250821131322.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"indexes/coding/assembly-x86/operands-as.md":{"createdTime":1762228759556,"modifiedTime":1755643996490,"sourceSize":2180,"sourcePath":"Indexes/Coding/Assembly x86/Operands - as.md","exportPath":"indexes/coding/assembly-x86/operands-as.md","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"assets/pasted-image-20250817144946.png":{"createdTime":1762229834912,"modifiedTime":1755463786610,"sourceSize":221813,"sourcePath":"assets/Pasted image 20250817144946.png","exportPath":"assets/pasted-image-20250817144946.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250817164321.png":{"createdTime":1762229901214,"modifiedTime":1755470601673,"sourceSize":152279,"sourcePath":"assets/Pasted image 20250817164321.png","exportPath":"assets/pasted-image-20250817164321.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"indexes/coding/assembly-x86/unary-operations-as.md":{"createdTime":1762228759858,"modifiedTime":1755713595313,"sourceSize":430,"sourcePath":"Indexes/Coding/Assembly x86/Unary Operations - as.md","exportPath":"indexes/coding/assembly-x86/unary-operations-as.md","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"assets/pasted-image-20250819172841.png":{"createdTime":1762229901171,"modifiedTime":1755646121451,"sourceSize":54455,"sourcePath":"assets/Pasted image 20250819172841.png","exportPath":"assets/pasted-image-20250819172841.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"indexes/coding/assembly-x86/binary-operations-as.md":{"createdTime":1762228759785,"modifiedTime":1755804002142,"sourceSize":913,"sourcePath":"Indexes/Coding/Assembly x86/Binary Operations - as.md","exportPath":"indexes/coding/assembly-x86/binary-operations-as.md","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"assets/pasted-image-20250819173309.png":{"createdTime":1762229538394,"modifiedTime":1755646389476,"sourceSize":83791,"sourcePath":"assets/Pasted image 20250819173309.png","exportPath":"assets/pasted-image-20250819173309.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"indexes/coding/assembly-x86/shift-operations-as.md":{"createdTime":1762228830891,"modifiedTime":1755714287911,"sourceSize":1311,"sourcePath":"Indexes/Coding/Assembly x86/Shift Operations - as.md","exportPath":"indexes/coding/assembly-x86/shift-operations-as.md","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"assets/pasted-image-20250820121350.png":{"createdTime":1762229759883,"modifiedTime":1755713630792,"sourceSize":64719,"sourcePath":"assets/Pasted image 20250820121350.png","exportPath":"assets/pasted-image-20250820121350.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"indexes/coding/assembly-x86/leaq.md":{"createdTime":1762228760063,"modifiedTime":1755804002011,"sourceSize":1850,"sourcePath":"Indexes/Coding/Assembly x86/leaq.md","exportPath":"indexes/coding/assembly-x86/leaq.md","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"indexes/coding/assembly-x86/push-&-pop.md":{"createdTime":1762228760445,"modifiedTime":1755640256003,"sourceSize":165,"sourcePath":"Indexes/Coding/Assembly x86/push & pop.md","exportPath":"indexes/coding/assembly-x86/push-&-pop.md","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"assets/pasted-image-20250819150715.png":{"createdTime":1762229539640,"modifiedTime":1755637635926,"sourceSize":72714,"sourcePath":"assets/Pasted image 20250819150715.png","exportPath":"assets/pasted-image-20250819150715.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250807193243.png":{"createdTime":1762229536582,"modifiedTime":1754616763030,"sourceSize":73400,"sourcePath":"assets/Pasted image 20250807193243.png","exportPath":"assets/pasted-image-20250807193243.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250807193302.png":{"createdTime":1762229609631,"modifiedTime":1754616782781,"sourceSize":96543,"sourcePath":"assets/Pasted image 20250807193302.png","exportPath":"assets/pasted-image-20250807193302.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250807193731.png":{"createdTime":1762229617994,"modifiedTime":1754617051543,"sourceSize":231237,"sourcePath":"assets/Pasted image 20250807193731.png","exportPath":"assets/pasted-image-20250807193731.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250815131351.png":{"createdTime":1762229688818,"modifiedTime":1755285231850,"sourceSize":69243,"sourcePath":"assets/Pasted image 20250815131351.png","exportPath":"assets/pasted-image-20250815131351.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250815133752.png":{"createdTime":1762229610156,"modifiedTime":1755286672138,"sourceSize":81837,"sourcePath":"assets/Pasted image 20250815133752.png","exportPath":"assets/pasted-image-20250815133752.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250715184855.png":{"createdTime":1762229687172,"modifiedTime":1752626935228,"sourceSize":117047,"sourcePath":"assets/Pasted image 20250715184855.png","exportPath":"assets/pasted-image-20250715184855.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250814135551.png":{"createdTime":1762229334327,"modifiedTime":1755201351747,"sourceSize":68034,"sourcePath":"assets/Pasted image 20250814135551.png","exportPath":"assets/pasted-image-20250814135551.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250716204848.png":{"createdTime":1762229332611,"modifiedTime":1752720528027,"sourceSize":47064,"sourcePath":"assets/Pasted image 20250716204848.png","exportPath":"assets/pasted-image-20250716204848.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250717130734.png":{"createdTime":1762229832302,"modifiedTime":1752779254321,"sourceSize":240978,"sourcePath":"assets/Pasted image 20250717130734.png","exportPath":"assets/pasted-image-20250717130734.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250717141129.png":{"createdTime":1762229831192,"modifiedTime":1752783089078,"sourceSize":30548,"sourcePath":"assets/Pasted image 20250717141129.png","exportPath":"assets/pasted-image-20250717141129.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250808193539.png":{"createdTime":1762229192083,"modifiedTime":1754703339496,"sourceSize":63872,"sourcePath":"assets/Pasted image 20250808193539.png","exportPath":"assets/pasted-image-20250808193539.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250808193628.png":{"createdTime":1762229334733,"modifiedTime":1754703388621,"sourceSize":64610,"sourcePath":"assets/Pasted image 20250808193628.png","exportPath":"assets/pasted-image-20250808193628.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250808194016.png":{"createdTime":1762229828182,"modifiedTime":1754703616571,"sourceSize":64005,"sourcePath":"assets/Pasted image 20250808194016.png","exportPath":"assets/pasted-image-20250808194016.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250808164737.png":{"createdTime":1762229760782,"modifiedTime":1754693257384,"sourceSize":83327,"sourcePath":"assets/Pasted image 20250808164737.png","exportPath":"assets/pasted-image-20250808164737.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250806124238.png":{"createdTime":1762229399502,"modifiedTime":1754505758227,"sourceSize":93826,"sourcePath":"assets/Pasted image 20250806124238.png","exportPath":"assets/pasted-image-20250806124238.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250805221658.png":{"createdTime":1762229763943,"modifiedTime":1754453818601,"sourceSize":143135,"sourcePath":"assets/Pasted image 20250805221658.png","exportPath":"assets/pasted-image-20250805221658.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250805215808.png":{"createdTime":1762229474454,"modifiedTime":1754452688607,"sourceSize":215177,"sourcePath":"assets/Pasted image 20250805215808.png","exportPath":"assets/pasted-image-20250805215808.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250805220347.png":{"createdTime":1762229189287,"modifiedTime":1754453027011,"sourceSize":80382,"sourcePath":"assets/Pasted image 20250805220347.png","exportPath":"assets/pasted-image-20250805220347.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250805133858.png":{"createdTime":1762229188925,"modifiedTime":1754422738969,"sourceSize":91863,"sourcePath":"assets/Pasted image 20250805133858.png","exportPath":"assets/pasted-image-20250805133858.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250805140636.png":{"createdTime":1762229468100,"modifiedTime":1754424396479,"sourceSize":139172,"sourcePath":"assets/Pasted image 20250805140636.png","exportPath":"assets/pasted-image-20250805140636.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250805143818.png":{"createdTime":1762229475500,"modifiedTime":1754426298006,"sourceSize":176785,"sourcePath":"assets/Pasted image 20250805143818.png","exportPath":"assets/pasted-image-20250805143818.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250725183303.png":{"createdTime":1762229328808,"modifiedTime":1753489983177,"sourceSize":84226,"sourcePath":"assets/Pasted image 20250725183303.png","exportPath":"assets/pasted-image-20250725183303.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250725180054.png":{"createdTime":1762229684089,"modifiedTime":1753488054931,"sourceSize":152839,"sourcePath":"assets/Pasted image 20250725180054.png","exportPath":"assets/pasted-image-20250725180054.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250725180109.png":{"createdTime":1762229401356,"modifiedTime":1753488069993,"sourceSize":166888,"sourcePath":"assets/Pasted image 20250725180109.png","exportPath":"assets/pasted-image-20250725180109.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250725174630.png":{"createdTime":1762229617339,"modifiedTime":1753487190764,"sourceSize":349764,"sourcePath":"assets/Pasted image 20250725174630.png","exportPath":"assets/pasted-image-20250725174630.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250724145251.png":{"createdTime":1762229828689,"modifiedTime":1753390371864,"sourceSize":32942,"sourcePath":"assets/Pasted image 20250724145251.png","exportPath":"assets/pasted-image-20250724145251.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250722131129.png":{"createdTime":1762229471945,"modifiedTime":1753211489260,"sourceSize":60178,"sourcePath":"assets/Pasted image 20250722131129.png","exportPath":"assets/pasted-image-20250722131129.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250712193205.png":{"createdTime":1762229333798,"modifiedTime":1752370325968,"sourceSize":112273,"sourcePath":"assets/Pasted image 20250712193205.png","exportPath":"assets/pasted-image-20250712193205.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250720142153.png":{"createdTime":1762229616996,"modifiedTime":1753042913414,"sourceSize":79129,"sourcePath":"assets/Pasted image 20250720142153.png","exportPath":"assets/pasted-image-20250720142153.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250722122228.png":{"createdTime":1762229829123,"modifiedTime":1753208548333,"sourceSize":17205,"sourcePath":"assets/Pasted image 20250722122228.png","exportPath":"assets/pasted-image-20250722122228.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250716183124.png":{"createdTime":1762229539145,"modifiedTime":1752712284369,"sourceSize":82789,"sourcePath":"assets/Pasted image 20250716183124.png","exportPath":"assets/pasted-image-20250716183124.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250716131144.png":{"createdTime":1762229689653,"modifiedTime":1752693104182,"sourceSize":82909,"sourcePath":"assets/Pasted image 20250716131144.png","exportPath":"assets/pasted-image-20250716131144.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250715224120.png":{"createdTime":1762229327566,"modifiedTime":1752640880759,"sourceSize":133127,"sourcePath":"assets/Pasted image 20250715224120.png","exportPath":"assets/pasted-image-20250715224120.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250715174131.png":{"createdTime":1762229263686,"modifiedTime":1752622891778,"sourceSize":59964,"sourcePath":"assets/Pasted image 20250715174131.png","exportPath":"assets/pasted-image-20250715174131.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250715174158.png":{"createdTime":1762229189941,"modifiedTime":1752622918726,"sourceSize":124066,"sourcePath":"assets/Pasted image 20250715174158.png","exportPath":"assets/pasted-image-20250715174158.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250715124434.png":{"createdTime":1762229330506,"modifiedTime":1752605075000,"sourceSize":187727,"sourcePath":"assets/Pasted image 20250715124434.png","exportPath":"assets/pasted-image-20250715124434.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250712180214.png":{"createdTime":1762229836153,"modifiedTime":1752364934483,"sourceSize":200905,"sourcePath":"assets/Pasted image 20250712180214.png","exportPath":"assets/pasted-image-20250712180214.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250712174037.png":{"createdTime":1762229398980,"modifiedTime":1752363637732,"sourceSize":85037,"sourcePath":"assets/Pasted image 20250712174037.png","exportPath":"assets/pasted-image-20250712174037.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20250712175559.png":{"createdTime":1762229615792,"modifiedTime":1752364559193,"sourceSize":201853,"sourcePath":"assets/Pasted image 20250712175559.png","exportPath":"assets/pasted-image-20250712175559.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/rss.xml":{"createdTime":1769640645520,"modifiedTime":1769640645520,"sourceSize":243165,"sourcePath":"","exportPath":"site-lib/rss.xml","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"indexes/cryptography/cbc-cyber-block-chaining.html":{"createdTime":1769618966679,"modifiedTime":1769620651574,"sourceSize":1512,"sourcePath":"Indexes/Cryptography/CBC - Cyber-Block Chaining.md","exportPath":"indexes/cryptography/cbc-cyber-block-chaining.html","showInTree":true,"treeOrder":145,"backlinks":[],"type":"markdown","data":null},"assets/pasted-image-20260128110417.png":{"createdTime":1769619857427,"modifiedTime":1769619857429,"sourceSize":29909,"sourcePath":"assets/Pasted image 20260128110417.png","exportPath":"assets/pasted-image-20260128110417.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"assets/pasted-image-20260128110814.png":{"createdTime":1769620094709,"modifiedTime":1769620094711,"sourceSize":25907,"sourcePath":"assets/Pasted image 20260128110814.png","exportPath":"assets/pasted-image-20260128110814.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null}},"sourceToTarget":{"CS_APP/Glossary/Adapter.md":"cs_app/glossary/adapter.html","CS_APP/Glossary/ALU.md":"cs_app/glossary/alu.html","CS_APP/Glossary/Buses.md":"cs_app/glossary/buses.html","CS_APP/Glossary/cache memories.md":"cs_app/glossary/cache-memories.html","CS_APP/Glossary/concurrency.md":"cs_app/glossary/concurrency.html","CS_APP/Glossary/Controller.md":"cs_app/glossary/controller.html","CS_APP/Glossary/CPU.md":"cs_app/glossary/cpu.html","CS_APP/Glossary/file.md":"cs_app/glossary/file.html","CS_APP/Glossary/hyperthreading.md":"cs_app/glossary/hyperthreading.html","CS_APP/Glossary/I-O Devices.md":"cs_app/glossary/i-o-devices.html","CS_APP/Glossary/ISA - Instruction Set Architecture.md":"cs_app/glossary/isa-instruction-set-architecture.html","CS_APP/Glossary/kernel.md":"cs_app/glossary/kernel.html","CS_APP/Glossary/Main Memory.md":"cs_app/glossary/main-memory.html","CS_APP/Glossary/multi-core processor.md":"cs_app/glossary/multi-core-processor.html","CS_APP/Glossary/Operating System.md":"cs_app/glossary/operating-system.html","CS_APP/Glossary/Parallelism.md":"cs_app/glossary/parallelism.html","CS_APP/Glossary/processes.md":"cs_app/glossary/processes.html","CS_APP/Glossary/program stack.md":"cs_app/glossary/program-stack.html","CS_APP/Glossary/register.md":"cs_app/glossary/register.html","CS_APP/Glossary/register file.md":"cs_app/glossary/register-file.html","CS_APP/Glossary/Shell.md":"cs_app/glossary/shell.html","CS_APP/Glossary/threads.md":"cs_app/glossary/threads.html","CS_APP/Glossary/TIB, TEB & PEB.md":"cs_app/glossary/tib,-teb-&-peb.html","CS_APP/Glossary/Transistor.md":"cs_app/glossary/transistor.html","CS_APP/Glossary/Unicode.md":"cs_app/glossary/unicode.html","CS_APP/Glossary/virtual memory.md":"cs_app/glossary/virtual-memory.html","CS_APP/I. Computer Systems/1.1 Information is Bits + Context/1.1 Information is Bits + Context.md":"cs_app/i.-computer-systems/1.1-information-is-bits-+-context/1.1-information-is-bits-+-context.html","CS_APP/I. Computer Systems/1.2 Programs are Translated by other Programs in Different Forms/1.2 Programs Are Translated by Other Programs into Different Forms.md":"cs_app/i.-computer-systems/1.2-programs-are-translated-by-other-programs-in-different-forms/1.2-programs-are-translated-by-other-programs-into-different-forms.html","CS_APP/I. Computer Systems/1.3 Pays to Understand How Compilation Systems Work/1.3 It pays to Understand How Compilation Systems Work.md":"cs_app/i.-computer-systems/1.3-pays-to-understand-how-compilation-systems-work/1.3-it-pays-to-understand-how-compilation-systems-work.html","CS_APP/I. Computer Systems/1.4 Processors Read and Interpret Instrucions Stored in Memory/1.4.0 Processors Read and Interpret Instructions Stored in Memory.md":"cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.0-processors-read-and-interpret-instructions-stored-in-memory.html","CS_APP/I. Computer Systems/1.4 Processors Read and Interpret Instrucions Stored in Memory/1.4.1 Hardware Organization of a System.md":"cs_app/i.-computer-systems/1.4-processors-read-and-interpret-instrucions-stored-in-memory/1.4.1-hardware-organization-of-a-system.html","CS_APP/I. Computer Systems/1.5 Caches Matter/1.5.0 Caches Matter.md":"cs_app/i.-computer-systems/1.5-caches-matter/1.5.0-caches-matter.html","CS_APP/I. Computer Systems/1.6 Storage Devices Form a Hierarchy/1.6.1 Storage Devices Form a Hierarchy.md":"cs_app/i.-computer-systems/1.6-storage-devices-form-a-hierarchy/1.6.1-storage-devices-form-a-hierarchy.html","CS_APP/I. Computer Systems/1.7 OS Manages the Hardware/1.7.0 The OS Manages the Hardware.md":"cs_app/i.-computer-systems/1.7-os-manages-the-hardware/1.7.0-the-os-manages-the-hardware.html","CS_APP/I. Computer Systems/1.8 Systems Comunicate with Other Systems Using Networks/1.8.0 Systems Communicate with Other Systems Using Networks.md":"cs_app/i.-computer-systems/1.8-systems-comunicate-with-other-systems-using-networks/1.8.0-systems-communicate-with-other-systems-using-networks.html","CS_APP/I. Computer Systems/1.9 Important Themes/1.9.0 Important Themes.md":"cs_app/i.-computer-systems/1.9-important-themes/1.9.0-important-themes.html","CS_APP/I. Computer Systems/1.9 Important Themes/1.9.2 Concurrency and Parallelism.md":"cs_app/i.-computer-systems/1.9-important-themes/1.9.2-concurrency-and-parallelism.html","CS_APP/I. Computer Systems/1.9 Important Themes/1.9.3 The Importance of Abstractions in Computer Systems.md":"cs_app/i.-computer-systems/1.9-important-themes/1.9.3-the-importance-of-abstractions-in-computer-systems.html","CS_APP/I. Computer Systems/1.9 Important Themes/Amdahl's Law.md":"cs_app/i.-computer-systems/1.9-important-themes/amdahl's-law.html","CS_APP/I. Computer Systems/1.0 Computer Systems.md":"cs_app/i.-computer-systems/1.0-computer-systems.html","CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.0 Information Storage.md":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.0-information-storage.html","CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.1 Hexadecimal Notation.md":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.1-hexadecimal-notation.html","CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.2 Data Sizes.md":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.2-data-sizes.html","CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.3 Addressing and Byte Ordering.md":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.3-addressing-and-byte-ordering.html","CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.4 Representing Strings.md":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.4-representing-strings.html","CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.5 Representing Code.md":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.5-representing-code.html","CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.6 Intro To Boolean Algebra.md":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.6-intro-to-boolean-algebra.html","CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.7 Bitwise operators.md":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.7-bitwise-operators.html","CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.8 Logical Operations in C.md":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.8-logical-operations-in-c.html","CS_APP/II. Representing and Manipulating Information/2.1 Information Storage/2.1.9 Shift Operations in C.md":"cs_app/ii.-representing-and-manipulating-information/2.1-information-storage/2.1.9-shift-operations-in-c.html","CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.0 Integer Representations.md":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.0-integer-representations.html","CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.1 Integral Data Types.md":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.1-integral-data-types.html","CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.2 Unsigned Encodings.md":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.2-unsigned-encodings.html","CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.3 Two's-Complement Encodings.md":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.3-two's-complement-encodings.html","CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.4 T2U & U2T.md":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.4-t2u-&-u2t.html","CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.5 Signed versus Unsigned in C.md":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.5-signed-versus-unsigned-in-c.html","CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.6 Expanding the Bit representation of a Number.md":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.6-expanding-the-bit-representation-of-a-number.html","CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.7 Truncating Numbers.md":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.7-truncating-numbers.html","CS_APP/II. Representing and Manipulating Information/2.2 Integer Representations/2.2.8 Advice on Signed versus Unsigned.md":"cs_app/ii.-representing-and-manipulating-information/2.2-integer-representations/2.2.8-advice-on-signed-versus-unsigned.html","CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.1 Unsigned Addition.md":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.1-unsigned-addition.html","CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.2 Two's-Complement Addition.md":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.2-two's-complement-addition.html","CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.3 Two's Complement Negation.md":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.3-two's-complement-negation.html","CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.4 Unsigned Multiplication.md":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.4-unsigned-multiplication.html","CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.5 Two's-complement multiplication.md":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.5-two's-complement-multiplication.html","CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.6 Multiplying by Constants.md":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.6-multiplying-by-constants.html","CS_APP/II. Representing and Manipulating Information/2.3 Integer Arithmetic/2.3.7 Dividing by Powers of 2.md":"cs_app/ii.-representing-and-manipulating-information/2.3-integer-arithmetic/2.3.7-dividing-by-powers-of-2.html","CS_APP/III. Machine-lever Representation of Programs/3.1 A Historical Perspective/3.0.0 Machine Level Representation of Programs.md":"cs_app/iii.-machine-lever-representation-of-programs/3.1-a-historical-perspective/3.0.0-machine-level-representation-of-programs.html","CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.0 Program Encodings.md":"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.0-program-encodings.html","CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.1 Machine-Level Code.md":"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.1-machine-level-code.html","CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.2 Code Examples.md":"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.2-code-examples.html","CS_APP/III. Machine-lever Representation of Programs/3.2 Program Encodings/3.2.3 Notes on Formatting.md":"cs_app/iii.-machine-lever-representation-of-programs/3.2-program-encodings/3.2.3-notes-on-formatting.html","CS_APP/III. Machine-lever Representation of Programs/3.3 Data Formats/3.3.0 Data Formats.md":"cs_app/iii.-machine-lever-representation-of-programs/3.3-data-formats/3.3.0-data-formats.html","CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.0 Accessing Information.md":"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.0-accessing-information.html","CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.1 Operand Specifiers.md":"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.1-operand-specifiers.html","CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.2 Data Movement Instructions.md":"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.2-data-movement-instructions.html","CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.3 Data Movement Example.md":"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.3-data-movement-example.html","CS_APP/III. Machine-lever Representation of Programs/3.4 Accessing Information/3.4.4 Pushing and Popping Stack Data.md":"cs_app/iii.-machine-lever-representation-of-programs/3.4-accessing-information/3.4.4-pushing-and-popping-stack-data.html","CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.0 Arithmetic and Logical Operations.md":"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.0-arithmetic-and-logical-operations.html","CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.1 Load Effective Address.md":"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.1-load-effective-address.html","CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.2 Unary and Binary Operations.md":"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.2-unary-and-binary-operations.html","CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.3 Shift Operations.md":"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.3-shift-operations.html","CS_APP/III. Machine-lever Representation of Programs/3.5 Arithmetic and Logical Operations/3.5.5 Special Arithmetic Operations.md":"cs_app/iii.-machine-lever-representation-of-programs/3.5-arithmetic-and-logical-operations/3.5.5-special-arithmetic-operations.html","CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.1 Condition Codes.md":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.1-condition-codes.html","CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.2 Accessing the Condition Codes.md":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.2-accessing-the-condition-codes.html","CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.3 Jump Instructions.md":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.3-jump-instructions.html","CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.4 Jump instruction Encodings.md":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.4-jump-instruction-encodings.html","CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.5 Conditional Branches with Conditional Control.md":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.5-conditional-branches-with-conditional-control.html","CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.6 Conditional Branches with Conditional Moves.md":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.6-conditional-branches-with-conditional-moves.html","CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.7 Loops.md":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.7-loops.html","CS_APP/III. Machine-lever Representation of Programs/3.6 Control/3.6.8 Switch Statements.md":"cs_app/iii.-machine-lever-representation-of-programs/3.6-control/3.6.8-switch-statements.html","CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7 Procedures.md":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7-procedures.html","CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.1 The Run-Time Stack.md":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.1-the-run-time-stack.html","CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.2 Control Transfer.md":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.2-control-transfer.html","CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.3 Data Transfer.md":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.3-data-transfer.html","CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.4 Local Storage on the Stack.md":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.4-local-storage-on-the-stack.html","CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.5 Local Storage in Registers.md":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.5-local-storage-in-registers.html","CS_APP/III. Machine-lever Representation of Programs/3.7 Procedures/3.7.6 Recursive Procedures.md":"cs_app/iii.-machine-lever-representation-of-programs/3.7-procedures/3.7.6-recursive-procedures.html","CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.1 Array Basic Principles.md":"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.1-array-basic-principles.html","CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.2 Pointer Arithmetic.md":"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.2-pointer-arithmetic.html","CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.3 Nested Arrays.md":"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.3-nested-arrays.html","CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.4 Fixed-Size Arrays.md":"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.4-fixed-size-arrays.html","CS_APP/III. Machine-lever Representation of Programs/3.8 Array Allocation and Access/3.8.5 Variable-Size Arrays.md":"cs_app/iii.-machine-lever-representation-of-programs/3.8-array-allocation-and-access/3.8.5-variable-size-arrays.html","CS_APP/III. Machine-lever Representation of Programs/3.9 Heterogeneous Data Structures/3.9.1 Structures.md":"cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.1-structures.html","CS_APP/III. Machine-lever Representation of Programs/3.9 Heterogeneous Data Structures/3.9.2 Unions.md":"cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.2-unions.html","CS_APP/III. Machine-lever Representation of Programs/3.9 Heterogeneous Data Structures/3.9.3 Data Alignment.md":"cs_app/iii.-machine-lever-representation-of-programs/3.9-heterogeneous-data-structures/3.9.3-data-alignment.html","CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.1 Understanding Pointers.md":"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.1-understanding-pointers.html","CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.3 Out-of-Bounds Memory References and Buffer Overflow.md":"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.3-out-of-bounds-memory-references-and-buffer-overflow.html","CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.4 Thwarting Buffer Overflow Attacks.md":"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.4-thwarting-buffer-overflow-attacks.html","CS_APP/III. Machine-lever Representation of Programs/3.10 Combining Control and Data in Machine-Level Programs/3.10.5 Supporting Variable-Size Stack Frames.md":"cs_app/iii.-machine-lever-representation-of-programs/3.10-combining-control-and-data-in-machine-level-programs/3.10.5-supporting-variable-size-stack-frames.html","CS_APP/IV. Processor Arch/4.1 Y86-64 ISA/4.1.1 Programmer-Visible State.md":"cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.1-programmer-visible-state.html","CS_APP/IV. Processor Arch/4.1 Y86-64 ISA/4.1.2 Y86-64 Instructions.md":"cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.2-y86-64-instructions.html","CS_APP/IV. Processor Arch/4.1 Y86-64 ISA/4.1.3 Instruction Encoding.md":"cs_app/iv.-processor-arch/4.1-y86-64-isa/4.1.3-instruction-encoding.html","CS_APP/IV. Processor Arch/Intro.md":"cs_app/iv.-processor-arch/intro.html","CS_APP/CS_APP.pdf":"cs_app/cs_app.html","":"site-lib/rss.xml","assets/Pasted image 20250807171802.png":"assets/pasted-image-20250807171802.png","assets/Pasted image 20250724134626.png":"assets/pasted-image-20250724134626.png","assets/Pasted image 20260122194808.png":"assets/pasted-image-20260122194808.png","assets/Pasted image 20260122211607.png":"assets/pasted-image-20260122211607.png","assets/Pasted image 20260122212355.png":"assets/pasted-image-20260122212355.png","assets/Pasted image 20260122172120.png":"assets/pasted-image-20260122172120.png","assets/Pasted image 20260122171049.png":"assets/pasted-image-20260122171049.png","assets/Pasted image 20251020154933.png":"assets/pasted-image-20251020154933.png","assets/Pasted image 20251018225151.png":"assets/pasted-image-20251018225151.png","assets/Pasted image 20250908124256.png":"assets/pasted-image-20250908124256.png","assets/Pasted image 20250908121209.png":"assets/pasted-image-20250908121209.png","assets/Pasted image 20250908121735.png":"assets/pasted-image-20250908121735.png","assets/Pasted image 20250715115553.png":"assets/pasted-image-20250715115553.png","assets/Pasted image 20250917213940.png":"assets/pasted-image-20250917213940.png","assets/Pasted image 20250908115829.png":"assets/pasted-image-20250908115829.png","assets/Pasted image 20250817140128.png":"assets/pasted-image-20250817140128.png","Indexes/Coding/Assembly x86/call.md":"indexes/coding/assembly-x86/call.md","assets/Pasted image 20250904134956.png":"assets/pasted-image-20250904134956.png","assets/Pasted image 20250904135618.png":"assets/pasted-image-20250904135618.png","assets/Pasted image 20250904135903.png":"assets/pasted-image-20250904135903.png","assets/Pasted image 20250904141340.png":"assets/pasted-image-20250904141340.png","assets/Pasted image 20250825133158.png":"assets/pasted-image-20250825133158.png","assets/Pasted image 20250819153309.png":"assets/pasted-image-20250819153309.png","Indexes/Coding/Assembly x86/JUMP.md":"indexes/coding/assembly-x86/jump.md","assets/Pasted image 20250821143128.png":"assets/pasted-image-20250821143128.png","assets/Pasted image 20250821143052.png":"assets/pasted-image-20250821143052.png","Indexes/Coding/Assembly x86/MOV.md":"indexes/coding/assembly-x86/mov.md","assets/Pasted image 20250818123607.png":"assets/pasted-image-20250818123607.png","assets/Pasted image 20250818124727.png":"assets/pasted-image-20250818124727.png","assets/Pasted image 20250818133441.png":"assets/pasted-image-20250818133441.png","assets/Pasted image 20250818134520.png":"assets/pasted-image-20250818134520.png","assets/Pasted image 20250818135026.png":"assets/pasted-image-20250818135026.png","assets/Pasted image 20250818141612.png":"assets/pasted-image-20250818141612.png","Indexes/Coding/Assembly x86/SET.md":"indexes/coding/assembly-x86/set.md","assets/Pasted image 20250821131150.png":"assets/pasted-image-20250821131150.png","assets/Pasted image 20250821131322.png":"assets/pasted-image-20250821131322.png","Indexes/Coding/Assembly x86/Operands - as.md":"indexes/coding/assembly-x86/operands-as.md","assets/Pasted image 20250817144946.png":"assets/pasted-image-20250817144946.png","assets/Pasted image 20250817164321.png":"assets/pasted-image-20250817164321.png","Indexes/Coding/Assembly x86/Unary Operations - as.md":"indexes/coding/assembly-x86/unary-operations-as.md","assets/Pasted image 20250819172841.png":"assets/pasted-image-20250819172841.png","Indexes/Coding/Assembly x86/Binary Operations - as.md":"indexes/coding/assembly-x86/binary-operations-as.md","assets/Pasted image 20250819173309.png":"assets/pasted-image-20250819173309.png","Indexes/Coding/Assembly x86/Shift Operations - as.md":"indexes/coding/assembly-x86/shift-operations-as.md","assets/Pasted image 20250820121350.png":"assets/pasted-image-20250820121350.png","Indexes/Coding/Assembly x86/leaq.md":"indexes/coding/assembly-x86/leaq.md","Indexes/Coding/Assembly x86/push & pop.md":"indexes/coding/assembly-x86/push-&-pop.md","assets/Pasted image 20250819150715.png":"assets/pasted-image-20250819150715.png","assets/Pasted image 20250807193243.png":"assets/pasted-image-20250807193243.png","assets/Pasted image 20250807193302.png":"assets/pasted-image-20250807193302.png","assets/Pasted image 20250807193731.png":"assets/pasted-image-20250807193731.png","assets/Pasted image 20250815131351.png":"assets/pasted-image-20250815131351.png","assets/Pasted image 20250815133752.png":"assets/pasted-image-20250815133752.png","assets/Pasted image 20250715184855.png":"assets/pasted-image-20250715184855.png","assets/Pasted image 20250814135551.png":"assets/pasted-image-20250814135551.png","assets/Pasted image 20250716204848.png":"assets/pasted-image-20250716204848.png","assets/Pasted image 20250717130734.png":"assets/pasted-image-20250717130734.png","assets/Pasted image 20250717141129.png":"assets/pasted-image-20250717141129.png","assets/Pasted image 20250808193539.png":"assets/pasted-image-20250808193539.png","assets/Pasted image 20250808193628.png":"assets/pasted-image-20250808193628.png","assets/Pasted image 20250808194016.png":"assets/pasted-image-20250808194016.png","assets/Pasted image 20250808164737.png":"assets/pasted-image-20250808164737.png","assets/Pasted image 20250806124238.png":"assets/pasted-image-20250806124238.png","assets/Pasted image 20250805221658.png":"assets/pasted-image-20250805221658.png","assets/Pasted image 20250805215808.png":"assets/pasted-image-20250805215808.png","assets/Pasted image 20250805220347.png":"assets/pasted-image-20250805220347.png","assets/Pasted image 20250805133858.png":"assets/pasted-image-20250805133858.png","assets/Pasted image 20250805140636.png":"assets/pasted-image-20250805140636.png","assets/Pasted image 20250805143818.png":"assets/pasted-image-20250805143818.png","assets/Pasted image 20250725183303.png":"assets/pasted-image-20250725183303.png","assets/Pasted image 20250725180054.png":"assets/pasted-image-20250725180054.png","assets/Pasted image 20250725180109.png":"assets/pasted-image-20250725180109.png","assets/Pasted image 20250725174630.png":"assets/pasted-image-20250725174630.png","assets/Pasted image 20250724145251.png":"assets/pasted-image-20250724145251.png","assets/Pasted image 20250722131129.png":"assets/pasted-image-20250722131129.png","assets/Pasted image 20250712193205.png":"assets/pasted-image-20250712193205.png","assets/Pasted image 20250720142153.png":"assets/pasted-image-20250720142153.png","assets/Pasted image 20250722122228.png":"assets/pasted-image-20250722122228.png","assets/Pasted image 20250716183124.png":"assets/pasted-image-20250716183124.png","assets/Pasted image 20250716131144.png":"assets/pasted-image-20250716131144.png","assets/Pasted image 20250715224120.png":"assets/pasted-image-20250715224120.png","assets/Pasted image 20250715174131.png":"assets/pasted-image-20250715174131.png","assets/Pasted image 20250715174158.png":"assets/pasted-image-20250715174158.png","assets/Pasted image 20250715124434.png":"assets/pasted-image-20250715124434.png","assets/Pasted image 20250712180214.png":"assets/pasted-image-20250712180214.png","assets/Pasted image 20250712174037.png":"assets/pasted-image-20250712174037.png","assets/Pasted image 20250712175559.png":"assets/pasted-image-20250712175559.png","Indexes/Cryptography/CBC - Cyber-Block Chaining.md":"indexes/cryptography/cbc-cyber-block-chaining.html","assets/Pasted image 20260128110417.png":"assets/pasted-image-20260128110417.png","assets/Pasted image 20260128110814.png":"assets/pasted-image-20260128110814.png"},"featureOptions":{"backlinks":{"featureId":"backlinks","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".footer","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Backlinks","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"tags":{"featureId":"tags","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showInlineTags":true,"showFrontmatterTags":true,"info_showInlineTags":{"show":true,"name":"","description":"Show tags defined inside the document at the top of the page.","placeholder":""},"info_showFrontmatterTags":{"show":true,"name":"","description":"Show tags defined in the frontmatter of the document at the top of the page.","placeholder":""}},"alias":{"featureId":"aliases","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Aliases","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"properties":{"featureId":"properties","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Properties","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_hideProperties":{"show":true,"name":"","description":"A list of properties to hide from the properties view","placeholder":""}},"fileNavigation":{"featureId":"file-navigation","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"showCustomIcons":false,"showDefaultFolderIcons":true,"showDefaultFileIcons":false,"defaultFolderIcon":"lucide//folder","defaultFileIcon":"lucide//file","defaultMediaIcon":"lucide//file-image","exposeStartingPath":true,"info_showCustomIcons":{"show":true,"name":"","description":"Show custom icons for files and folders","placeholder":""},"info_showDefaultFolderIcons":{"show":true,"name":"","description":"Show a default icon of a folder for every folder in the tree","placeholder":""},"info_showDefaultFileIcons":{"show":true,"name":"","description":"Show a default icon of a file for every file in the tree","placeholder":""},"info_defaultFolderIcon":{"show":true,"name":"","description":"The icon to use for folders. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultFileIcon":{"show":true,"name":"","description":"The icon to use for files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultMediaIcon":{"show":true,"name":"","description":"The icon to use for media files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_exposeStartingPath":{"show":true,"name":"","description":"Whether or not to show the current file in the file tree when the page is first loaded","placeholder":""},"includePath":"site-lib/html/file-tree.html"},"search":{"featureId":"search","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar .topbar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Search...","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"outline":{"featureId":"outline","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Outline","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"startCollapsed":false,"minCollapseDepth":0,"info_startCollapsed":{"show":true,"name":"","description":"Should the outline start collapsed?","placeholder":""},"info_minCollapseDepth":{"show":true,"name":"","description":"Only allow outline items to be collapsed if they are at least this many levels deep in the tree.","placeholder":"","dropdownOptions":{"1":1,"2":2,"No Collapse":100}}},"themeToggle":{"featureId":"theme-toggle","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"graphView":{"featureId":"graph-view","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Graph","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showOrphanNodes":true,"showAttachments":false,"allowGlobalGraph":true,"allowExpand":true,"attractionForce":1,"linkLength":15,"repulsionForce":80,"centralForce":2,"edgePruning":100,"minNodeRadius":3,"maxNodeRadius":5,"info_showOrphanNodes":{"show":true,"name":"","description":"Show nodes that are not connected to any other nodes.","placeholder":""},"info_showAttachments":{"show":true,"name":"","description":"Show attachments like images and PDFs as nodes in the graph.","placeholder":""},"info_allowGlobalGraph":{"show":true,"name":"","description":"Allow the user to view the global graph of all nodes.","placeholder":""},"info_allowExpand":{"show":true,"name":"","description":"Allow the user to pop-out the graph view to take up the whole screen","placeholder":""},"info_attractionForce":{"show":true,"name":"","description":"How much should linked nodes attract each other? This will make the graph appear more clustered.","placeholder":""},"info_linkLength":{"show":true,"name":"","description":"How long should the links between nodes be? The shorter the links the more connected nodes will cluster together.","placeholder":""},"info_repulsionForce":{"show":true,"name":"","description":"How much should nodes repel each other? This will make disconnected parts more spread out.","placeholder":""},"info_centralForce":{"show":true,"name":"","description":"How much should nodes be attracted to the center? This will make the graph appear more dense and circular.","placeholder":""},"info_edgePruning":{"show":true,"name":"","description":"Edges with a length above this threshold will not be rendered, however they will still contribute to the simulation. This can help large tangled graphs look more organised. Hovering over a node will still display these links.","placeholder":""},"info_minNodeRadius":{"show":true,"name":"","description":"How small should the smallest nodes be? The smaller a node is the less it will attract other nodes.","placeholder":""},"info_maxNodeRadius":{"show":true,"name":"","description":"How large should the largest nodes be? Nodes are sized by how many links they have. The larger a node is the more it will attract other nodes. This can be used to create a good grouping around the most important nodes.","placeholder":""}},"sidebar":{"featureId":"sidebar","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"allowResizing":true,"allowCollapsing":true,"rightDefaultWidth":"20em","leftDefaultWidth":"15em","info_allowResizing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be resized","placeholder":""},"info_allowCollapsing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be collapsed","placeholder":""},"info_rightDefaultWidth":{"show":true,"name":"","description":"The default width of the right sidebar","placeholder":""},"info_leftDefaultWidth":{"show":true,"name":"","description":"The default width of the left sidebar","placeholder":""}},"customHead":{"featureId":"custom-head","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"head","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"sourcePath":"","info_sourcePath":{"show":true,"name":"","description":"The local path to the source .html file which will be included.","placeholder":"","fileInputOptions":{"makeRelativeToVault":true,"browseButton":true}},"includePath":"site-lib/html/custom-head.html"},"document":{"featureId":"obsidian-document","enabled":true,"unavailable":false,"alwaysEnabled":true,"hideSettingsButton":false,"allowFoldingLists":true,"allowFoldingHeadings":true,"documentWidth":"60em","info_allowFoldingLists":{"show":true,"name":"","description":"Whether or not to allow lists to be folded","placeholder":""},"info_allowFoldingHeadings":{"show":true,"name":"","description":"Whether or not to allow headings to be folded","placeholder":""},"info_documentWidth":{"show":true,"name":"","description":"The width of the document","placeholder":""}},"rss":{"featureId":"rss","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"siteUrl":"canekzamudio.com","authorName":"Canek","info_siteUrl":{"show":true,"name":"","description":"The url that this site will be hosted at","placeholder":"https://example.com/mysite"},"info_authorName":{"show":true,"name":"","description":"The name of the author of the site","placeholder":""}},"linkPreview":{"featureId":"link-preview","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":true}},"modifiedTime":1769640643669,"siteName":"GZ","vaultName":"Anom","exportRoot":"","baseURL":"canekzamudio.com","pluginVersion":"1.9.2","themeName":"obsidian-current-theme","bodyClasses":"publish css-settings-manager is-frameless is-hidden-frameless styled-scrollbars show-inline-title show-ribbon ctp-latte ctp-mocha-old ctp-accent-mauve anp-callout-block anp-callout-color-toggle anp-latex-inline-mauve anp-latex-block-mauve anp-table-toggle anp-table-width anp-table-auto anp-hide-external-link-icon anp-h1-red anp-h1-divider anp-h2-peach anp-h3-green anp-h4-teal anp-h5-lavender anp-h6-mauve anp-decoration-toggle anp-bold-lavender anp-highlight-yellow anp-canvas-dark-bg anp-default-tab anp-theme-ext-dark ctp-luminescence-light ctp-material-mint-dark is-focused","hasFavicon":false}